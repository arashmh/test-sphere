<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>TerrainShader Pro | Environment Studio</title>
    <style>
        :root {
            --bg-color: #121212;
            --panel-color: #1e1e1e;
            --text-color: #e0e0e0;
            --accent-color: #4cc9f0;
            --accent-hover: #3a9bb8;
            --border-color: #333;
            --input-bg: #2a2a2a;
        }

        body { margin: 0; overflow: hidden; font-family: 'Segoe UI', sans-serif; background: var(--bg-color); color: var(--text-color); display: flex; height: 100vh; }
        
        /* Dashboard */
        #dashboard {
            width: 340px; background: var(--panel-color); border-right: 1px solid var(--border-color);
            display: flex; flex-direction: column; z-index: 10; box-shadow: 4px 0 15px rgba(0,0,0,0.4);
        }
        .header { padding: 20px; border-bottom: 1px solid var(--border-color); font-weight: 700; font-size: 1.2em; letter-spacing: 1px; color: #fff; background: linear-gradient(45deg, #1e1e1e, #252525); }
        .header span { color: var(--accent-color); }
        .scroll-area { flex: 1; overflow-y: auto; padding: 15px; }
        .scroll-area::-webkit-scrollbar { width: 6px; }
        .scroll-area::-webkit-scrollbar-thumb { background: #444; border-radius: 3px; }

        /* Panels */
        .panel { background: #262626; border: 1px solid var(--border-color); border-radius: 6px; margin-bottom: 16px; overflow: hidden; }
        .panel-header { padding: 12px 15px; background: #2f2f2f; font-size: 0.85em; font-weight: 600; text-transform: uppercase; letter-spacing: 0.5px; border-bottom: 1px solid var(--border-color); display: flex; justify-content: space-between; align-items: center; }
        .panel-content { padding: 15px; }

        /* Controls */
        .control-group { margin-bottom: 15px; }
        .control-group label { display: flex; justify-content: space-between; margin-bottom: 6px; font-size: 0.85em; color: #aaa; }
        input[type="range"] { width: 100%; -webkit-appearance: none; background: transparent; cursor: pointer; }
        input[type="range"]::-webkit-slider-runnable-track { width: 100%; height: 4px; background: #444; border-radius: 2px; }
        input[type="range"]::-webkit-slider-thumb { -webkit-appearance: none; height: 14px; width: 14px; border-radius: 50%; background: var(--accent-color); margin-top: -5px; box-shadow: 0 0 5px rgba(0,0,0,0.5); }
        input[type="color"] { width: 100%; height: 30px; border: none; background: none; cursor: pointer; }
        
        button { width: 100%; padding: 10px; background: var(--input-bg); border: 1px solid var(--border-color); color: white; border-radius: 4px; cursor: pointer; font-size: 0.9em; transition: 0.2s; margin-bottom: 6px; }
        button:hover { background: #353535; }
        button.active { background: var(--accent-color); border-color: var(--accent-color); color: #000; font-weight: bold; }
        button.primary { background: var(--accent-color); color: #000; font-weight: bold; border: none; }
        button.primary:hover { background: var(--accent-hover); }

        /* Grid Layouts */
        .tool-grid { display: grid; grid-template-columns: 1fr 1fr; gap: 8px; }
        
        /* Viewport */
        #viewport { flex: 1; position: relative; background: #000; }
        #overlay { position: absolute; top: 20px; left: 20px; pointer-events: none; background: rgba(0,0,0,0.6); padding: 10px 15px; border-radius: 4px; font-size: 0.85em; color: #fff; backdrop-filter: blur(4px); border: 1px solid rgba(255,255,255,0.1); }
        
        /* Modal */
        #code-modal { display: none; position: fixed; top: 0; left: 0; width: 100%; height: 100%; background: rgba(0,0,0,0.9); z-index: 100; justify-content: center; align-items: center; }
        .modal-box { background: #1e1e1e; width: 80%; height: 85%; border-radius: 8px; display: flex; flex-direction: column; border: 1px solid #444; box-shadow: 0 0 40px rgba(0,0,0,0.6); }
        textarea { flex: 1; background: #151515; color: #aaddff; border: none; padding: 20px; font-family: 'Consolas', monospace; resize: none; font-size: 0.9em; line-height: 1.5; outline: none; }
    </style>
    
    <script type="importmap">
        {
            "imports": {
                "three": "https://unpkg.com/three@0.160.0/build/three.module.js",
                "three/addons/": "https://unpkg.com/three@0.160.0/examples/jsm/"
            }
        }
    </script>
</head>
<body>

    <!-- SIDEBAR -->
    <div id="dashboard">
        <div class="header">Terrain<span>Shader Pro</span></div>
        <div class="scroll-area">

            <!-- Tools -->
            <div class="panel">
                <div class="panel-header">Sculpting Tools</div>
                <div class="panel-content">
                    <div class="tool-grid">
                        <button class="active" onclick="setTool('mountain', this)">‚õ∞Ô∏è Mountain</button>
                        <button onclick="setTool('valley', this)">üìâ Valley</button>
                        <button onclick="setTool('plateau', this)">üü¶ Plateau</button>
                        <button onclick="setTool('smooth', this)">üí® Smooth</button>
                    </div>
                    <div class="control-group" style="margin-top:10px;">
                        <label>Brush Size <span id="val-radius">25</span></label>
                        <input type="range" id="inp-radius" min="5" max="60" value="25">
                    </div>
                    <div class="control-group">
                        <label>Intensity <span id="val-str">5</span></label>
                        <input type="range" id="inp-str" min="1" max="20" value="5">
                    </div>
                </div>
            </div>

            <!-- Atmosphere -->
            <div class="panel">
                <div class="panel-header">Atmosphere & Time</div>
                <div class="panel-content">
                    <div class="control-group">
                        <label>Time of Day <span id="val-time">12:00</span></label>
                        <input type="range" id="inp-time" min="0" max="24" step="0.1" value="12">
                    </div>
                    <div class="control-group">
                        <label>Water Level</label>
                        <input type="range" id="inp-water" min="-20" max="20" value="0">
                    </div>
                    <div class="control-group">
                        <label>Fog Density</label>
                        <input type="range" id="inp-fog" min="0" max="0.02" step="0.001" value="0.005">
                    </div>
                </div>
            </div>

            <!-- Shader Colors -->
            <div class="panel">
                <div class="panel-header">Biome Shaders</div>
                <div class="panel-content">
                    <div class="control-group"><label>Snow Level</label><input type="range" id="sh-snow-h" min="10" max="80" value="45"></div>
                    <div class="control-group"><label>Grass Color</label><input type="color" id="col-grass" value="#416135"></div>
                    <div class="control-group"><label>Rock Color</label><input type="color" id="col-rock" value="#5a4d41"></div>
                    <div class="control-group"><label>Sand Color</label><input type="color" id="col-sand" value="#d4c79e"></div>
                    <div class="control-group"><label>Water Color</label><input type="color" id="col-water" value="#006994"></div>
                </div>
            </div>

            <!-- Nature -->
            <div class="panel">
                <div class="panel-header">Vegetation System</div>
                <div class="panel-content">
                    <button onclick="scatterVegetation()">üå≤ Regenerate Forest</button>
                    <div class="control-group" style="margin-top:10px">
                        <label>Tree Density</label>
                        <input type="range" id="inp-trees" min="0" max="5000" value="1000">
                    </div>
                </div>
            </div>

            <div class="panel">
                <div class="panel-content">
                    <button class="primary" onclick="exportSystem()">Generate Full Code</button>
                </div>
            </div>

        </div>
    </div>

    <!-- VIEWPORT -->
    <div id="viewport">
        <div id="overlay">
            LMB: Sculpt ‚Ä¢ RMB: Rotate ‚Ä¢ Scroll: Zoom<br>
            <span style="color:#aaa; font-size:0.9em">Sun position affects lighting & shadows</span>
        </div>
    </div>

    <!-- CODE WINDOW -->
    <div id="code-modal">
        <div class="modal-box">
            <div style="padding:15px; border-bottom:1px solid #444; background:#222; display:flex; justify-content:space-between;">
                <span style="color:#fff; font-weight:bold">Generated Project Code</span>
                <button onclick="document.getElementById('code-modal').style.display='none'" style="width:auto; padding:5px 15px; margin:0;">Close</button>
            </div>
            <textarea id="code-output" readonly></textarea>
        </div>
    </div>

    <!-- MAIN LOGIC -->
    <script type="module">
        import * as THREE from 'three';
        import { OrbitControls } from 'three/addons/controls/OrbitControls.js';
        import { Sky } from 'three/addons/objects/Sky.js';
        import { SimplexNoise } from 'three/addons/math/SimplexNoise.js';

        // --- GLOBALS ---
        let scene, camera, renderer, controls;
        let terrainMesh, waterMesh, brushHelper;
        let sun, sky;
        let treesMesh, stonesMesh;
        
        // Data
        const SEGMENTS = 256;
        const SIZE = 400;
        const heightData = new Float32Array((SEGMENTS+1)*(SEGMENTS+1)).fill(0);
        
        // State
        const state = {
            tool: 'mountain',
            radius: 25,
            strength: 5,
            isDrawing: false,
            time: 12,
            waterLevel: 0,
            snowLevel: 45,
            colors: {
                grass: new THREE.Color('#416135'),
                rock: new THREE.Color('#5a4d41'),
                sand: new THREE.Color('#d4c79e'),
                water: new THREE.Color('#006994'),
                snow: new THREE.Color('#ffffff')
            }
        };

        // --- SHADERS ---
        
        const terrainVertexShader = `
            varying vec2 vUv;
            varying vec3 vNormal;
            varying vec3 vPosition;
            varying float vSlope;
            
            void main() {
                vUv = uv;
                // Calculate position slightly differently to support lighting calculation in fragment if needed
                vec4 worldPosition = modelMatrix * vec4(position, 1.0);
                vPosition = worldPosition.xyz;
                
                // Normal in world space
                vNormal = normalize(mat3(modelMatrix) * normal);
                
                // Slope: 1.0 = up, 0.0 = vertical wall
                vSlope = dot(vNormal, vec3(0.0, 1.0, 0.0));
                
                gl_Position = projectionMatrix * viewMatrix * worldPosition;
            }
        `;

        const terrainFragmentShader = `
            uniform vec3 uColorGrass;
            uniform vec3 uColorRock;
            uniform vec3 uColorSand;
            uniform vec3 uColorSnow;
            uniform float uSnowLevel;
            uniform float uSandLevel;
            
            // Lighting
            uniform vec3 uSunDirection;
            uniform vec3 uSunColor;
            uniform vec3 uAmbientColor;

            varying vec3 vNormal;
            varying vec3 vPosition;
            varying float vSlope;

            // Simple noise function for shader transitions
            float hash(vec2 p) { return fract(1e4 * sin(17.0 * p.x + p.y * 0.1) * (0.1 + abs(sin(p.y * 13.0 + p.x)))); }

            void main() {
                float h = vPosition.y;
                
                // Base lighting (Lambert)
                float diff = max(dot(vNormal, uSunDirection), 0.0);
                vec3 lighting = uAmbientColor + uSunColor * diff * 0.8; // simple day/night intensity

                // --- Texturing / Mixing ---
                vec3 col = uColorGrass;

                // 1. Rock (Slope based)
                // If slope < 0.7 (steeper), blend in rock. 
                // Add noise to the blend to look natural
                float rockNoise = hash(vPosition.xz * 0.1);
                float rockFactor = smoothstep(0.7 + rockNoise*0.1, 0.4, vSlope);
                col = mix(col, uColorRock, rockFactor);

                // 2. Sand (Height based, low)
                float sandFactor = 1.0 - smoothstep(uSandLevel, uSandLevel + 3.0, h);
                col = mix(col, uColorSand, sandFactor);

                // 3. Snow (Height based, high)
                // Snow also prefers flat surfaces (it falls off cliffs)
                float snowHeight = uSnowLevel + (rockNoise * 5.0);
                float snowFactor = smoothstep(snowHeight, snowHeight + 10.0, h);
                snowFactor *= smoothstep(0.3, 0.6, vSlope); // Remove snow from cliffs
                col = mix(col, uColorSnow, snowFactor);

                // Apply lighting
                gl_FragColor = vec4(col * lighting, 1.0);
                
                // Simple fog
                // float depth = gl_FragCoord.z / gl_FragCoord.w;
                // float fogFactor = smoothstep(200.0, 400.0, depth);
                // gl_FragColor = mix(gl_FragColor, vec4(0.5,0.6,0.7,1.0), fogFactor);
            }
        `;

        const waterVertexShader = `
            uniform float uTime;
            varying vec2 vUv;
            varying vec3 vPosition;

            void main() {
                vUv = uv;
                vec3 pos = position;
                
                // Simple sine waves
                float wave = sin(pos.x * 0.1 + uTime) * 0.5 + sin(pos.z * 0.08 + uTime * 0.8) * 0.5;
                pos.y += wave;

                vec4 worldPosition = modelMatrix * vec4(pos, 1.0);
                vPosition = worldPosition.xyz;
                gl_Position = projectionMatrix * viewMatrix * worldPosition;
            }
        `;

        const waterFragmentShader = `
            uniform vec3 uColorWater;
            uniform vec3 uSunDirection;
            uniform vec3 uSunColor;
            
            varying vec3 vPosition;
            
            void main() {
                // Simple fresnel-ish look
                vec3 viewVector = normalize(cameraPosition - vPosition);
                vec3 normal = vec3(0.0, 1.0, 0.0); // Simplified normal for water plane
                
                // Specular reflection of sun
                vec3 halfDir = normalize(uSunDirection + viewVector);
                float spec = pow(max(dot(normal, halfDir), 0.0), 100.0);
                
                vec3 col = uColorWater;
                col += uSunColor * spec;
                
                // Transparency based on nothing (uniform opacity for now)
                gl_FragColor = vec4(col, 0.85); 
            }
        `;

        // --- INIT ---

        function init() {
            const container = document.getElementById('viewport');

            // Scene
            scene = new THREE.Scene();

            // Camera
            camera = new THREE.PerspectiveCamera(55, container.clientWidth / container.clientHeight, 1, 2000);
            camera.position.set(0, 80, 200);

            // Renderer
            renderer = new THREE.WebGLRenderer({ antialias: true, alpha: false });
            renderer.setSize(container.clientWidth, container.clientHeight);
            renderer.shadowMap.enabled = true;
            renderer.toneMapping = THREE.ACESFilmicToneMapping;
            renderer.toneMappingExposure = 0.5;
            container.appendChild(renderer.domElement);

            // Controls
            controls = new OrbitControls(camera, renderer.domElement);
            controls.enableDamping = true;
            controls.maxPolarAngle = Math.PI / 2 - 0.02;

            // --- Sun & Sky ---
            sky = new Sky();
            sky.scale.setScalar(450000);
            scene.add(sky);

            sun = new THREE.DirectionalLight(0xffffff, 1.5);
            sun.position.set(100, 100, 100);
            sun.castShadow = true;
            sun.shadow.mapSize.width = 2048;
            sun.shadow.mapSize.height = 2048;
            sun.shadow.camera.near = 0.5;
            sun.shadow.camera.far = 500;
            sun.shadow.camera.left = -SIZE/2;
            sun.shadow.camera.right = SIZE/2;
            sun.shadow.camera.top = SIZE/2;
            sun.shadow.camera.bottom = -SIZE/2;
            scene.add(sun);
            
            // --- Terrain ---
            const geo = new THREE.PlaneGeometry(SIZE, SIZE, SEGMENTS, SEGMENTS);
            geo.rotateX(-Math.PI / 2);
            
            // Custom Shader Material
            const mat = new THREE.ShaderMaterial({
                uniforms: {
                    uColorGrass: { value: state.colors.grass },
                    uColorRock: { value: state.colors.rock },
                    uColorSand: { value: state.colors.sand },
                    uColorSnow: { value: state.colors.snow },
                    uSnowLevel: { value: state.snowLevel },
                    uSandLevel: { value: state.waterLevel + 2.0 },
                    uSunDirection: { value: new THREE.Vector3(0,1,0) },
                    uSunColor: { value: new THREE.Color(0xffffff) },
                    uAmbientColor: { value: new THREE.Color(0x404040) }
                },
                vertexShader: terrainVertexShader,
                fragmentShader: terrainFragmentShader,
                side: THREE.DoubleSide
            });

            terrainMesh = new THREE.Mesh(geo, mat);
            terrainMesh.receiveShadow = true;
            terrainMesh.castShadow = true;
            scene.add(terrainMesh);

            // --- Water ---
            const waterGeo = new THREE.PlaneGeometry(SIZE, SIZE, 64, 64);
            waterGeo.rotateX(-Math.PI/2);
            const waterMat = new THREE.ShaderMaterial({
                uniforms: {
                    uTime: { value: 0 },
                    uColorWater: { value: state.colors.water },
                    uSunDirection: { value: new THREE.Vector3(0,1,0) },
                    uSunColor: { value: new THREE.Color(0xffffff) }
                },
                vertexShader: waterVertexShader,
                fragmentShader: waterFragmentShader,
                transparent: true,
                side: THREE.DoubleSide
            });
            waterMesh = new THREE.Mesh(waterGeo, waterMat);
            waterMesh.position.y = state.waterLevel;
            scene.add(waterMesh);

            // --- Brush Cursor ---
            const bGeo = new THREE.RingGeometry(0.5, 1, 32);
            bGeo.rotateX(-Math.PI/2);
            brushHelper = new THREE.Mesh(bGeo, new THREE.MeshBasicMaterial({ color: 0xff0000, transparent:true, opacity:0.5 }));
            scene.add(brushHelper);

            // Input Events
            container.addEventListener('pointermove', onPointerMove);
            container.addEventListener('pointerdown', onPointerDown);
            container.addEventListener('pointerup', onPointerUp);
            window.addEventListener('resize', onResize);

            initUI();
            updateSunPosition();
            scatterVegetation(); // Initial trees
            animate();
        }

        // --- SCULPTING LOGIC ---

        const raycaster = new THREE.Raycaster();
        const pointer = new THREE.Vector2();

        function onPointerMove(e) {
            const rect = renderer.domElement.getBoundingClientRect();
            pointer.x = ((e.clientX - rect.left) / rect.width) * 2 - 1;
            pointer.y = -((e.clientY - rect.top) / rect.height) * 2 + 1;

            raycaster.setFromCamera(pointer, camera);
            const intersects = raycaster.intersectObject(terrainMesh);

            if (intersects.length > 0) {
                const pt = intersects[0].point;
                brushHelper.position.copy(pt);
                brushHelper.position.y = Math.max(pt.y + 1, state.waterLevel + 1);
                brushHelper.scale.set(state.radius, state.radius, state.radius);
                brushHelper.visible = true;

                if (state.isDrawing) applySculpt(pt);
            } else {
                brushHelper.visible = false;
            }
        }

        function onPointerDown(e) {
            if (e.button === 0) {
                state.isDrawing = true;
                controls.enabled = false; // Disable orbit while sculpting
                // Initial click action
                raycaster.setFromCamera(pointer, camera);
                const intersects = raycaster.intersectObject(terrainMesh);
                if (intersects.length > 0) applySculpt(intersects[0].point);
            }
        }

        function onPointerUp() {
            state.isDrawing = false;
            controls.enabled = true;
            // Re-calc trees after sculpting session? 
            // For performance, let's keep trees static until button pressed or update them inefficiently.
            // Better: update Y of trees in loop.
            updateVegetationY();
        }

        function applySculpt(center) {
            const posAttr = terrainMesh.geometry.attributes.position;
            const halfSize = SIZE / 2;
            
            // Convert world to grid
            const gridX = Math.floor(((center.x + halfSize) / SIZE) * SEGMENTS);
            const gridZ = Math.floor(((center.z + halfSize) / SIZE) * SEGMENTS);
            const rGrid = Math.ceil((state.radius / SIZE) * SEGMENTS);
            
            let dirty = false;

            const startX = Math.max(0, gridX - rGrid);
            const endX = Math.min(SEGMENTS, gridX + rGrid);
            const startZ = Math.max(0, gridZ - rGrid);
            const endZ = Math.min(SEGMENTS, gridZ + rGrid);

            for (let x = startX; x <= endX; x++) {
                for (let z = startZ; z <= endZ; z++) {
                    const dx = x - gridX;
                    const dz = z - gridZ;
                    const dist = Math.sqrt(dx*dx + dz*dz);
                    
                    if (dist < rGrid) {
                        const idx = x + z * (SEGMENTS + 1);
                        const oldY = heightData[idx];
                        
                        // Gaussianish brush
                        const factor = Math.cos((dist/rGrid) * (Math.PI/2));
                        let delta = state.strength * factor * 0.4;

                        let newY = oldY;
                        
                        if (state.tool === 'mountain') newY += delta;
                        if (state.tool === 'valley') newY -= delta;
                        if (state.tool === 'plateau') {
                            // Lerp towards center height
                            const centerH = brushHelper.position.y - 1; // Approx
                            newY = THREE.MathUtils.lerp(oldY, centerH, 0.1 * factor);
                        }
                        if (state.tool === 'smooth') {
                            // Simple average with center? No, just diminish slope.
                            // Simplified smooth: move towards 0 or average.
                            // We'll just dampen towards the neighbor average (simulated by lerping to previous value less?)
                            // Let's just flatten peaks.
                            newY = THREE.MathUtils.lerp(oldY, oldY * 0.95, factor * 0.5);
                        }

                        if (newY !== oldY) {
                            heightData[idx] = newY;
                            posAttr.setY(idx, newY);
                            dirty = true;
                        }
                    }
                }
            }

            if (dirty) {
                posAttr.needsUpdate = true;
                terrainMesh.geometry.computeVertexNormals();
            }
        }

        // --- VEGETATION ---
        
        window.scatterVegetation = function() {
            if (treesMesh) { scene.remove(treesMesh); treesMesh.dispose(); }
            
            const count = parseInt(document.getElementById('inp-trees').value);
            if (count === 0) return;

            // Simple Cone Tree
            const geom = new THREE.ConeGeometry(1, 4, 8);
            geom.translate(0, 2, 0); // pivot at bottom
            const mat = new THREE.MeshLambertMaterial({ color: 0x2d4c1e });
            treesMesh = new THREE.InstancedMesh(geom, mat, count);
            treesMesh.castShadow = true;
            treesMesh.receiveShadow = true;

            const dummy = new THREE.Object3D();
            const posAttr = terrainMesh.geometry.attributes.position;
            const normAttr = terrainMesh.geometry.attributes.normal;

            let placed = 0;
            for(let i=0; i<count * 2; i++) { // Try more times than count
                if (placed >= count) break;

                const rx = Math.floor(Math.random() * SEGMENTS);
                const rz = Math.floor(Math.random() * SEGMENTS);
                const idx = rx + rz * (SEGMENTS + 1);

                const y = posAttr.getY(idx);
                const nx = normAttr.getX(idx);
                const ny = normAttr.getY(idx);
                const nz = normAttr.getZ(idx);

                // Rules: Not underwater, not on snow, not on steep slopes
                if (y > state.waterLevel + 1 && y < state.snowLevel - 5) {
                    // Check slope (ny approx 1 is flat)
                    if (ny > 0.8) {
                        // Position
                        const x = posAttr.getX(idx);
                        const z = posAttr.getZ(idx);
                        
                        dummy.position.set(x, y, z);
                        
                        // Random Scale
                        const s = 1 + Math.random();
                        dummy.scale.set(s, s * (0.8 + Math.random()*0.4), s);
                        
                        dummy.updateMatrix();
                        treesMesh.setMatrixAt(placed, dummy.matrix);
                        placed++;
                    }
                }
            }
            treesMesh.count = placed; // Update actual count
            scene.add(treesMesh);
        }

        function updateVegetationY() {
            if (!treesMesh) return;
            const dummy = new THREE.Object3D();
            const posAttr = terrainMesh.geometry.attributes.position;
            const matrix = new THREE.Matrix4();
            const position = new THREE.Vector3();

            for(let i=0; i<treesMesh.count; i++) {
                treesMesh.getMatrixAt(i, matrix);
                position.setFromMatrixPosition(matrix);
                
                // Find height at this X,Z
                // Simple nearest vertex lookup
                const halfSize = SIZE/2;
                const gx = Math.round(((position.x + halfSize)/SIZE)*SEGMENTS);
                const gz = Math.round(((position.z + halfSize)/SIZE)*SEGMENTS);
                
                if (gx >= 0 && gx <= SEGMENTS && gz >=0 && gz <= SEGMENTS) {
                    const idx = gx + gz * (SEGMENTS+1);
                    const h = posAttr.getY(idx);
                    
                    // If underwater now, hide it? Or just move it.
                    if (h < state.waterLevel) {
                         matrix.makeScale(0,0,0); // Hide
                    } else {
                        // Reconstruct matrix with new Y
                        // Extract scale
                        const sx = new THREE.Vector3();
                        matrix.decompose(position, new THREE.Quaternion(), sx);
                        
                        dummy.position.set(position.x, h, position.z);
                        dummy.scale.copy(sx);
                        dummy.updateMatrix();
                        treesMesh.setMatrixAt(i, dummy.matrix);
                    }
                }
            }
            treesMesh.instanceMatrix.needsUpdate = true;
        }

        // --- ATMOSPHERE & TIME ---

        function updateSunPosition() {
            const time = state.time; // 0 - 24
            // Map 6am to 0 rad (sunrise), 12 to PI/2 (noon), 18 to PI (set), etc.
            // Let's do a simple orbit.
            // 0 = midnight, 12 = noon
            const theta = ((time - 6) / 24) * Math.PI * 2; 
            const phi = Math.PI * (0.5 - 0.45 * Math.cos(theta)); // Elevation
            const sunX = Math.cos(phi) * Math.cos(theta);
            const sunY = Math.sin(phi); // height
            const sunZ = Math.cos(phi) * Math.sin(theta);

            const distance = 400;
            sun.position.set(sunX*distance, sunY*distance, sunZ*distance);

            // Sun Color & Intensity based on height
            if (sunY < 0.1) {
                // Sunset / Night
                sun.intensity = Math.max(0, sunY * 5);
                scene.fog = new THREE.FogExp2(0x050510, 0.002);
                terrainMesh.material.uniforms.uAmbientColor.value.setHex(0x1a1a2e);
            } else {
                sun.intensity = 1.5;
                scene.fog = new THREE.FogExp2(0xcceeff, document.getElementById('inp-fog').value);
                terrainMesh.material.uniforms.uAmbientColor.value.setHex(0x404040);
            }

            // Update Sky Shader
            const uniforms = sky.material.uniforms;
            uniforms['sunPosition'].value.copy(sun.position);
            uniforms['rayleigh'].value = 2;
            uniforms['turbidity'].value = 10;
            uniforms['mieCoefficient'].value = 0.005;
            uniforms['mieDirectionalG'].value = 0.7;

            // Update Terrain Shader Sun
            const sunDir = sun.position.clone().normalize();
            terrainMesh.material.uniforms.uSunDirection.value.copy(sunDir);
            waterMesh.material.uniforms.uSunDirection.value.copy(sunDir);
            
            // Render call to update shadows
            if(sunY <= 0) sun.castShadow = false;
            else sun.castShadow = true;
        }

        // --- ANIMATION ---
        
        function animate() {
            requestAnimationFrame(animate);
            
            const time = performance.now() * 0.001;
            waterMesh.material.uniforms.uTime.value = time;
            
            controls.update();
            renderer.render(scene, camera);
        }

        function onResize() {
            const el = document.getElementById('viewport');
            camera.aspect = el.clientWidth / el.clientHeight;
            camera.updateProjectionMatrix();
            renderer.setSize(el.clientWidth, el.clientHeight);
        }

        // --- UI BINDINGS ---
        
        window.setTool = (t, el) => {
            state.tool = t;
            document.querySelectorAll('.tool-grid button').forEach(b => b.classList.remove('active'));
            el.classList.add('active');
        };

        function initUI() {
            // Brushes
            document.getElementById('inp-radius').addEventListener('input', e => { state.radius = parseFloat(e.target.value); document.getElementById('val-radius').innerText=state.radius; });
            document.getElementById('inp-str').addEventListener('input', e => { state.strength = parseFloat(e.target.value); document.getElementById('val-str').innerText=state.strength; });
            
            // Env
            document.getElementById('inp-time').addEventListener('input', e => {
                state.time = parseFloat(e.target.value);
                const hours = Math.floor(state.time);
                const mins = Math.floor((state.time - hours) * 60);
                document.getElementById('val-time').innerText = `${hours}:${mins<10?'0'+mins:mins}`;
                updateSunPosition();
            });

            document.getElementById('inp-water').addEventListener('input', e => {
                state.waterLevel = parseFloat(e.target.value);
                waterMesh.position.y = state.waterLevel;
                terrainMesh.material.uniforms.uSandLevel.value = state.waterLevel + 2.0;
                updateVegetationY();
            });

            document.getElementById('inp-fog').addEventListener('input', e => {
                scene.fog.density = parseFloat(e.target.value);
            });

            // Shaders
            document.getElementById('sh-snow-h').addEventListener('input', e => terrainMesh.material.uniforms.uSnowLevel.value = parseFloat(e.target.value));
            
            const bindColor = (id, uniform) => {
                document.getElementById(id).addEventListener('input', e => terrainMesh.material.uniforms[uniform].value.set(e.target.value));
            };
            bindColor('col-grass', 'uColorGrass');
            bindColor('col-rock', 'uColorRock');
            bindColor('col-sand', 'uColorSand');
            bindColor('col-water', 'uColorWater'); // For water mesh
            // Note: Water color on mesh needs explicit update
            document.getElementById('col-water').addEventListener('input', e => waterMesh.material.uniforms.uColorWater.value.set(e.target.value));

            document.getElementById('inp-trees').addEventListener('change', scatterVegetation); // Regenerate on release
        }

        // --- EXPORT ---

        window.exportSystem = function() {
            const code = `
/* 
   Three.js Terrain with Custom Shaders 
   Generated by TerrainShader Pro
*/
import * as THREE from 'three';

// Shader Code
const VERTEX_SHADER = \`${terrainVertexShader}\`;
const FRAGMENT_SHADER = \`${terrainFragmentShader}\`;

export function createScene(container) {
    const scene = new THREE.Scene();
    const camera = new THREE.PerspectiveCamera(50, window.innerWidth/window.innerHeight, 1, 1000);
    const renderer = new THREE.WebGLRenderer({ antialias: true });
    
    // Geometry
    const geometry = new THREE.PlaneGeometry(${SIZE}, ${SIZE}, ${SEGMENTS}, ${SEGMENTS});
    geometry.rotateX(-Math.PI/2);
    
    // Height Data Application
    const heights = [${Array.from(heightData).map(x=>x.toFixed(2))}];
    const pos = geometry.attributes.position;
    for(let i=0; i<pos.count; i++) pos.setY(i, heights[i]);
    geometry.computeVertexNormals();

    // Material
    const material = new THREE.ShaderMaterial({
        uniforms: {
            uColorGrass: { value: new THREE.Color("${state.colors.grass.getHexString()}") },
            uColorRock: { value: new THREE.Color("${state.colors.rock.getHexString()}") },
            uColorSnow: { value: new THREE.Color("${state.colors.snow.getHexString()}") },
            uColorSand: { value: new THREE.Color("${state.colors.sand.getHexString()}") },
            uSnowLevel: { value: ${state.snowLevel} },
            uSandLevel: { value: ${state.waterLevel + 2.0} },
            uSunDirection: { value: new THREE.Vector3(0,1,0) },
            uAmbientColor: { value: new THREE.Color(0x404040) },
            uSunColor: { value: new THREE.Color(0xffffff) }
        },
        vertexShader: VERTEX_SHADER,
        fragmentShader: FRAGMENT_SHADER
    });

    const mesh = new THREE.Mesh(geometry, material);
    scene.add(mesh);
    
    return { scene, camera, renderer, mesh };
}
            `;
            document.getElementById('code-output').value = code.trim();
            document.getElementById('code-modal').style.display = 'flex';
        }

        init();
    </script>
</body>
</html>