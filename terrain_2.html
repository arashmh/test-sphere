<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>TerrainShader Pro v2 | Environment Studio</title>
    <style>
        :root {
            --bg-color: #121212;
            --panel-color: #1e1e1e;
            --text-color: #e0e0e0;
            --accent-color: #4cc9f0;
            --accent-hover: #3a9bb8;
            --border-color: #333;
            --input-bg: #2a2a2a;
        }

        body { margin: 0; overflow: hidden; font-family: 'Segoe UI', sans-serif; background: var(--bg-color); color: var(--text-color); display: flex; height: 100vh; }
        
        /* Dashboard */
        #dashboard {
            width: 340px; background: var(--panel-color); border-right: 1px solid var(--border-color);
            display: flex; flex-direction: column; z-index: 10; box-shadow: 4px 0 15px rgba(0,0,0,0.4);
        }
        .header { padding: 20px; border-bottom: 1px solid var(--border-color); font-weight: 700; font-size: 1.2em; letter-spacing: 1px; color: #fff; background: linear-gradient(45deg, #1e1e1e, #252525); }
        .header span { color: var(--accent-color); }
        .scroll-area { flex: 1; overflow-y: auto; padding: 15px; }
        .scroll-area::-webkit-scrollbar { width: 6px; }
        .scroll-area::-webkit-scrollbar-thumb { background: #444; border-radius: 3px; }

        /* Panels */
        .panel { background: #262626; border: 1px solid var(--border-color); border-radius: 6px; margin-bottom: 16px; overflow: hidden; }
        .panel-header { padding: 12px 15px; background: #2f2f2f; font-size: 0.85em; font-weight: 600; text-transform: uppercase; letter-spacing: 0.5px; border-bottom: 1px solid var(--border-color); display: flex; justify-content: space-between; align-items: center; }
        .panel-content { padding: 15px; }

        /* Controls */
        .control-group { margin-bottom: 15px; }
        .control-group label { display: flex; justify-content: space-between; margin-bottom: 6px; font-size: 0.85em; color: #aaa; }
        input[type="range"] { width: 100%; -webkit-appearance: none; background: transparent; cursor: pointer; }
        input[type="range"]::-webkit-slider-runnable-track { width: 100%; height: 4px; background: #444; border-radius: 2px; }
        input[type="range"]::-webkit-slider-thumb { -webkit-appearance: none; height: 14px; width: 14px; border-radius: 50%; background: var(--accent-color); margin-top: -5px; box-shadow: 0 0 5px rgba(0,0,0,0.5); }
        input[type="color"] { width: 100%; height: 30px; border: none; background: none; cursor: pointer; }
        
        button { width: 100%; padding: 10px; background: var(--input-bg); border: 1px solid var(--border-color); color: white; border-radius: 4px; cursor: pointer; font-size: 0.9em; transition: 0.2s; margin-bottom: 6px; }
        button:hover { background: #353535; }
        button.active { background: var(--accent-color); border-color: var(--accent-color); color: #000; font-weight: bold; }
        button.primary { background: var(--accent-color); color: #000; font-weight: bold; border: none; }
        button.primary:hover { background: var(--accent-hover); }

        /* Grid Layouts */
        .tool-grid { display: grid; grid-template-columns: 1fr 1fr; gap: 8px; }
        
        /* Viewport */
        #viewport { flex: 1; position: relative; background: #000; }
        #overlay { position: absolute; top: 20px; left: 20px; pointer-events: none; background: rgba(0,0,0,0.6); padding: 10px 15px; border-radius: 4px; font-size: 0.85em; color: #fff; backdrop-filter: blur(4px); border: 1px solid rgba(255,255,255,0.1); }
        
        /* Modal */
        #code-modal { display: none; position: fixed; top: 0; left: 0; width: 100%; height: 100%; background: rgba(0,0,0,0.9); z-index: 100; justify-content: center; align-items: center; }
        .modal-box { background: #1e1e1e; width: 80%; height: 85%; border-radius: 8px; display: flex; flex-direction: column; border: 1px solid #444; box-shadow: 0 0 40px rgba(0,0,0,0.6); }
        textarea { flex: 1; background: #151515; color: #aaddff; border: none; padding: 20px; font-family: 'Consolas', monospace; resize: none; font-size: 0.9em; line-height: 1.5; outline: none; }
    </style>
    
    <script type="importmap">
        {
            "imports": {
                "three": "https://unpkg.com/three@0.160.0/build/three.module.js",
                "three/addons/": "https://unpkg.com/three@0.160.0/examples/jsm/"
            }
        }
    </script>
</head>
<body>

    <!-- SIDEBAR -->
    <div id="dashboard">
        <div class="header">Terrain<span>Shader Pro</span></div>
        <div class="scroll-area">

            <!-- Tools -->
            <div class="panel">
                <div class="panel-header">Sculpting Tools</div>
                <div class="panel-content">
                    <div class="tool-grid">
                        <button class="active" onclick="setTool('mountain', this)">‚õ∞Ô∏è Mountain</button>
                        <button onclick="setTool('valley', this)">üìâ Valley</button>
                        <button onclick="setTool('flatten', this)">üìê Flatten</button>
                        <button onclick="setTool('smooth', this)">üí® Smooth</button>
                        <button onclick="setTool('nav', this)" style="grid-column: span 2;">‚úã Navigate / Zoom</button>
                    </div>
                    <div class="control-group" style="margin-top:10px;">
                        <label>Brush Size <span id="val-radius">25</span></label>
                        <input type="range" id="inp-radius" min="5" max="60" value="25">
                    </div>
                    <div class="control-group">
                        <label>Intensity <span id="val-str">5</span></label>
                        <input type="range" id="inp-str" min="1" max="20" value="5">
                    </div>
                </div>
            </div>

            <!-- Atmosphere -->
            <div class="panel">
                <div class="panel-header">Atmosphere & Lighting</div>
                <div class="panel-content">
                    <div class="control-group">
                        <label>Time of Day <span id="val-time">10:00</span></label>
                        <input type="range" id="inp-time" min="0" max="24" step="0.1" value="10">
                    </div>
                    <div class="control-group">
                        <label>Ambient Light <span id="val-ambient">50%</span></label>
                        <input type="range" id="inp-ambient" min="0" max="1" step="0.05" value="0.5">
                    </div>
                    <div class="control-group">
                        <label>Water Level <span id="val-water">0m</span></label>
                        <input type="range" id="inp-water" min="-20" max="20" value="0">
                    </div>
                    <div class="control-group">
                        <label>Fog Density <span id="val-fog">0.005</span></label>
                        <input type="range" id="inp-fog" min="0" max="0.02" step="0.001" value="0.005">
                    </div>
                </div>
            </div>

            <!-- Shader Colors -->
            <div class="panel">
                <div class="panel-header">Biome Shaders</div>
                <div class="panel-content">
                    <div class="control-group"><label>Snow Level</label><input type="range" id="sh-snow-h" min="10" max="80" value="45"></div>
                    <div class="control-group"><label>Grass Color</label><input type="color" id="col-grass" value="#416135"></div>
                    <div class="control-group"><label>Rock Color</label><input type="color" id="col-rock" value="#5a4d41"></div>
                    <div class="control-group"><label>Sand Color</label><input type="color" id="col-sand" value="#d4c79e"></div>
                    <div class="control-group"><label>Water Color</label><input type="color" id="col-water" value="#006994"></div>
                </div>
            </div>

            <!-- Nature -->
            <div class="panel">
                <div class="panel-header">Vegetation System</div>
                <div class="panel-content">
                    <button onclick="scatterVegetation()">üå≤ Regenerate Forest</button>
                    <div class="control-group" style="margin-top:10px">
                        <label>Tree Density</label>
                        <input type="range" id="inp-trees" min="0" max="5000" value="1000">
                    </div>
                </div>
            </div>

            <div class="panel">
                <div class="panel-content">
                    <button class="primary" onclick="exportSystem()">Generate Full Code</button>
                </div>
            </div>

        </div>
    </div>

    <!-- VIEWPORT -->
    <div id="viewport">
        <div id="overlay">
            LMB: Action ‚Ä¢ RMB: Rotate ‚Ä¢ Scroll: Zoom<br>
            <span id="tool-status" style="color:#aaa; font-size:0.9em">Tool: Mountain</span>
        </div>
    </div>

    <!-- CODE WINDOW -->
    <div id="code-modal">
        <div class="modal-box">
            <div style="padding:15px; border-bottom:1px solid #444; background:#222; display:flex; justify-content:space-between;">
                <span style="color:#fff; font-weight:bold">Generated Project Code</span>
                <button onclick="document.getElementById('code-modal').style.display='none'" style="width:auto; padding:5px 15px; margin:0;">Close</button>
            </div>
            <textarea id="code-output" readonly></textarea>
        </div>
    </div>

    <!-- MAIN LOGIC -->
    <script type="module">
        import * as THREE from 'three';
        import { OrbitControls } from 'three/addons/controls/OrbitControls.js';
        import { Sky } from 'three/addons/objects/Sky.js';

        // --- GLOBALS ---
        let scene, camera, renderer, controls;
        let terrainMesh, waterMesh, brushHelper;
        let sun, sky;
        let treesMesh;
        
        // Data
        const SEGMENTS = 256;
        const SIZE = 400;
        const heightData = new Float32Array((SEGMENTS+1)*(SEGMENTS+1)).fill(0);
        
        // State
        const state = {
            tool: 'mountain', // mountain, valley, flatten, smooth, nav
            radius: 25,
            strength: 5,
            isDrawing: false,
            time: 10.0, // Default 10:00
            ambientIntensity: 0.5,
            waterLevel: 0,
            snowLevel: 45,
            flattenHeight: null, // Stores height when "Flatten" click starts
            colors: {
                grass: new THREE.Color('#416135'),
                rock: new THREE.Color('#5a4d41'),
                sand: new THREE.Color('#d4c79e'),
                water: new THREE.Color('#006994'),
                snow: new THREE.Color('#ffffff')
            }
        };

        // --- SHADERS ---
        
        const terrainVertexShader = `
            varying vec3 vNormal;
            varying vec3 vPosition;
            varying float vSlope;
            
            void main() {
                vec4 worldPosition = modelMatrix * vec4(position, 1.0);
                vPosition = worldPosition.xyz;
                
                // Normal in world space
                vNormal = normalize(mat3(modelMatrix) * normal);
                
                // Slope: 1.0 = up, 0.0 = vertical
                vSlope = dot(vNormal, vec3(0.0, 1.0, 0.0));
                
                gl_Position = projectionMatrix * viewMatrix * worldPosition;
            }
        `;

        const terrainFragmentShader = `
            uniform vec3 uColorGrass;
            uniform vec3 uColorRock;
            uniform vec3 uColorSand;
            uniform vec3 uColorSnow;
            uniform float uSnowLevel;
            uniform float uSandLevel;
            
            // Lighting
            uniform vec3 uSunDirection;
            uniform vec3 uSunColor;
            uniform vec3 uAmbientColor;
            uniform float uAmbientIntensity;

            varying vec3 vNormal;
            varying vec3 vPosition;
            varying float vSlope;

            float hash(vec2 p) { return fract(1e4 * sin(17.0 * p.x + p.y * 0.1) * (0.1 + abs(sin(p.y * 13.0 + p.x)))); }

            void main() {
                float h = vPosition.y;
                
                // Lighting Calc
                float diff = max(dot(vNormal, uSunDirection), 0.0);
                // Combine Ambient + Sun (Directional)
                vec3 lighting = (uAmbientColor * uAmbientIntensity) + (uSunColor * diff);

                // --- Texturing ---
                vec3 col = uColorGrass;

                // 1. Rock (Slope based)
                float rockNoise = hash(vPosition.xz * 0.1);
                float rockFactor = smoothstep(0.7 + rockNoise*0.1, 0.4, vSlope);
                col = mix(col, uColorRock, rockFactor);

                // 2. Sand (Height based, low)
                float sandFactor = 1.0 - smoothstep(uSandLevel, uSandLevel + 3.0, h);
                col = mix(col, uColorSand, sandFactor);

                // 3. Snow (Height based, high)
                float snowHeight = uSnowLevel + (rockNoise * 5.0);
                float snowFactor = smoothstep(snowHeight, snowHeight + 10.0, h);
                snowFactor *= smoothstep(0.3, 0.6, vSlope); // No snow on cliffs
                col = mix(col, uColorSnow, snowFactor);

                gl_FragColor = vec4(col * lighting, 1.0);
            }
        `;

        const waterVertexShader = `
            uniform float uTime;
            varying vec3 vPosition;

            void main() {
                vec3 pos = position;
                // Waves
                float wave = sin(pos.x * 0.1 + uTime) * 0.5 + sin(pos.z * 0.08 + uTime * 0.8) * 0.5;
                pos.y += wave;

                vec4 worldPosition = modelMatrix * vec4(pos, 1.0);
                vPosition = worldPosition.xyz;
                gl_Position = projectionMatrix * viewMatrix * worldPosition;
            }
        `;

        const waterFragmentShader = `
            uniform vec3 uColorWater;
            uniform vec3 uSunDirection;
            uniform vec3 uSunColor;
            varying vec3 vPosition;
            
            void main() {
                vec3 viewVector = normalize(cameraPosition - vPosition);
                vec3 normal = vec3(0.0, 1.0, 0.0);
                
                vec3 halfDir = normalize(uSunDirection + viewVector);
                float spec = pow(max(dot(normal, halfDir), 0.0), 100.0);
                
                vec3 col = uColorWater + (uSunColor * spec);
                gl_FragColor = vec4(col, 0.85); 
            }
        `;

        // --- INIT ---

        function init() {
            const container = document.getElementById('viewport');

            // Scene
            scene = new THREE.Scene();

            // Camera
            camera = new THREE.PerspectiveCamera(55, container.clientWidth / container.clientHeight, 1, 2000);
            camera.position.set(0, 80, 200);

            // Renderer
            renderer = new THREE.WebGLRenderer({ antialias: true, alpha: false });
            renderer.setSize(container.clientWidth, container.clientHeight);
            renderer.shadowMap.enabled = true;
            renderer.shadowMap.type = THREE.PCFSoftShadowMap;
            renderer.toneMapping = THREE.ACESFilmicToneMapping;
            renderer.toneMappingExposure = 0.5;
            container.appendChild(renderer.domElement);

            // Controls
            controls = new OrbitControls(camera, renderer.domElement);
            controls.enableDamping = true;
            controls.maxPolarAngle = Math.PI / 2 - 0.02;
            controls.mouseButtons.LEFT = null; // Sculpt by default, Rotate on Right

            // --- Sun & Sky ---
            sky = new Sky();
            sky.scale.setScalar(450000);
            scene.add(sky);

            sun = new THREE.DirectionalLight(0xffffff, 1.5);
            sun.position.set(100, 100, 100);
            sun.castShadow = true;
            sun.shadow.mapSize.width = 2048;
            sun.shadow.mapSize.height = 2048;
            sun.shadow.camera.near = 0.5;
            sun.shadow.camera.far = 500;
            sun.shadow.camera.left = -SIZE/2;
            sun.shadow.camera.right = SIZE/2;
            sun.shadow.camera.top = SIZE/2;
            sun.shadow.camera.bottom = -SIZE/2;
            scene.add(sun);
            
            // --- Terrain ---
            const geo = new THREE.PlaneGeometry(SIZE, SIZE, SEGMENTS, SEGMENTS);
            geo.rotateX(-Math.PI / 2);
            
            const mat = new THREE.ShaderMaterial({
                uniforms: {
                    uColorGrass: { value: state.colors.grass },
                    uColorRock: { value: state.colors.rock },
                    uColorSand: { value: state.colors.sand },
                    uColorSnow: { value: state.colors.snow },
                    uSnowLevel: { value: state.snowLevel },
                    uSandLevel: { value: state.waterLevel + 2.0 },
                    uSunDirection: { value: new THREE.Vector3(0,1,0) },
                    uSunColor: { value: new THREE.Color(0xffffff) },
                    uAmbientColor: { value: new THREE.Color(0x404040) },
                    uAmbientIntensity: { value: state.ambientIntensity }
                },
                vertexShader: terrainVertexShader,
                fragmentShader: terrainFragmentShader,
                side: THREE.DoubleSide
            });

            terrainMesh = new THREE.Mesh(geo, mat);
            terrainMesh.receiveShadow = true;
            terrainMesh.castShadow = true;
            scene.add(terrainMesh);

            // --- Water ---
            const waterGeo = new THREE.PlaneGeometry(SIZE, SIZE, 64, 64);
            waterGeo.rotateX(-Math.PI/2);
            const waterMat = new THREE.ShaderMaterial({
                uniforms: {
                    uTime: { value: 0 },
                    uColorWater: { value: state.colors.water },
                    uSunDirection: { value: new THREE.Vector3(0,1,0) },
                    uSunColor: { value: new THREE.Color(0xffffff) }
                },
                vertexShader: waterVertexShader,
                fragmentShader: waterFragmentShader,
                transparent: true,
                side: THREE.DoubleSide
            });
            waterMesh = new THREE.Mesh(waterGeo, waterMat);
            waterMesh.position.y = state.waterLevel;
            scene.add(waterMesh);

            // --- Brush Cursor ---
            const bGeo = new THREE.RingGeometry(0.5, 1, 32);
            bGeo.rotateX(-Math.PI/2);
            brushHelper = new THREE.Mesh(bGeo, new THREE.MeshBasicMaterial({ color: 0xff0000, transparent:true, opacity:0.5 }));
            scene.add(brushHelper);

            // Input Events
            container.addEventListener('pointermove', onPointerMove);
            container.addEventListener('pointerdown', onPointerDown);
            container.addEventListener('pointerup', onPointerUp);
            window.addEventListener('resize', onResize);

            initUI();
            updateSunPosition();
            scatterVegetation(); 
            animate();
        }

        // --- SCULPTING LOGIC ---

        const raycaster = new THREE.Raycaster();
        const pointer = new THREE.Vector2();

        function onPointerMove(e) {
            const rect = renderer.domElement.getBoundingClientRect();
            pointer.x = ((e.clientX - rect.left) / rect.width) * 2 - 1;
            pointer.y = -((e.clientY - rect.top) / rect.height) * 2 + 1;

            if (state.tool === 'nav') {
                brushHelper.visible = false;
                return;
            }

            raycaster.setFromCamera(pointer, camera);
            const intersects = raycaster.intersectObject(terrainMesh);

            if (intersects.length > 0) {
                const pt = intersects[0].point;
                brushHelper.position.copy(pt);
                brushHelper.position.y = Math.max(pt.y + 1, state.waterLevel + 1);
                brushHelper.scale.set(state.radius, state.radius, state.radius);
                brushHelper.visible = true;

                if (state.isDrawing) applySculpt(pt);
            } else {
                brushHelper.visible = false;
            }
        }

        function onPointerDown(e) {
            if (e.button === 0) {
                if (state.tool === 'nav') return; // Do nothing, let orbit control work

                state.isDrawing = true;
                controls.enabled = false; 
                
                raycaster.setFromCamera(pointer, camera);
                const intersects = raycaster.intersectObject(terrainMesh);
                
                if (intersects.length > 0) {
                    const pt = intersects[0].point;
                    
                    // Logic for Flatten: Capture height on click
                    if (state.tool === 'flatten') {
                        // Find closest vertex height or just use intersection y
                        state.flattenHeight = pt.y; 
                    }

                    applySculpt(pt);
                }
            }
        }

        function onPointerUp() {
            state.isDrawing = false;
            state.flattenHeight = null;
            if (state.tool !== 'nav') controls.enabled = true; // Re-enable orbit if not in nav mode (nav mode is always enabled)
            updateVegetationY();
        }

        function applySculpt(center) {
            const posAttr = terrainMesh.geometry.attributes.position;
            const gridX = Math.floor(((center.x + SIZE/2) / SIZE) * SEGMENTS);
            const gridZ = Math.floor(((center.z + SIZE/2) / SIZE) * SEGMENTS);
            const rGrid = Math.ceil((state.radius / SIZE) * SEGMENTS);
            
            let dirty = false;
            const startX = Math.max(0, gridX - rGrid);
            const endX = Math.min(SEGMENTS, gridX + rGrid);
            const startZ = Math.max(0, gridZ - rGrid);
            const endZ = Math.min(SEGMENTS, gridZ + rGrid);

            for (let x = startX; x <= endX; x++) {
                for (let z = startZ; z <= endZ; z++) {
                    const dx = x - gridX;
                    const dz = z - gridZ;
                    const dist = Math.sqrt(dx*dx + dz*dz);
                    
                    if (dist < rGrid) {
                        const idx = x + z * (SEGMENTS + 1);
                        const oldY = heightData[idx];
                        
                        // Falloff factor (Gaussian-ish)
                        const factor = Math.cos((dist/rGrid) * (Math.PI/2)); 
                        let newY = oldY;
                        const delta = state.strength * factor * 0.4;

                        switch (state.tool) {
                            case 'mountain': 
                                newY += delta; 
                                break;
                            case 'valley': 
                                newY -= delta; 
                                break;
                            case 'flatten':
                                // Strong Lerp towards the height we clicked on
                                if (state.flattenHeight !== null) {
                                    newY = THREE.MathUtils.lerp(oldY, state.flattenHeight, 0.1 * factor * state.strength); 
                                }
                                break;
                            case 'smooth':
                                // Flatten slopes logic: move towards average? 
                                // Simple approach: shrink amplitude relative to local area? 
                                // Actually, standard smooth is averaging neighbors. 
                                // Simplified fast smooth: Move towards current Y * 0.99? No, that just sinks terrain.
                                // We will simulate smooth by blending with a local target (0 or water level is bad).
                                // Let's just dampen the peaks slightly.
                                // A real blur is expensive here. We'll use a trick:
                                // Move towards the center point's height slightly?
                                const localAvg = (oldY + (center.y || oldY)) / 2;
                                newY = THREE.MathUtils.lerp(oldY, localAvg, 0.05 * factor);
                                break;
                        }

                        if (newY !== oldY) {
                            heightData[idx] = newY;
                            posAttr.setY(idx, newY);
                            dirty = true;
                        }
                    }
                }
            }

            if (dirty) {
                posAttr.needsUpdate = true;
                terrainMesh.geometry.computeVertexNormals();
            }
        }

        // --- VEGETATION ---
        
        window.scatterVegetation = function() {
            if (treesMesh) { scene.remove(treesMesh); treesMesh.dispose(); }
            
            const count = parseInt(document.getElementById('inp-trees').value);
            if (count === 0) return;

            const geom = new THREE.ConeGeometry(1, 4, 8);
            geom.translate(0, 2, 0); 
            const mat = new THREE.MeshLambertMaterial({ color: 0x2d4c1e });
            treesMesh = new THREE.InstancedMesh(geom, mat, count);
            treesMesh.castShadow = true;
            treesMesh.receiveShadow = true;

            const dummy = new THREE.Object3D();
            const posAttr = terrainMesh.geometry.attributes.position;
            const normAttr = terrainMesh.geometry.attributes.normal;

            let placed = 0;
            for(let i=0; i<count * 2; i++) {
                if (placed >= count) break;
                const rx = Math.floor(Math.random() * SEGMENTS);
                const rz = Math.floor(Math.random() * SEGMENTS);
                const idx = rx + rz * (SEGMENTS + 1);

                const y = posAttr.getY(idx);
                const ny = normAttr.getY(idx);

                if (y > state.waterLevel + 1 && y < state.snowLevel - 5) {
                    if (ny > 0.8) {
                        const x = posAttr.getX(idx);
                        const z = posAttr.getZ(idx);
                        dummy.position.set(x, y, z);
                        const s = 1 + Math.random();
                        dummy.scale.set(s, s * (0.8 + Math.random()*0.4), s);
                        dummy.updateMatrix();
                        treesMesh.setMatrixAt(placed, dummy.matrix);
                        placed++;
                    }
                }
            }
            treesMesh.count = placed;
            scene.add(treesMesh);
        }

        function updateVegetationY() {
            if (!treesMesh) return;
            const dummy = new THREE.Object3D();
            const posAttr = terrainMesh.geometry.attributes.position;
            const matrix = new THREE.Matrix4();
            const position = new THREE.Vector3();

            for(let i=0; i<treesMesh.count; i++) {
                treesMesh.getMatrixAt(i, matrix);
                position.setFromMatrixPosition(matrix);
                
                const gx = Math.round(((position.x + SIZE/2)/SIZE)*SEGMENTS);
                const gz = Math.round(((position.z + SIZE/2)/SIZE)*SEGMENTS);
                
                if (gx >= 0 && gx <= SEGMENTS && gz >=0 && gz <= SEGMENTS) {
                    const idx = gx + gz * (SEGMENTS+1);
                    const h = posAttr.getY(idx);
                    
                    if (h < state.waterLevel) matrix.makeScale(0,0,0);
                    else {
                        const sx = new THREE.Vector3();
                        matrix.decompose(position, new THREE.Quaternion(), sx);
                        dummy.position.set(position.x, h, position.z);
                        dummy.scale.copy(sx);
                        dummy.updateMatrix();
                        treesMesh.setMatrixAt(i, dummy.matrix);
                    }
                }
            }
            treesMesh.instanceMatrix.needsUpdate = true;
        }

        // --- ATMOSPHERE & TIME ---

        function updateSunPosition() {
            const time = state.time; 
            const theta = ((time - 6) / 24) * Math.PI * 2; 
            const phi = Math.PI * (0.5 - 0.45 * Math.cos(theta)); 
            const sunX = Math.cos(phi) * Math.cos(theta);
            const sunY = Math.sin(phi); 
            const sunZ = Math.cos(phi) * Math.sin(theta);

            const distance = 400;
            sun.position.set(sunX*distance, sunY*distance, sunZ*distance);

            if (sunY < 0.1) {
                sun.intensity = Math.max(0, sunY * 5);
                scene.fog = new THREE.FogExp2(0x050510, 0.002);
            } else {
                sun.intensity = 1.5;
                scene.fog = new THREE.FogExp2(0xcceeff, parseFloat(document.getElementById('inp-fog').value));
            }

            const uniforms = sky.material.uniforms;
            uniforms['sunPosition'].value.copy(sun.position);

            const sunDir = sun.position.clone().normalize();
            terrainMesh.material.uniforms.uSunDirection.value.copy(sunDir);
            waterMesh.material.uniforms.uSunDirection.value.copy(sunDir);
            
            if(sunY <= 0) sun.castShadow = false;
            else sun.castShadow = true;
        }

        // --- ANIMATION ---
        
        function animate() {
            requestAnimationFrame(animate);
            const time = performance.now() * 0.001;
            waterMesh.material.uniforms.uTime.value = time;
            controls.update();
            renderer.render(scene, camera);
        }

        function onResize() {
            const el = document.getElementById('viewport');
            camera.aspect = el.clientWidth / el.clientHeight;
            camera.updateProjectionMatrix();
            renderer.setSize(el.clientWidth, el.clientHeight);
        }

        // --- UI BINDINGS ---
        
        window.setTool = (t, el) => {
            state.tool = t;
            document.querySelectorAll('.tool-grid button').forEach(b => b.classList.remove('active'));
            el.classList.add('active');
            
            // Logic for Navigation Mode
            if (t === 'nav') {
                controls.mouseButtons.LEFT = THREE.MOUSE.ROTATE;
                document.getElementById('viewport').style.cursor = "grab";
                document.getElementById('tool-status').innerText = "Mode: Navigation (Look around)";
            } else {
                controls.mouseButtons.LEFT = null; // Disable orbit on left click
                document.getElementById('viewport').style.cursor = "default";
                document.getElementById('tool-status').innerText = "Tool: " + t.charAt(0).toUpperCase() + t.slice(1);
            }
        };

        function initUI() {
            // Brushes
            document.getElementById('inp-radius').addEventListener('input', e => { state.radius = parseFloat(e.target.value); document.getElementById('val-radius').innerText=state.radius; });
            document.getElementById('inp-str').addEventListener('input', e => { state.strength = parseFloat(e.target.value); document.getElementById('val-str').innerText=state.strength; });
            
            // Env
            document.getElementById('inp-time').addEventListener('input', e => {
                state.time = parseFloat(e.target.value);
                const hours = Math.floor(state.time);
                const mins = Math.floor((state.time - hours) * 60);
                document.getElementById('val-time').innerText = `${hours}:${mins<10?'0'+mins:mins}`;
                updateSunPosition();
            });

            document.getElementById('inp-ambient').addEventListener('input', e => {
                state.ambientIntensity = parseFloat(e.target.value);
                terrainMesh.material.uniforms.uAmbientIntensity.value = state.ambientIntensity;
                document.getElementById('val-ambient').innerText = Math.round(state.ambientIntensity * 100) + "%";
            });

            document.getElementById('inp-water').addEventListener('input', e => {
                state.waterLevel = parseFloat(e.target.value);
                waterMesh.position.y = state.waterLevel;
                terrainMesh.material.uniforms.uSandLevel.value = state.waterLevel + 2.0;
                document.getElementById('val-water').innerText = state.waterLevel + "m";
                updateVegetationY();
            });

            document.getElementById('inp-fog').addEventListener('input', e => {
                const val = parseFloat(e.target.value);
                scene.fog.density = val;
                document.getElementById('val-fog').innerText = val;
            });

            // Shaders
            document.getElementById('sh-snow-h').addEventListener('input', e => terrainMesh.material.uniforms.uSnowLevel.value = parseFloat(e.target.value));
            
            const bindColor = (id, uniform) => {
                document.getElementById(id).addEventListener('input', e => terrainMesh.material.uniforms[uniform].value.set(e.target.value));
            };
            bindColor('col-grass', 'uColorGrass');
            bindColor('col-rock', 'uColorRock');
            bindColor('col-sand', 'uColorSand');
            bindColor('col-water', 'uColorWater'); 
            document.getElementById('col-water').addEventListener('input', e => waterMesh.material.uniforms.uColorWater.value.set(e.target.value));

            document.getElementById('inp-trees').addEventListener('change', scatterVegetation);
        }

        // --- EXPORT ---

        window.exportSystem = function() {
            const code = `import * as THREE from 'three';
// TerrainShader Pro Generated Code
const VERTEX_SHADER = \`${terrainVertexShader}\`;
const FRAGMENT_SHADER = \`${terrainFragmentShader}\`;

export function createScene(container) {
    const scene = new THREE.Scene();
    const camera = new THREE.PerspectiveCamera(50, window.innerWidth/window.innerHeight, 1, 1000);
    const renderer = new THREE.WebGLRenderer({ antialias: true });
    
    // Geometry & Height
    const geometry = new THREE.PlaneGeometry(${SIZE}, ${SIZE}, ${SEGMENTS}, ${SEGMENTS});
    geometry.rotateX(-Math.PI/2);
    const heights = [${Array.from(heightData).map(x=>x.toFixed(2))}];
    const pos = geometry.attributes.position;
    for(let i=0; i<pos.count; i++) pos.setY(i, heights[i]);
    geometry.computeVertexNormals();

    // Material
    const material = new THREE.ShaderMaterial({
        uniforms: {
            uColorGrass: { value: new THREE.Color("${state.colors.grass.getHexString()}") },
            uColorRock: { value: new THREE.Color("${state.colors.rock.getHexString()}") },
            uColorSnow: { value: new THREE.Color("${state.colors.snow.getHexString()}") },
            uColorSand: { value: new THREE.Color("${state.colors.sand.getHexString()}") },
            uSnowLevel: { value: ${state.snowLevel} },
            uSandLevel: { value: ${state.waterLevel + 2.0} },
            uSunDirection: { value: new THREE.Vector3(0,1,0) },
            uAmbientColor: { value: new THREE.Color(0x404040) },
            uAmbientIntensity: { value: ${state.ambientIntensity} },
            uSunColor: { value: new THREE.Color(0xffffff) }
        },
        vertexShader: VERTEX_SHADER,
        fragmentShader: FRAGMENT_SHADER
    });

    const mesh = new THREE.Mesh(geometry, material);
    scene.add(mesh);
    return { scene, camera, renderer, mesh };
}`;
            document.getElementById('code-output').value = code.trim();
            document.getElementById('code-modal').style.display = 'flex';
        }

        init();
    </script>
</body>
</html>