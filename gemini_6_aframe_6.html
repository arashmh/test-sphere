<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8">
    <title>A-Frame Swarm: Generic World Hiding</title>
    <script src="https://aframe.io/releases/1.7.0/aframe.min.js"></script>
    <style>
      /* --- (UI STYLES REMAIN THE SAME) --- */
      body { margin: 0; overflow: hidden; font-family: 'Segoe UI', sans-serif; user-select: none; }
      #ui-container {
        position: absolute; bottom: 30px; left: 50%; transform: translateX(-50%);
        z-index: 100; display: flex; flex-direction: column; align-items: center;
        gap: 18px; background: rgba(0, 0, 0, 0.85); 
        padding: 35px 80px 25px 35px; border-radius: 24px; backdrop-filter: blur(12px);
        border: 1px solid rgba(255, 255, 255, 0.15); box-shadow: 0 10px 30px rgba(0,0,0,0.6); 
        width: 1050px; max-width: 95vw; transition: all 0.4s cubic-bezier(0.25, 1, 0.5, 1);
      }
      #ui-container.minimized { transform: translateX(-50%) translateY(150%); opacity: 0; pointer-events: none; }
      #btn-minimize {
        position: absolute; top: 20px; right: 20px; width: 44px; height: 44px;
        background: #222222; border: 2px solid rgba(255, 255, 255, 0.3); border-radius: 12px; 
        color: #fff; font-weight: bold; font-size: 16px; cursor: pointer; display: flex; 
        align-items: center; justify-content: center; transition: all 0.2s ease;
      }
      #btn-minimize:hover { background: #ff4757; border-color: #ff4757; transform: scale(1.1); }
      #restore-container {
        position: absolute; bottom: 40px; left: 50%; transform: translateX(-50%) translateY(200%);
        z-index: 99; transition: all 0.4s cubic-bezier(0.25, 1, 0.5, 1);
      }
      #restore-container.visible { transform: translateX(-50%) translateY(0); }
      #btn-restore {
        background: rgba(0, 0, 0, 0.9); border: 1px solid rgba(0, 234, 255, 0.6);
        color: #00eaff; padding: 15px 40px; font-size: 16px; text-transform: uppercase;
        letter-spacing: 2px; cursor: pointer; border-radius: 40px; backdrop-filter: blur(10px);
        font-weight: 800; transition: all 0.2s;
      }
      #btn-restore:hover { background: rgba(0, 234, 255, 0.2); transform: scale(1.05); color: #fff; }
      #btn-row { display: flex; gap: 12px; flex-wrap: wrap; justify-content: center; width: 100%; }
      button.control-btn {
        background: rgba(255, 255, 255, 0.05); border: 1px solid rgba(255, 255, 255, 0.2);
        color: #ddd; padding: 12px 24px; font-size: 14px; text-transform: uppercase;
        letter-spacing: 1px; cursor: pointer; border-radius: 12px; transition: all 0.2s ease;
        outline: none; font-weight: 700; flex: 1;
      }
      button.control-btn:hover { background: rgba(255, 255, 255, 0.2); transform: translateY(-2px); }
      button#btn-attack.active { background: #ff4757; border-color: #ff4757; }
      button#btn-pressure.active { background: #ffa502; border-color: #ffa502; }
      button#btn-push.active { background: #bdc3c7; border-color: #bdc3c7; color: #333; }
      button#btn-chill.active { background: #2ed573; border-color: #2ed573; }
      button#btn-audio.active { background: #00eaff; border-color: #00eaff; color: #000; }
      button#btn-audio.muted { background: #ff0000; border-color: #ff0000; color: white; }
      button.toggle-btn.active { background: #a29bfe; border-color: #a29bfe; }
      button.toggle-btn.off { background: #2d3436; border-color: #636e72; color: #636e72; }
      .dropdown-row { width: 100%; display: flex; gap: 20px; justify-content: space-between; }
      .select-group { display: flex; flex-direction: column; gap: 6px; flex: 1; }
      .select-group label { font-size: 11px; color: rgba(255,255,255,0.6); text-transform: uppercase; }
      select {
        background: rgba(0, 0, 0, 0.6); border: 1px solid rgba(255, 255, 255, 0.3);
        color: #00eaff; padding: 10px 14px; border-radius: 8px; cursor: pointer; width: 100%;
      }
      .slider-row { width: 100%; display: flex; flex-direction: row; gap: 30px; align-items: flex-end; }
      .slider-container { display: flex; flex-direction: column; gap: 10px; flex: 1; color: rgba(255,255,255,0.9); font-size: 12px; text-transform: uppercase; font-weight: 600; }
      .label-row { display: flex; justify-content: space-between; width: 100%; }
      .val-display { color: #00eaff; font-family: monospace; font-size: 13px; }
      input[type=range] { -webkit-appearance: none; width: 100%; background: transparent; }
      input[type=range]::-webkit-slider-thumb { -webkit-appearance: none; height: 16px; width: 16px; border-radius: 50%; background: #ffffff; cursor: pointer; margin-top: -6px; }
      input[type=range]::-webkit-slider-runnable-track { width: 100%; height: 4px; cursor: pointer; background: rgba(255,255,255,0.2); }
      #audio-debug { position: absolute; top: 10px; right: 10px; background: rgba(0,0,0,0.7); color: #0f0; font-family: monospace; font-size: 11px; padding: 8px; border-radius: 4px; display: none; }
    </style>
  </head>
  <body>

    <div id="audio-debug">Density: <span id="pressure-load">0%</span></div>

    <!-- RESTORE BUTTON -->
    <div id="restore-container">
        <button id="btn-restore" onclick="toggleUIMinimize()">‚ñ≤ Open Controls</button>
    </div>

    <!-- MAIN UI -->
    <div id="ui-container">
      <button id="btn-minimize" onclick="toggleUIMinimize()" title="Minimize Menu">‚ñº</button>

      <div id="btn-row">
        <button id="btn-attack" class="control-btn" onclick="setMode('attack')">Attack</button>
        <button id="btn-pressure" class="control-btn" onclick="setMode('pressure')">Pressure</button>
        <button id="btn-push" class="control-btn" onclick="setMode('pushback')">Push Back</button>
        <button id="btn-chill" class="control-btn active" onclick="setMode('chill')">Chill</button>
      </div>

      <div class="dropdown-row">
        <div class="select-group">
          <label>Scale (Chill Mode)</label>
          <select id="scaleSelect" onchange="changeScale(this.value)">
            <option value="pentatonic" selected>üåø Pentatonic (Nature)</option>
            <option value="insen">üßò‚Äç‚ôÇÔ∏è Japanese In Sen (Zen)</option>
            <option value="hirajoshi">üåô Hirajoshi (Reflective)</option>
            <option value="dorian">üîÆ Dorian Mode (Introspective)</option>
            <option value="wholetone">üå¨Ô∏è Whole Tone (Dreamy)</option>
          </select>
        </div>
        <div class="select-group">
          <label>Instrument</label>
          <select id="instSelect" onchange="changeInstrument(this.value)">
            <option value="bowl">üîî Singing Bowl</option>
            <option value="bell">üéê Soft Bell / Chime</option>
            <option value="shakuhachi" selected>üçÉ Shakuhachi</option>
            <option value="kalimba">ü™ï Kalimba</option>
            <option value="organ">üé∂ Soft Organ</option>
          </select>
        </div>
      </div>
      
      <div class="slider-row">
        <div class="slider-container">
          <div class="label-row"><span>Swarm Force</span><span id="val-force" class="val-display">0.10</span></div>
          <input type="range" id="intensitySlider" min="0.01" max="1.5" step="0.01" value="0.1">
        </div>
        <div class="slider-container">
            <div class="label-row"><span>Master Vol</span><span id="val-vol" class="val-display">50%</span></div>
            <input type="range" id="volumeSlider" min="0.0" max="1.0" step="0.05" value="0.50">
        </div>
        <div style="display: flex; gap: 10px; flex: 1.5; align-items: flex-end;">
            <button id="btn-audio" class="control-btn active" onclick="toggleAudio()" style="height: 46px; min-width: 60px; font-size: 11px;">SND ON</button>
            <button id="btn-sphere" class="control-btn toggle-btn active" onclick="toggleSafeSphere()" style="height: 46px; min-width: 70px; font-size: 11px;">SHIELD: VIS</button>
            <button id="btn-system" class="control-btn toggle-btn active" onclick="toggleSystem()" style="height: 46px; min-width: 70px; font-size: 11px;">SYSTEM: ON</button>
        </div>
      </div>
      
      <div style="width: 100%; display: flex; justify-content: space-between; align-items: center; gap: 15px; margin-top: 5px; padding-top: 15px; border-top: 1px solid rgba(255,255,255,0.1);">
        <button class="control-btn" onclick="changeFence(-1)" style="padding: 8px 16px; flex: 0 0 auto;">‚óÄ Prev Fence</button>
        <div style="flex: 1; text-align: center; color: rgba(255,255,255,0.9); font-size: 12px; text-transform: uppercase; font-weight: 600;">
          <div id="fence-name" style="color: #00eaff; font-size: 14px; margin-bottom: 3px;">Simple Wire</div>
          <div id="fence-id" style="color: rgba(255,255,255,0.5); font-size: 10px;">Design 1/7</div>
        </div>
        <button class="control-btn" onclick="changeFence(1)" style="padding: 8px 16px; flex: 0 0 auto;">Next Fence ‚ñ∂</button>
      </div>
    </div>

    <!-- SCENE -->
    <a-scene stats background="color: #000000" renderer="antialias: true; colorManagement: true; sortObjects: true;" xr-mode-ui="XRMode:xr">
      
      <!-- ======================================================== -->
      <!-- THE GENERIC OUTSIDE WORLD CONTAINER -->
      <!-- Everything inside this entity will disappear when the camera is inside the box -->
      <a-entity id="outside-world">
          
          <!-- 1. The Sky -->
          <a-sky color="#87CEEB"></a-sky>
          
          <!-- 2. A Grid Floor (To prove other objects disappear too) -->
          <a-gridhelper size="50" divisions="50" color-center="#ffffff" color-grid="#555555"></a-gridhelper>
          
          <!-- 3. Some floating reference objects outside -->
          <a-box position="-5 2 -5" color="orange" rotation="0 45 0" animation="property: rotation; to: 0 405 0; loop: true; dur: 5000"></a-box>
          <a-box position="5 4 5" color="purple" rotation="45 0 0"></a-box>
          
      </a-entity>
      <!-- ======================================================== -->

      <a-entity light="type: ambient; intensity: 0.3; color: #ffffff"></a-entity>
      <a-entity light="type: point; intensity: 1.2; distance: 10; decay: 2; color: #00eaff" position="0 0 0"></a-entity>
      <a-entity light="type: directional; intensity: 0.5; position: 2 4 3"></a-entity>

      <!-- Safe Sphere (Box Size = 6) -->
      <a-entity id="main-safe-sphere" 
                safe-sphere="
                  box_size: 6;
                  safe_sphere_radius_chill: 1.5;
                  balls_radius_min: 0.05;
                  balls_radius_max: 0.2;
                  number_of_balls: 100;
                  swarm_force: 0.1;
                  master_vol: 0.5;
                "
                position="0 0 0">
      </a-entity>

      <a-entity id="rig" movement-controls position="0.5 0 0">
        <a-entity id="camera" camera look-controls="fly: true" wasd-controls="acceleration:15" position="0 0 0"></a-entity>
        <a-entity id="leftHand" hand-controls="hand: left; handModelStyle: lowPoly; color: #FF0000"></a-entity>
        <a-entity id="rightHand" hand-controls="hand: right; handModelStyle: lowPoly; color: #0000FF"></a-entity>
      </a-entity>

    </a-scene>

    <script>
      let uiMinimized = false;
      function toggleUIMinimize() {
          uiMinimized = !uiMinimized;
          const mainUI = document.getElementById('ui-container');
          const restoreUI = document.getElementById('restore-container');
          if(uiMinimized) { mainUI.classList.add('minimized'); restoreUI.classList.add('visible'); } 
          else { mainUI.classList.remove('minimized'); restoreUI.classList.remove('visible'); }
      }

      /* --- AUDIO ENGINE (Same as before) --- */
      class EnhancedImpactEngine {
        constructor(volume) {
          const AudioContext = window.AudioContext || window.webkitAudioContext;
          this.ctx = new AudioContext();
          this.maxVoices = 12; this.voicePool = []; this.lastTriggerTime = 0; this.minTimeBetweenTriggers = 15; 
          this.currentVolumeSetting = volume; this.currentInstrument = 'shakuhachi'; this.currentScaleName = 'pentatonic';
          this.masterGain = this.ctx.createGain(); this.masterGain.gain.value = volume;
          this.limiter = this.ctx.createDynamicsCompressor(); this.limiter.connect(this.masterGain); this.masterGain.connect(this.ctx.destination);
          this.convolver = this.ctx.createConvolver(); this.wetGain = this.ctx.createGain(); this.wetGain.gain.value = 0.35; 
          this.dryGain = this.ctx.createGain(); this.dryGain.gain.value = 0.8;
          this.convolver.connect(this.wetGain); this.wetGain.connect(this.limiter); this.dryGain.connect(this.limiter);
          this.createMassiveHallImpulse(); this.initVoicePool();
          this.scales = {
            pentatonic: [261.63, 293.66, 329.63, 392.00, 440.00, 523.25, 587.33, 659.25, 783.99, 880.00], 
            insen:      [261.63, 277.18, 349.23, 392.00, 466.16, 523.25, 554.37, 698.46, 783.99, 932.33], 
            hirajoshi:  [261.63, 293.66, 311.13, 392.00, 415.30, 523.25, 587.33, 622.25, 783.99, 830.61], 
            dorian:     [293.66, 329.63, 349.23, 392.00, 440.00, 493.88, 523.25, 587.33, 659.25, 698.46], 
            wholetone:  [261.63, 293.66, 329.63, 369.99, 415.30, 466.16, 523.25, 587.33, 659.25, 739.99]  
          };
        }
        resumeContext() { if (this.ctx.state === 'suspended') { this.ctx.resume(); } }
        destroy() { if(this.ctx) { this.ctx.close(); } }
        createMassiveHallImpulse() {
          const length = this.ctx.sampleRate * 2.5; const impulse = this.ctx.createBuffer(2, length, this.ctx.sampleRate);
          for (let c = 0; c < 2; c++) { const d = impulse.getChannelData(c); for (let i = 0; i < length; i++) d[i] = (Math.random() * 2 - 1) * Math.pow(1 - i / length, 2); }
          this.convolver.buffer = impulse;
        }
        initVoicePool() { for (let i=0; i<this.maxVoices; i++) this.voicePool.push({ id: i, inUse: false }); }
        setVolume(val) { this.currentVolumeSetting = val; if(this.ctx.state !== 'closed') this.masterGain.gain.setTargetAtTime(val, this.ctx.currentTime, 0.1); }
        setScale(scaleName) { if (this.scales[scaleName]) this.currentScaleName = scaleName; }
        setInstrument(instName) { this.currentInstrument = instName; }
        fadeMute(mute) {
            if(this.ctx.state === 'closed') return;
            const now = this.ctx.currentTime; this.masterGain.gain.cancelScheduledValues(now);
            if (mute) { this.masterGain.gain.setValueAtTime(this.masterGain.gain.value, now); this.masterGain.gain.linearRampToValueAtTime(0, now + 1.0); } 
            else { this.resumeContext(); this.masterGain.gain.setValueAtTime(0, now); this.masterGain.gain.linearRampToValueAtTime(this.currentVolumeSetting, now + 0.2); }
        }
        clearQueue() { this.impactQueue = []; }
        play(velocity = 1.0) {
          if (this.ctx.state === 'suspended' || this.ctx.state === 'closed') return;
          const now = performance.now(); if (now - this.lastTriggerTime < this.minTimeBetweenTriggers) return;
          this.lastTriggerTime = now; const voice = this.voicePool.find(v => !v.inUse); if (!voice) return;
          voice.inUse = true; const t = this.ctx.currentTime + 0.005; 
          const osc = this.ctx.createOscillator(); const gain = this.ctx.createGain();
          osc.frequency.setValueAtTime(200 + Math.random() * 50, t); osc.frequency.exponentialRampToValueAtTime(40, t + 0.1); 
          gain.gain.setValueAtTime(0, t); gain.gain.linearRampToValueAtTime(velocity * 1.5, t + 0.005); gain.gain.linearRampToValueAtTime(0, t + 0.16);
          osc.connect(gain); gain.connect(this.dryGain); gain.connect(this.convolver);
          osc.start(t); osc.stop(t + 0.17); setTimeout(() => { voice.inUse = false; try{osc.disconnect(); gain.disconnect();}catch(e){} }, 180);
        }
        playChillNote(velocity = 1.0) {
           if (this.ctx.state === 'suspended' || this.ctx.state === 'closed') return;
           const scale = this.scales[this.currentScaleName] || this.scales.pentatonic; const freq = scale[Math.floor(Math.random() * scale.length)];
           const t = this.ctx.currentTime;
           if(this.currentInstrument === 'bowl') this.synthBowl(freq, t, velocity);
           else if(this.currentInstrument === 'bell') this.synthBell(freq, t, velocity);
           else if(this.currentInstrument === 'shakuhachi') this.synthShakuhachi(freq, t, velocity);
           else if(this.currentInstrument === 'kalimba') this.synthKalimba(freq, t, velocity);
           else if(this.currentInstrument === 'organ') this.synthOrgan(freq, t, velocity);
           else this.synthBowl(freq, t, velocity);
        }
        synthBowl(freq, t, velocity) {
            const osc = this.ctx.createOscillator(); const gain = this.ctx.createGain(); osc.type = 'sine'; osc.frequency.setValueAtTime(freq, t);
            const fmOsc = this.ctx.createOscillator(); const fmGain = this.ctx.createGain(); fmOsc.frequency.value = 4; fmGain.gain.value = 3; fmOsc.connect(fmGain); fmGain.connect(osc.frequency);
            gain.gain.setValueAtTime(0, t); gain.gain.linearRampToValueAtTime(velocity * 0.3, t + 0.05); gain.gain.linearRampToValueAtTime(0, t + 2.1);
            osc.connect(gain); gain.connect(this.convolver); osc.start(t); fmOsc.start(t); osc.stop(t + 2.15); fmOsc.stop(t + 2.15); setTimeout(() => { try{osc.disconnect(); gain.disconnect();}catch(e){} }, 2200);
        }
        synthBell(freq, t, velocity) {
            const ratios = [1, 2.7, 5.4]; const gains = [0.3, 0.15, 0.05];
            ratios.forEach((ratio, i) => {
                const osc = this.ctx.createOscillator(); const gain = this.ctx.createGain(); osc.type = 'sine'; osc.frequency.setValueAtTime(freq * ratio, t);
                gain.gain.setValueAtTime(0, t); gain.gain.linearRampToValueAtTime(velocity * gains[i], t + 0.01); gain.gain.linearRampToValueAtTime(0, t + 1.05);
                osc.connect(gain); gain.connect(this.convolver); gain.connect(this.dryGain); osc.start(t); osc.stop(t + 1.1); setTimeout(() => { try{osc.disconnect(); gain.disconnect();}catch(e){} }, 1150);
            });
        }
        synthShakuhachi(freq, t, velocity) {
            const osc = this.ctx.createOscillator(); const gain = this.ctx.createGain(); const filter = this.ctx.createBiquadFilter();
            osc.type = 'triangle'; osc.frequency.setValueAtTime(freq, t); filter.type = 'lowpass'; filter.frequency.setValueAtTime(freq * 2, t); filter.Q.value = 1;
            gain.gain.setValueAtTime(0, t); gain.gain.linearRampToValueAtTime(velocity * 0.2, t + 0.1); gain.gain.linearRampToValueAtTime(0, t + 1.0);
            osc.connect(filter); filter.connect(gain); gain.connect(this.convolver); osc.start(t); osc.stop(t + 1.05); setTimeout(() => { try{osc.disconnect(); gain.disconnect();}catch(e){} }, 1100);
        }
        synthKalimba(freq, t, velocity) {
            const osc = this.ctx.createOscillator(); const gain = this.ctx.createGain(); osc.type = 'sine'; osc.frequency.setValueAtTime(freq * 1.05, t); osc.frequency.exponentialRampToValueAtTime(freq, t + 0.08);
            gain.gain.setValueAtTime(0, t); gain.gain.linearRampToValueAtTime(velocity * 0.4, t + 0.015); gain.gain.linearRampToValueAtTime(0, t + 0.85);
            osc.connect(gain); gain.connect(this.dryGain); gain.connect(this.convolver); osc.start(t); osc.stop(t + 0.9); setTimeout(() => { try{osc.disconnect(); gain.disconnect();}catch(e){} }, 950);
        }
        synthOrgan(freq, t, velocity) {
            const osc1 = this.ctx.createOscillator(); const osc2 = this.ctx.createOscillator(); const gain = this.ctx.createGain();
            osc1.type = 'sine'; osc2.type = 'sine'; osc1.frequency.value = freq; osc2.frequency.value = freq * 2; 
            gain.gain.setValueAtTime(0, t); gain.gain.linearRampToValueAtTime(velocity * 0.15, t + 0.05); gain.gain.linearRampToValueAtTime(0, t + 1.2);
            osc1.connect(gain); osc2.connect(gain); gain.connect(this.convolver); osc1.start(t); osc2.start(t); osc1.stop(t + 1.25); osc2.stop(t + 1.25); setTimeout(() => { try{osc1.disconnect(); gain.disconnect();}catch(e){} }, 1300);
        }
        playPushBackEffect() {
            if (this.ctx.state === 'suspended') this.ctx.resume(); if (this.ctx.state === 'closed') return; const t = this.ctx.currentTime;
            const osc1 = this.ctx.createOscillator(); const gain1 = this.ctx.createGain(); osc1.type = 'triangle'; osc1.frequency.setValueAtTime(80, t); osc1.frequency.exponentialRampToValueAtTime(30, t + 1.0); 
            gain1.gain.setValueAtTime(0, t); gain1.gain.linearRampToValueAtTime(0.8, t + 0.05); gain1.gain.linearRampToValueAtTime(0, t + 1.05); 
            const osc2 = this.ctx.createOscillator(); const gain2 = this.ctx.createGain(); osc2.type = 'sine'; osc2.frequency.setValueAtTime(50, t); osc2.frequency.linearRampToValueAtTime(20, t + 1.2); 
            gain2.gain.setValueAtTime(0, t); gain2.gain.linearRampToValueAtTime(1.0, t + 0.1); gain2.gain.linearRampToValueAtTime(0, t + 1.25); 
            const filter = this.ctx.createBiquadFilter(); filter.type = 'lowpass'; filter.frequency.setValueAtTime(400, t); filter.frequency.linearRampToValueAtTime(100, t + 1.0); 
            osc1.connect(filter); osc2.connect(filter); filter.connect(gain1); gain1.connect(this.masterGain); gain2.connect(this.masterGain); osc1.start(t); osc1.stop(t + 1.2); osc2.start(t); osc2.stop(t + 1.3);
        }
        playShowSound() {
            if (this.ctx.state === 'suspended' || this.ctx.state === 'closed') return; const t = this.ctx.currentTime;
            const osc = this.ctx.createOscillator(); const gain = this.ctx.createGain(); osc.type = 'sine'; osc.frequency.setValueAtTime(200, t); osc.frequency.exponentialRampToValueAtTime(600, t + 1.5);
            gain.gain.setValueAtTime(0, t); gain.gain.linearRampToValueAtTime(0.3, t + 1.0); gain.gain.linearRampToValueAtTime(0, t + 1.5); osc.connect(gain); gain.connect(this.convolver); osc.start(t); osc.stop(t + 1.6);
        }
        playPressureCrush(density, force) {
          if (this.ctx.state === 'suspended' || this.ctx.state === 'closed') return; const now = this.ctx.currentTime;
          const d = Math.max(0, Math.min(1, density)); const f = Math.max(0.01, Math.min(1.5, force)); const masterVol = Math.min(1.0, d * 1.5); 
          const releaseTime = 0.2 + (1.5 - f) * 1.0; const baseFreq = 40 + (f * 30); 
          const subOsc = this.ctx.createOscillator(); const subGain = this.ctx.createGain(); subOsc.type = 'sine'; subOsc.frequency.setValueAtTime(baseFreq, now); subOsc.frequency.exponentialRampToValueAtTime(20, now + releaseTime);
          subGain.gain.setValueAtTime(0, now); subGain.gain.linearRampToValueAtTime(masterVol, now + 0.05); subGain.gain.linearRampToValueAtTime(0, now + releaseTime + 0.05); 
          subOsc.connect(subGain); subGain.connect(this.dryGain); subOsc.start(now); subOsc.stop(now + releaseTime + 0.1);
        }
      }

      AFRAME.registerComponent('pooled-ring', {
        init: function() {
          this.isActive = false; this.timer = 0; this.lifeTime = 0;
          this.el.setAttribute('geometry', { primitive: 'ring', radiusInner: 0.085, radiusOuter: 0.1, segmentsTheta: 32 });
          this.el.setAttribute('material', { color: '#ffd700', shader: 'flat', transparent: true, opacity: 0, side: 'double', blending: 'additive', depthTest: false, depthWrite: false });
          this.el.object3D.visible = false;
        },
        activate: function(pos, normal, color) {
          this.isActive = true; this.timer = 0; this.lifeTime = 400 + Math.random() * 600; 
          this.el.object3D.position.copy(pos).addScaledVector(normal, 0.02);
          this.el.object3D.lookAt(new THREE.Vector3().copy(pos).add(normal));
          this.el.object3D.visible = true; const mesh = this.el.getObject3D('mesh'); if (mesh) { mesh.material.opacity = 1.0; mesh.material.color.set(color); }
        },
        tick: function(t, dt) {
          if (!this.isActive) return; this.timer += dt; if (this.timer >= this.lifeTime) { this.isActive = false; this.el.object3D.visible = false; return; }
          const progress = this.timer / this.lifeTime; if (this.el.getObject3D('mesh')) this.el.getObject3D('mesh').material.opacity = 1.0 - progress;
        }
      });

      const FENCE_DESIGNS = [
        { id: 0, name: 'Simple Wire' }, { id: 1, name: 'Nested Harmonic Shells' }, { id: 2, name: 'Veil Lattice Aurora' }, { id: 3, name: 'Petal Arc Bloom' }, { id: 4, name: 'Fractal Mesh Dissolve' }, { id: 5, name: 'Halo Bead Filigree' }, { id: 6, name: 'Connected Bead Network' }
      ];

      AFRAME.registerComponent('safe-sphere', {
        schema: {
          box_size: { default: 6 },
          safe_sphere_radius_chill: { default: 1.5 },
          safe_sphere_radius_attack: { default: 1.4 },
          safe_sphere_radius_pressure: { default: 1.0 },
          safe_sphere_radius_pushback: { default: 1.6 },
          balls_radius_min: { default: 0.05 },
          balls_radius_max: { default: 0.2 },
          number_of_balls: { default: 100 },
          color_chill: { default: '#00d2d3' },
          color_attack: { default: '#ff4757' },
          color_pressure: { default: '#f1c40f' },
          color_pushback: { default: '#bdc3c7' },
          swarm_force: { default: 0.05 },
          master_vol: { default: 0.5 },
          with_impact_sounds: { default: true }
        },

        init: function() {
          this.mode = 'chill'; this.targetRadius = this.data.safe_sphere_radius_chill; this.isSystemActive = true; this.isSphereVisible = true; this.isMuted = !this.data.with_impact_sounds;
          
          // --- GENERIC WORLD HANDLING ---
          // Instead of getting a specific sky ID, we get the container for the whole outside world
          this.worldEl = document.getElementById('outside-world');
          this.camWorldPos = new THREE.Vector3();
          this.boxContainsCamera = false;
          // ------------------------------

          this.balls = []; this.fenceObjects = []; this.currentFenceIndex = 0; this.soundEngine = null;
          this.createVisualStructure(); this.createPool(); this.createFenceDesigns(); this.set_fence_style('Simple Wire'); 
          this.vTemp = new THREE.Vector3(); this.vDir = new THREE.Vector3(); this.vNormal = new THREE.Vector3();
          this.pressureBucketCurrent = 0; this.pressureBucketPrevious = 0; this.pressureTimer = 0;
          this.palettes = {
            chill: ['#00d2d3', '#48dbfb', '#0abde3', '#54a0ff'],
            attack: ['#ff4757', '#ff6b81', '#e17055', '#d63031'],
            pressure: ['#8e44ad', '#9b59b6', '#f1c40f', '#e67e22'],
            pushback: ['#bdc3c7', '#ecf0f1', '#95a5a6', '#7f8c8d']
          };
          this.colorA = new THREE.Color(this.data.color_chill); this.colorB = new THREE.Color('#006266'); this.ambientColor = new THREE.Color();
          this.show_all();
          const unlockAudio = () => { if(this.soundEngine && !this.isMuted) this.soundEngine.resumeContext(); document.body.removeEventListener('click', unlockAudio); document.body.removeEventListener('touchstart', unlockAudio); };
          document.body.addEventListener('click', unlockAudio); document.body.addEventListener('touchstart', unlockAudio);
        },

        // ... (Functions createVisualStructure, createPool, createBalls, removeBalls, activate_*, set_*, mute, unmute remain the same) ...
        createVisualStructure: function() {
          this.sphereContainer = document.createElement('a-entity'); this.el.appendChild(this.sphereContainer);
          this.safeCore = document.createElement('a-sphere'); this.safeCore.setAttribute('radius', '1'); this.safeCore.setAttribute('segments-width', 64); this.safeCore.setAttribute('segments-height', 64);
          this.safeCore.setAttribute('material', 'color: #00a8ff; opacity: 0.12; transparent: true; roughness: 0.1; metalness: 0.0; side: double; blending: additive; depthWrite: false');
          this.sphereContainer.appendChild(this.safeCore);
          this.safeWire = document.createElement('a-sphere'); this.safeWire.setAttribute('radius', '1.01'); this.safeWire.setAttribute('segments-width', 24); this.safeWire.setAttribute('segments-height', 16);
          this.safeWire.setAttribute('material', 'color: #48dbfb; wireframe: true; opacity: 0.2; transparent: true; side: double; depthWrite: false');
          this.sphereContainer.appendChild(this.safeWire);
          this.sphereContainer.object3D.scale.set(this.targetRadius, this.targetRadius, this.targetRadius);
        },
        createPool: function() { this.ringPool = []; this.poolIndex = 0; const poolContainer = document.createElement('a-entity'); this.el.appendChild(poolContainer); for(let i=0; i<50; i++) { let el = document.createElement('a-entity'); el.setAttribute('pooled-ring', ''); poolContainer.appendChild(el); this.ringPool.push(el); } },
        createBalls: function() {
          if(this.balls.length > 0) return; const bound = this.data.box_size / 2;
          for(let i=0; i<this.data.number_of_balls; i++) {
            let ball = document.createElement('a-sphere'); let r = this.data.balls_radius_min + Math.random() * (this.data.balls_radius_max - this.data.balls_radius_min);
            ball.setAttribute('radius', r); ball.setAttribute('segments-width', 8); ball.setAttribute('segments-height', 8);
            ball.setAttribute('material', 'shader: standard; roughness: 0.3; metalness: 0.5; transparent: true; opacity: 1.0;');
            let pos = new THREE.Vector3((Math.random() - 0.5) * this.data.box_size, (Math.random() - 0.5) * this.data.box_size, (Math.random() - 0.5) * this.data.box_size);
            if (pos.length() < this.data.safe_sphere_radius_chill) pos.setLength(this.data.safe_sphere_radius_chill + 0.5);
            ball.object3D.position.copy(pos);
            const palette = this.palettes[this.mode] || this.palettes.chill; const col = palette[Math.floor(Math.random() * palette.length)];
            ball.userData = { velocity: new THREE.Vector3(0,0,0), colorTarget: new THREE.Color(col), currentColor: new THREE.Color(col), isAttacking: false, attackCooldown: 0, lastImpactTime: 0, radius: r };
            this.el.sceneEl.appendChild(ball); this.balls.push(ball);
          }
        },
        removeBalls: function() { this.balls.forEach(ball => { if(ball.parentNode) ball.parentNode.removeChild(ball); }); this.balls = []; },
        activate_chill: function() { this.setMode('chill'); }, activate_attack: function() { this.setMode('attack'); }, activate_pressure: function() { this.setMode('pressure'); }, activate_pushback: function() { this.setMode('pushback'); },
        set_swarm_force: function(val) { this.data.swarm_force = parseFloat(val); }, set_master_vol: function(val) { this.data.master_vol = parseFloat(val); if(this.soundEngine) this.soundEngine.setVolume(this.data.master_vol); },
        set_fence_style: function(name) { const design = FENCE_DESIGNS.find(d => d.name === name); if (design) this.switchToFenceDesign(design.id); },
        set_scale: function(scaleName) { if(this.soundEngine) this.soundEngine.setScale(scaleName); }, set_instrument: function(instName) { if(this.soundEngine) this.soundEngine.setInstrument(instName); },
        mute: function() { this.isMuted = true; if(this.soundEngine) this.soundEngine.fadeMute(true); },
        unmute: function() { this.isMuted = false; if(this.soundEngine && this.boxContainsCamera) this.soundEngine.fadeMute(false); },
        show_all: function() { if (this.isSystemActive && this.soundEngine) return; this.isSystemActive = true; if (!this.soundEngine) { this.soundEngine = new EnhancedImpactEngine(this.data.master_vol); const scaleSel = document.getElementById('scaleSelect'); const instSel = document.getElementById('instSelect'); if(scaleSel) this.soundEngine.setScale(scaleSel.value); if(instSel) this.soundEngine.setInstrument(instSel.value); if(!this.isMuted && this.boxContainsCamera) this.soundEngine.playShowSound(); } this.createBalls(); this.sphereContainer.object3D.visible = this.isSphereVisible; },
        hide_all: function() { this.isSystemActive = false; if (this.soundEngine) { this.soundEngine.destroy(); this.soundEngine = null; } this.removeBalls(); this.sphereContainer.object3D.visible = false; },
        show_safe_sphere: function() { this.isSphereVisible = true; if (this.isSystemActive) { this.sphereContainer.object3D.visible = true; if(this.soundEngine && !this.isMuted && this.boxContainsCamera) this.soundEngine.playShowSound(); } },
        hide_safe_sphere: function() { this.isSphereVisible = false; if (this.isSystemActive) { this.sphereContainer.object3D.visible = false; } },
        setMode: function(mode) {
          this.mode = mode; if(this.soundEngine) this.soundEngine.clearQueue();
          if (mode === 'chill') this.targetRadius = this.data.safe_sphere_radius_chill; else if (mode === 'attack') this.targetRadius = this.data.safe_sphere_radius_attack; else if (mode === 'pressure') this.targetRadius = this.data.safe_sphere_radius_pressure; else if (mode === 'pushback') { this.targetRadius = this.data.safe_sphere_radius_pushback; if(this.soundEngine && !this.isMuted && this.boxContainsCamera) this.soundEngine.playPushBackEffect(); }
          const palette = this.palettes[mode]; this.balls.forEach(ball => { ball.userData.colorTarget.set(palette[Math.floor(Math.random() * palette.length)]); });
        },
        
        tick: function(time, timeDelta) {
          if (!this.isSystemActive) return;
          if (timeDelta > 100) return;

          // --- VISIBILITY & AUDIO LOGIC (Generic) ---
          const cam = this.el.sceneEl.camera;
          if (cam) {
            cam.el.object3D.getWorldPosition(this.camWorldPos);
            const sphereWorldPos = this.el.object3D.position; 
            const limit = this.data.box_size / 2;
            const isInside = (
              Math.abs(this.camWorldPos.x - sphereWorldPos.x) < limit &&
              Math.abs(this.camWorldPos.y - sphereWorldPos.y) < limit &&
              Math.abs(this.camWorldPos.z - sphereWorldPos.z) < limit
            );

            if (isInside !== this.boxContainsCamera) {
                this.boxContainsCamera = isInside;
                if (isInside) {
                  // Inside Box: Hide the WHOLE outside world, Enable Audio
                  if (this.worldEl) this.worldEl.object3D.visible = false;
                  if (this.soundEngine && !this.isMuted) this.soundEngine.fadeMute(false);
                } else {
                  // Outside Box: Show the WHOLE outside world, Mute Audio
                  if (this.worldEl) this.worldEl.object3D.visible = true;
                  if (this.soundEngine) this.soundEngine.fadeMute(true);
                }
            }
          }
          // ------------------------------------------

          const dt = timeDelta / 1000; const now = performance.now();
          this.animateFences(time); this.animateAmbientColor(time);
          let currentScale = this.sphereContainer.object3D.scale.x; let scaleDiff = this.targetRadius - currentScale;
          if (Math.abs(scaleDiff) > 0.001) { let speed = (this.mode === 'pushback') ? 1.2 : 2.0; let newScale = currentScale + (scaleDiff * speed * dt); this.sphereContainer.object3D.scale.set(newScale, newScale, newScale); }
          const currentCollisionRadius = 1.0 * this.sphereContainer.object3D.scale.x; 
          const audioEnabled = !this.isMuted && this.data.with_impact_sounds && this.soundEngine && this.boxContainsCamera;
          
          if (this.mode === 'pressure') {
            this.pressureTimer += timeDelta;
            if (this.pressureTimer >= 1000) {
              const totalImpacts = this.pressureBucketCurrent + this.pressureBucketPrevious; const maxPossibleImpacts = this.data.number_of_balls * 20; const density = Math.min(1.0, totalImpacts / maxPossibleImpacts);
              const debugEl = document.getElementById('pressure-load'); if(debugEl) debugEl.innerText = Math.round(density * 100) + '%';
              if (audioEnabled) this.soundEngine.playPressureCrush(density, this.data.swarm_force);
              this.pressureBucketPrevious = this.pressureBucketCurrent; this.pressureBucketCurrent = 0; this.pressureTimer = 0;
            }
          } else { this.pressureBucketCurrent = 0; this.pressureTimer = 0; }
          const bound = this.data.box_size / 2; const origin = new THREE.Vector3(0,0,0);
          for (let i = 0; i < this.balls.length; i++) {
            let ball = this.balls[i]; let uData = ball.userData; let pos = ball.object3D.position;
            uData.currentColor.lerp(uData.colorTarget, 0.08);
            const mesh = ball.getObject3D('mesh'); if(mesh) { mesh.material.color.setHex(uData.currentColor.getHex()); mesh.material.emissive.setHex(uData.currentColor.getHex()); mesh.material.emissiveIntensity = 0.5; }
            let dist = pos.length();
            if (this.mode === 'chill' || this.mode === 'pushback') {
               uData.velocity.multiplyScalar(0.98); this.applyJitter(uData.velocity, 0.005 * this.data.swarm_force);
               if(uData.velocity.length() < 0.02) uData.velocity.normalize().multiplyScalar(0.02); uData.isAttacking = false;
            } else if (this.mode === 'attack') {
               if (uData.attackCooldown > 0) uData.attackCooldown -= dt;
               if (!uData.isAttacking && uData.attackCooldown <= 0) {
                  if (Math.random() < 0.02 * this.data.swarm_force) { uData.isAttacking = true; this.vDir.copy(origin).sub(pos).normalize(); uData.velocity.copy(this.vDir).multiplyScalar((3.5 + this.data.swarm_force * 2.0) * dt); } else { this.applyJitter(uData.velocity, 0.02 * this.data.swarm_force); }
               }
            } else if (this.mode === 'pressure') {
               this.vDir.copy(origin).sub(pos).normalize(); uData.velocity.addScaledVector(this.vDir, 0.04 * this.data.swarm_force); uData.velocity.multiplyScalar(0.96); uData.isAttacking = false;
            }
            pos.add(uData.velocity);
            if (Math.abs(pos.x) > bound) { pos.x = Math.sign(pos.x)*bound; uData.velocity.x *= -0.8; }
            if (Math.abs(pos.y) > bound) { pos.y = Math.sign(pos.y)*bound; uData.velocity.y *= -0.8; }
            if (Math.abs(pos.z) > bound) { pos.z = Math.sign(pos.z)*bound; uData.velocity.z *= -0.8; }
            let minDist = currentCollisionRadius + uData.radius;
            if (dist < minDist) {
               this.vNormal.copy(pos).normalize();
               const cooldown = (this.mode === 'chill') ? 150 : 50; const canPlaySound = (now - uData.lastImpactTime) > cooldown;
               if (this.mode === 'attack' && uData.isAttacking) {
                  this.spawnRing(pos, this.vNormal, uData.currentColor);
                  if (canPlaySound && audioEnabled) { this.soundEngine.play(Math.min(1.0, uData.velocity.length() * 0.3)); uData.lastImpactTime = now; }
                  uData.isAttacking = false; uData.attackCooldown = 0.5; uData.velocity.multiplyScalar(0.2); 
               } else if (this.mode === 'chill') {
                   if (canPlaySound) { uData.lastImpactTime = now; this.spawnRing(pos, this.vNormal, new THREE.Color('#00FFFF')); if(audioEnabled) this.soundEngine.playChillNote(Math.random() * 0.5 + 0.5); }
               } else if (this.mode === 'pressure') {
                  if (canPlaySound) { this.pressureBucketCurrent++; uData.lastImpactTime = now; this.spawnRing(pos, this.vNormal, uData.currentColor); }
               }
               let vDotN = uData.velocity.dot(this.vNormal); this.vTemp.copy(this.vNormal).multiplyScalar(2 * vDotN); uData.velocity.sub(this.vTemp); pos.copy(this.vNormal).multiplyScalar(minDist); uData.velocity.addScaledVector(this.vNormal, 0.01);
            }
          }
          if (this.mode !== 'attack') { this.handleBallCollisions(); }
        },
        applyJitter: function(vel, force) { vel.x += (Math.random() * 2 - 1) * force; vel.y += (Math.random() * 2 - 1) * force; vel.z += (Math.random() * 2 - 1) * force; },
        spawnRing: function(pos, normal, color) { let poolEl = this.ringPool[this.poolIndex]; this.poolIndex = (this.poolIndex + 1) % this.ringPool.length; if (poolEl.components['pooled-ring']) poolEl.components['pooled-ring'].activate(pos, normal, color); },
        handleBallCollisions: function() {
           const rSum = this.data.balls_radius_max * 1.5; const rSumSq = rSum * rSum;
           for (let i = 0; i < this.balls.length; i++) {
             for (let j = i + 1; j < this.balls.length; j++) {
                let b1 = this.balls[i].object3D.position; let b2 = this.balls[j].object3D.position; let distSq = b1.distanceToSquared(b2);
                if (distSq < rSumSq) {
                   let dist = Math.sqrt(distSq); this.vTemp.copy(b1).sub(b2).normalize(); let overlap = (rSum - dist) * 0.5;
                   b1.addScaledVector(this.vTemp, overlap); b2.addScaledVector(this.vTemp, -overlap);
                   let v1 = this.balls[i].userData.velocity; let v2 = this.balls[j].userData.velocity; this.vDir.copy(this.vTemp).multiplyScalar(0.01); v1.add(this.vDir).multiplyScalar(0.95); v2.sub(this.vDir).multiplyScalar(0.95);
                }
             }
           }
        },
        animateAmbientColor: function(time) { const alpha = (Math.sin(time * 0.001) + 1) / 2; this.ambientColor.copy(this.colorB).lerp(this.colorA, alpha); const hex = this.ambientColor.getHex(); if(this.safeCore) this.safeCore.getObject3D('mesh').material.color.setHex(hex); },
        createFenceDesigns: function() { this.fenceObjects[1] = this.createNestedShells(); this.fenceObjects[2] = this.createVeilLattice(); this.fenceObjects[3] = this.createPetalBloom(); this.fenceObjects[4] = this.createFractalMesh(); this.fenceObjects[5] = this.createHaloBeads(); this.fenceObjects[6] = this.createConnectedBeads(); },
        switchToFenceDesign: function(index) { this.currentFenceIndex = index; if(this.safeWire) this.safeWire.object3D.visible = (index === 0); for (let i = 1; i < this.fenceObjects.length; i++) { if (this.fenceObjects[i]) this.fenceObjects[i].visible = (i === index); } },
        animateFences: function(time) {
            if(!this.isSphereVisible) return;
            if (this.fenceObjects[1] && this.fenceObjects[1].visible) { const consciousnessWave = Math.sin(time * 0.00012) * 0.5 + 0.5; this.fenceObjects[1].children.forEach((mesh, idx) => { if (mesh.userData.isShell && mesh.material.uniforms) { const phase = mesh.userData.phaseOffset; const breathe = 1.0 + Math.sin((time + phase) * 0.0005) * 0.012; mesh.scale.set(breathe, breathe, breathe); mesh.material.uniforms.time.value = time; mesh.material.uniforms.baseOpacity.value = (0.15 + idx * 0.05) * (0.95 + consciousnessWave * 0.1); } }); }
            if (this.fenceObjects[2] && this.fenceObjects[2].visible) { const consciousShimmer = Math.sin(time * 0.0001) * 0.5 + 0.5; this.fenceObjects[2].children.forEach(child => { if (child.userData.isRibbon && child.material.uniforms) { child.material.uniforms.time.value = time; child.material.opacity = 0.35 * (0.9 + consciousShimmer * 0.15); } else if (child.material) { child.material.opacity = 0.2; } }); }
            [3, 4, 5, 6].forEach(idx => { if (this.fenceObjects[idx] && this.fenceObjects[idx].visible) { this.fenceObjects[idx].children.forEach(child => { if(child.material.uniforms) child.material.uniforms.time.value = time; if(child.userData.isPetal && child.material.uniforms) { const consciousGlow = Math.sin(time * 0.00013) * 0.5 + 0.5; const petalBreath = 1.0 + consciousGlow * 0.006; child.scale.set(petalBreath, petalBreath, petalBreath); } if (child.userData.isFractalLayer) child.rotation.y = Math.sin(time * 0.00004) * 0.01; if(child.userData.isBead) { const hueShift = Math.sin(time * 0.00008) * 0.08; const baseColor = child.userData.baseColor; const hsl = {}; baseColor.getHSL(hsl); child.material.color.setHSL(hsl.h + hueShift, hsl.s, hsl.l); } }); } });
        },
        createNestedShells: function() {
            const group = new THREE.Group(); const radii = [1.0, 1.02, 1.04]; const colors = [new THREE.Color('#7ff9ff'), new THREE.Color('#33c7ff'), new THREE.Color('#c9ffff')]; const phases = [0, 4000, 8000];
            radii.forEach((radius, idx) => { const geo = new THREE.IcosahedronGeometry(radius, 2); const mat = new THREE.ShaderMaterial({ uniforms: { time: {value:0}, color1: {value:colors[idx]}, color2: {value:colors[idx].clone().multiplyScalar(0.7)}, phase: {value:phases[idx]}, baseOpacity: {value: 0.15} }, vertexShader: `varying vec3 vP; void main(){vP=position;gl_Position=projectionMatrix*modelViewMatrix*vec4(position,1.0);}`, fragmentShader: `uniform float time; uniform vec3 color1; uniform vec3 color2; uniform float baseOpacity; varying vec3 vP; void main(){ float d=length(vP); float a=baseOpacity*(1.0-abs(vP.y/d)*0.15); gl_FragColor=vec4(mix(color2,color1,abs(vP.y/d)), a); }`, transparent: true, side: THREE.DoubleSide, wireframe: true, blending: THREE.AdditiveBlending, depthWrite: false }); const mesh = new THREE.LineSegments(new THREE.EdgesGeometry(geo), mat); mesh.userData = { isShell: true, phaseOffset: phases[idx] }; group.add(mesh); }); this.sphereContainer.object3D.add(group); return group;
        },
        createVeilLattice: function() { const group = new THREE.Group(); const geo = new THREE.IcosahedronGeometry(1.01, 3); const mat = new THREE.LineBasicMaterial({ color: '#d6fff6', transparent: true, opacity: 0.2, blending: THREE.AdditiveBlending }); group.add(new THREE.LineSegments(new THREE.EdgesGeometry(geo), mat)); this.sphereContainer.object3D.add(group); return group; },
        createPetalBloom: function() { const group = new THREE.Group(); const count = 16; for(let i=0; i<count; i++){ const curve = new THREE.EllipseCurve(0,0, 1.01, 0.5, 0, Math.PI*2, false, 0); const pts = curve.getPoints(50).map(p => new THREE.Vector3(p.x, p.y, 0)); const geo = new THREE.BufferGeometry().setFromPoints(pts); const mat = new THREE.LineBasicMaterial({ color: '#4ddde8', transparent: true, opacity: 0.4, blending: THREE.AdditiveBlending }); const line = new THREE.Line(geo, mat); line.rotation.y = (i/count)*Math.PI; line.userData.isPetal = true; group.add(line); } this.sphereContainer.object3D.add(group); return group; },
        createFractalMesh: function() { const group = new THREE.Group(); [0, 1].forEach(idx => { const geo = new THREE.IcosahedronGeometry(1.01 + idx*0.01, idx+1); const mat = new THREE.LineBasicMaterial({ color: idx===0?'#73f6e8':'#186265', transparent: true, opacity: 0.2 }); const mesh = new THREE.LineSegments(new THREE.EdgesGeometry(geo), mat); mesh.userData.isFractalLayer = true; group.add(mesh); }); this.sphereContainer.object3D.add(group); return group; },
        createHaloBeads: function() { const group = new THREE.Group(); for(let i=0; i<40; i++) { const mesh = new THREE.Mesh(new THREE.SphereGeometry(0.02, 8, 8), new THREE.MeshBasicMaterial({ color: '#7de0d5', transparent: true })); mesh.position.randomDirection().multiplyScalar(1.01); mesh.userData = { isBead: true, baseColor: new THREE.Color('#7de0d5') }; group.add(mesh); } this.sphereContainer.object3D.add(group); return group; },
        createConnectedBeads: function() { const group = new THREE.Group(); const geo = new THREE.IcosahedronGeometry(1.01, 1); const pos = geo.attributes.position.array; for(let i=0; i<pos.length; i+=3){ const v = new THREE.Vector3(pos[i], pos[i+1], pos[i+2]); const mesh = new THREE.Mesh(new THREE.SphereGeometry(0.025, 8, 8), new THREE.MeshBasicMaterial({color: '#6ee3d6', transparent:true})); mesh.position.copy(v); mesh.userData = { isBead: true, baseColor: new THREE.Color('#6ee3d6') }; group.add(mesh); } const lineGeo = new THREE.WireframeGeometry(geo); const line = new THREE.LineSegments(lineGeo, new THREE.LineBasicMaterial({color: '#9df7ec', transparent:true, opacity:0.3})); group.add(line); this.sphereContainer.object3D.add(group); return group; }
      });





      
      let currentFenceIndex = 0; const fenceNames = FENCE_DESIGNS.map(d => d.name);
      const intensitySlider = document.getElementById('intensitySlider'); const volumeSlider = document.getElementById('volumeSlider');
      function getSphereComp() { const el = document.getElementById('main-safe-sphere'); return el ? el.components['safe-sphere'] : null; }
      function setMode(mode) {
        const comp = getSphereComp(); if (!comp || !comp.isSystemActive) return; 
        if(mode === 'chill') comp.activate_chill(); if(mode === 'attack') comp.activate_attack(); if(mode === 'pressure') comp.activate_pressure(); if(mode === 'pushback') comp.activate_pushback();
        document.querySelectorAll('#btn-row button').forEach(b => b.classList.remove('active'));
        const idMap = { 'attack': 'btn-attack', 'pressure': 'btn-pressure', 'pushback': 'btn-push', 'chill': 'btn-chill' }; const btn = document.getElementById(idMap[mode]); if(btn) btn.classList.add('active');
      }
      function changeScale(val) { const comp = getSphereComp(); if(comp) comp.set_scale(val); }
      function changeInstrument(val) { const comp = getSphereComp(); if(comp) comp.set_instrument(val); }
      intensitySlider.addEventListener('input', (e) => { const val = parseFloat(e.target.value); document.getElementById('val-force').innerText = val.toFixed(2); const comp = getSphereComp(); if(comp) comp.set_swarm_force(val); });
      volumeSlider.addEventListener('input', (e) => { const val = parseFloat(e.target.value); document.getElementById('val-vol').innerText = Math.round(val * 100) + '%'; const comp = getSphereComp(); if(comp) comp.set_master_vol(val); });
      function changeFence(direction) { currentFenceIndex = (currentFenceIndex + direction + fenceNames.length) % fenceNames.length; const name = fenceNames[currentFenceIndex]; document.getElementById('fence-name').innerText = name; document.getElementById('fence-id').innerText = `Design ${currentFenceIndex + 1}/7`; const comp = getSphereComp(); if(comp) comp.set_fence_style(name); }
      let isAudioEnabled = true;
      function toggleAudio() { isAudioEnabled = !isAudioEnabled; const btn = document.getElementById('btn-audio'); const comp = getSphereComp(); if(isAudioEnabled) { btn.classList.remove('muted'); btn.classList.add('active'); btn.innerText = "SND ON"; if(comp) comp.unmute(); } else { btn.classList.remove('active'); btn.classList.add('muted'); btn.innerText = "MUTED"; if(comp) comp.mute(); } }
      let isSystemEnabled = true;
      function toggleSystem() { isSystemEnabled = !isSystemEnabled; const btn = document.getElementById('btn-system'); const comp = getSphereComp(); if(isSystemEnabled) { btn.classList.remove('off'); btn.classList.add('active'); btn.innerText = "SYSTEM: ON"; if(comp) comp.show_all(); } else { btn.classList.remove('active'); btn.classList.add('off'); btn.innerText = "SYSTEM: OFF"; if(comp) comp.hide_all(); } }
      let isSphereVisEnabled = true;
      function toggleSafeSphere() { isSphereVisEnabled = !isSphereVisEnabled; const btn = document.getElementById('btn-sphere'); const comp = getSphereComp(); if(isSphereVisEnabled) { btn.classList.remove('off'); btn.classList.add('active'); btn.innerText = "SHIELD: VIS"; if(comp) comp.show_safe_sphere(); } else { btn.classList.remove('active'); btn.classList.add('off'); btn.innerText = "SHIELD: HID"; if(comp) comp.hide_safe_sphere(); } }
    </script>
  </body>
</html>