<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>The Living Plasma Vortex - VR Mode</title>
    <style>
        body { margin: 0; overflow: hidden; background-color: #000; font-family: sans-serif; }
        canvas { display: block; }
        #loading {
            position: absolute; top: 50%; left: 50%; 
            transform: translate(-50%, -50%); 
            color: #d4af37; font-size: 14px; letter-spacing: 2px;
            pointer-events: none; transition: opacity 0.5s;
            z-index: 10;
        }
    </style>
</head>
<body>
    <div id="loading">INITIALIZING VR SYSTEMS...</div>
    
    <!-- Import Map -->
    <script type="importmap">
        {
            "imports": {
                "three": "https://unpkg.com/three@0.160.0/build/three.module.js",
                "three/addons/": "https://unpkg.com/three@0.160.0/examples/jsm/",
                "lil-gui": "https://unpkg.com/lil-gui@0.19.1/dist/lil-gui.esm.min.js"
            }
        }
    </script>

    <script type="module">
        import * as THREE from 'three';
        import { OrbitControls } from 'three/addons/controls/OrbitControls.js';
        import { VRButton } from 'three/addons/webxr/VRButton.js';
        import { XRControllerModelFactory } from 'three/addons/webxr/XRControllerModelFactory.js';
        import Stats from 'three/addons/libs/stats.module.js';
        import GUI from 'lil-gui';

        // --- CONFIG & STATE ---
        const params = {
            baseWidth: 1.8, stemPinch: 0.2, bulbWidth: 1.9, bulbHeight: 6.5, totalHeight: 7.0,
            coreColor: '#fffdb0', midColor: '#ffaa00', edgeColor: '#aa2200',
            flowSpeed: 1.2, twistSpeed: 0.2, twistStrength: 1.0, noiseScale: 1.0,
            roughness: 2.0, brightness: 1.5,
            rimColor: '#aaccff', shellPulseSpeed: 0.5, shellDisplacement: 0.08,
            fresnelPower: 3.0, shellOpacity: 0.8,
            poolSize: 1.0, poolColor: '#ffaa00'
        };

        // --- SCENE SETUP ---
        const scene = new THREE.Scene();
        scene.background = new THREE.Color(0x000000);
        scene.fog = new THREE.FogExp2(0x000000, 0.02);

        const camera = new THREE.PerspectiveCamera(45, window.innerWidth / window.innerHeight, 0.1, 100);
        
        // --- VR RIG SETUP ---
        const dolly = new THREE.Group();
        dolly.position.set(0, 0, 8); // Start user 8 meters back
        dolly.add(camera);
        scene.add(dolly);

        const renderer = new THREE.WebGLRenderer({ antialias: true, alpha: false });
        renderer.setSize(window.innerWidth, window.innerHeight);
        renderer.setPixelRatio(Math.min(window.devicePixelRatio, 2));
        renderer.xr.enabled = true; // ENABLE WE BXR
        document.body.appendChild(renderer.domElement);
        document.body.appendChild(VRButton.createButton(renderer));

        // --- STATS ---
        const stats = new Stats();
        document.body.appendChild(stats.dom);

        // --- DESKTOP CONTROLS (Fallback) ---
        const controls = new OrbitControls(camera, renderer.domElement);
        controls.target.set(0, 3.5, 0);
        controls.enableDamping = true;

        // --- VR CONTROLLERS & RAYCASTING ---
        const controller1 = renderer.xr.getController(0);
        const controller2 = renderer.xr.getController(1);
        dolly.add(controller1);
        dolly.add(controller2);

        // Controller Models
        const controllerModelFactory = new XRControllerModelFactory();
        const controllerGrip1 = renderer.xr.getControllerGrip(0);
        controllerGrip1.add(controllerModelFactory.createControllerModel(controllerGrip1));
        dolly.add(controllerGrip1);

        const controllerGrip2 = renderer.xr.getControllerGrip(1);
        controllerGrip2.add(controllerModelFactory.createControllerModel(controllerGrip2));
        dolly.add(controllerGrip2);

        // Laser pointer visuals
        const laserGeo = new THREE.BufferGeometry().setFromPoints([new THREE.Vector3(0,0,0), new THREE.Vector3(0,0,-1)]);
        const laserMat = new THREE.LineBasicMaterial({ color: 0xffffff });
        const laser1 = new THREE.Line(laserGeo, laserMat); laser1.name = 'laser'; laser1.scale.z = 5;
        const laser2 = new THREE.Line(laserGeo, laserMat); laser2.name = 'laser'; laser2.scale.z = 5;
        controller1.add(laser1);
        controller2.add(laser2);

        // Teleport Marker
        const markerGeo = new THREE.RingGeometry(0.15, 0.2, 32).rotateX(-Math.PI / 2);
        const markerMat = new THREE.MeshBasicMaterial({ color: 0x00ff00 });
        const teleportMarker = new THREE.Mesh(markerGeo, markerMat);
        teleportMarker.visible = false;
        scene.add(teleportMarker);

        // Physics Floor (Invisible, larger than visual floor for teleporting)
        const floorGeo = new THREE.PlaneGeometry(50, 50);
        const floorPhysMat = new THREE.MeshBasicMaterial({ visible: false });
        const floorPhys = new THREE.Mesh(floorGeo, floorPhysMat);
        floorPhys.rotation.x = -Math.PI / 2;
        scene.add(floorPhys);

        const raycaster = new THREE.Raycaster();
        const tempMatrix = new THREE.Matrix4();

        // --- SHADER CHUNKS ---
        const noiseChunk = `
            vec4 permute(vec4 x){return mod(((x*34.0)+1.0)*x, 289.0);}
            vec4 taylorInvSqrt(vec4 r){return 1.79284291400159 - 0.85373472095314 * r;}
            float snoise(vec3 v){ 
                const vec2  C = vec2(1.0/6.0, 1.0/3.0) ;
                const vec4  D = vec4(0.0, 0.5, 1.0, 2.0);
                vec3 i  = floor(v + dot(v, C.yyy) );
                vec3 x0 = v - i + dot(i, C.xxx) ;
                vec3 g = step(x0.yzx, x0.xyz);
                vec3 l = 1.0 - g;
                vec3 i1 = min( g.xyz, l.zxy );
                vec3 i2 = max( g.xyz, l.zxy );
                vec3 x1 = x0 - i1 + 1.0 * C.xxx;
                vec3 x2 = x0 - i2 + 2.0 * C.xxx;
                vec3 x3 = x0 - 1.0 + 3.0 * C.xxx;
                i = mod(i, 289.0 ); 
                vec4 p = permute( permute( permute( 
                            i.z + vec4(0.0, i1.z, i2.z, 1.0 ))
                          + i.y + vec4(0.0, i1.y, i2.y, 1.0 )) 
                          + i.x + vec4(0.0, i1.x, i2.x, 1.0 ));
                float n_ = 1.0/7.0; 
                vec3  ns = n_ * D.wyz - D.xzx;
                vec4 j = p - 49.0 * floor(p * ns.z *ns.z); 
                vec4 x_ = floor(j * ns.z);
                vec4 y_ = floor(j - 7.0 * x_ ); 
                vec4 x = x_ *ns.x + ns.yyyy;
                vec4 y = y_ *ns.x + ns.yyyy;
                vec4 h = 1.0 - abs(x) - abs(y);
                vec4 b0 = vec4( x.xy, y.xy );
                vec4 b1 = vec4( x.zw, y.zw );
                vec4 s0 = floor(b0)*2.0 + 1.0;
                vec4 s1 = floor(b1)*2.0 + 1.0;
                vec4 sh = -step(h, vec4(0.0));
                vec4 a0 = b0.xzyw + s0.xzyw*sh.xxyy ;
                vec4 a1 = b1.xzyw + s1.xzyw*sh.zzww ;
                vec3 p0 = vec3(a0.xy,h.x);
                vec3 p1 = vec3(a0.zw,h.y);
                vec3 p2 = vec3(a1.xy,h.z);
                vec3 p3 = vec3(a1.zw,h.w);
                vec4 norm = taylorInvSqrt(vec4(dot(p0,p0), dot(p1,p1), dot(p2, p2), dot(p3,p3)));
                p0 *= norm.x; p1 *= norm.y; p2 *= norm.z; p3 *= norm.w;
                vec4 m = max(0.6 - vec4(dot(x0,x0), dot(x1,x1), dot(x2,x2), dot(x3,x3)), 0.0);
                m = m * m;
                return 42.0 * dot( m*m, vec4( dot(p0,x0), dot(p1,x1), dot(p2,x2), dot(p3,x3) ) );
            }
        `;

        // --- MATERIALS ---
        const plasmaMaterial = new THREE.ShaderMaterial({
            uniforms: {
                uTime: { value: 0 },
                uColorCore: { value: new THREE.Color(params.coreColor) },
                uColorMid: { value: new THREE.Color(params.midColor) },
                uColorEdge: { value: new THREE.Color(params.edgeColor) },
                uFlowSpeed: { value: params.flowSpeed },
                uTwistSpeed: { value: params.twistSpeed },
                uTwistStrength: { value: params.twistStrength },
                uNoiseScale: { value: params.noiseScale },
                uRoughness: { value: params.roughness },
                uBrightness: { value: params.brightness },
                uHeight: { value: params.totalHeight }
            },
            vertexShader: `
                uniform float uTime;
                uniform float uTwistSpeed;
                uniform float uTwistStrength;
                varying vec3 vPos;
                varying vec3 vNormal;
                varying vec3 vViewPosition;
                ${noiseChunk}
                void main() {
                    vNormal = normalize(normalMatrix * normal);
                    vec3 pos = position;
                    float twistAmt = uTwistStrength * pos.y; 
                    float angle = twistAmt - uTime * uTwistSpeed;
                    float s = sin(angle); float c = cos(angle);
                    mat2 rot = mat2(c, -s, s, c);
                    pos.xz = rot * pos.xz;
                    float wave = snoise(vec3(pos.x * 2.0, pos.y - uTime, pos.z * 2.0));
                    pos += normal * wave * 0.05;
                    vPos = pos;
                    vec4 mvPosition = modelViewMatrix * vec4(pos, 1.0);
                    vViewPosition = -mvPosition.xyz;
                    gl_Position = projectionMatrix * mvPosition;
                }
            `,
            fragmentShader: `
                uniform float uTime;
                uniform vec3 uColorCore;
                uniform vec3 uColorMid;
                uniform vec3 uColorEdge;
                uniform float uFlowSpeed;
                uniform float uNoiseScale;
                uniform float uRoughness;
                uniform float uBrightness;
                uniform float uHeight;
                varying vec3 vPos;
                varying vec3 vNormal;
                ${noiseChunk}
                void main() {
                    vec3 flowPos = vPos * uNoiseScale;
                    flowPos.y -= uTime * uFlowSpeed; 
                    float n1 = snoise(flowPos);
                    vec3 warp = flowPos + vec3(n1 * 0.5);
                    float n2 = snoise(warp * uRoughness + vec3(0.0, uTime * 0.2, 0.0));
                    float ribbon = sin(n2 * 10.0 + flowPos.y * 2.0); 
                    ribbon = smoothstep(-0.2, 0.8, ribbon);
                    vec3 finalColor = mix(uColorEdge, uColorMid, ribbon);
                    float coreIntensity = smoothstep(0.6, 1.0, n2 + ribbon * 0.5);
                    finalColor = mix(finalColor, uColorCore, coreIntensity);
                    float heightFactor = smoothstep(0.0, uHeight, vPos.y);
                    finalColor *= mix(1.2, 0.8, heightFactor);
                    float opacity = 0.6 + 0.4 * ribbon;
                    float groundFade = smoothstep(0.0, 0.3, vPos.y);
                    gl_FragColor = vec4(finalColor * uBrightness, opacity * groundFade);
                }
            `,
            transparent: true, blending: THREE.AdditiveBlending, side: THREE.DoubleSide, depthWrite: false
        });

        const shellMaterial = new THREE.ShaderMaterial({
            uniforms: {
                uTime: { value: 0 },
                uColorRim: { value: new THREE.Color(params.rimColor) },
                uPulseSpeed: { value: params.shellPulseSpeed },
                uDisplacement: { value: params.shellDisplacement },
                uFresnelPower: { value: params.fresnelPower },
                uOpacity: { value: params.shellOpacity }
            },
            vertexShader: `
                uniform float uTime;
                uniform float uPulseSpeed;
                uniform float uDisplacement;
                varying vec3 vNormal;
                varying vec3 vViewPosition;
                ${noiseChunk}
                void main() {
                    vec3 pos = position;
                    float breath = snoise(vec3(pos.x, pos.y * 0.5 + uTime * uPulseSpeed, pos.z));
                    pos += normal * breath * uDisplacement; 
                    vec4 mvPosition = modelViewMatrix * vec4(pos, 1.0);
                    vViewPosition = -mvPosition.xyz;
                    vNormal = normalize(normalMatrix * normal);
                    gl_Position = projectionMatrix * mvPosition;
                }
            `,
            fragmentShader: `
                uniform vec3 uColorRim;
                uniform float uFresnelPower;
                uniform float uOpacity;
                varying vec3 vNormal;
                varying vec3 vViewPosition;
                void main() {
                    vec3 viewDir = normalize(vViewPosition);
                    vec3 normal = normalize(vNormal);
                    float fresnel = dot(viewDir, normal);
                    fresnel = clamp(1.0 - fresnel, 0.0, 1.0);
                    float rim = pow(fresnel, uFresnelPower); 
                    float alpha = rim * uOpacity;
                    gl_FragColor = vec4(uColorRim * 2.0, alpha);
                }
            `,
            transparent: true, blending: THREE.AdditiveBlending, side: THREE.FrontSide, depthWrite: false
        });

        const floorMaterial = new THREE.ShaderMaterial({
            uniforms: {
                uTime: { value: 0 },
                uColor: { value: new THREE.Color(params.poolColor) }
            },
            vertexShader: `varying vec2 vUv; void main() { vUv = uv; gl_Position = projectionMatrix * modelViewMatrix * vec4(position, 1.0); }`,
            fragmentShader: `
                uniform float uTime;
                uniform vec3 uColor;
                varying vec2 vUv;
                ${noiseChunk}
                void main() {
                    vec2 uv = vUv - 0.5;
                    float dist = length(uv) * 2.0;
                    float alpha = 1.0 - smoothstep(0.0, 1.0, dist);
                    float angle = atan(uv.y, uv.x);
                    float noiseVal = snoise(vec3(uv * 5.0, uTime * 0.5));
                    float spiral = sin(dist * 10.0 - uTime * 2.0 + angle * 2.0);
                    vec3 color = uColor * (1.5 + spiral * 0.5);
                    gl_FragColor = vec4(color, alpha * 0.6 * (1.0 + noiseVal * 0.2));
                }
            `,
            transparent: true, blending: THREE.AdditiveBlending, depthWrite: false, side: THREE.DoubleSide
        });

        // --- GEOMETRY ---
        let coreMesh, shellMesh;
        // Create a group for the vortex so we can move/interact with it as one unit if needed
        const vortexGroup = new THREE.Group(); 
        scene.add(vortexGroup);

        function generateGeometry() {
            if(coreMesh) { coreMesh.geometry.dispose(); vortexGroup.remove(coreMesh); }
            if(shellMesh) { shellMesh.geometry.dispose(); vortexGroup.remove(shellMesh); }

            const points = [];
            points.push(new THREE.Vector2(params.baseWidth, 0));
            points.push(new THREE.Vector2(params.baseWidth * 0.5, 0.5));
            points.push(new THREE.Vector2(params.stemPinch, params.bulbHeight * 0.3));
            points.push(new THREE.Vector2(params.stemPinch * 1.5, params.bulbHeight * 0.5));
            points.push(new THREE.Vector2(params.bulbWidth, params.bulbHeight * 0.8));
            points.push(new THREE.Vector2(params.bulbWidth * 0.6, params.bulbHeight * 0.95));
            points.push(new THREE.Vector2(0.0, params.totalHeight));

            const geometryCurve = new THREE.SplineCurve(points);
            const geometry = new THREE.LatheGeometry(geometryCurve.getPoints(100), 80);

            plasmaMaterial.uniforms.uHeight.value = params.totalHeight;
            
            coreMesh = new THREE.Mesh(geometry, plasmaMaterial);
            vortexGroup.add(coreMesh);

            shellMesh = new THREE.Mesh(geometry.clone(), shellMaterial);
            shellMesh.scale.set(1.05, 1.02, 1.05);
            vortexGroup.add(shellMesh);
        }
        generateGeometry();

        // Visual Floor
        const floorGeometry = new THREE.PlaneGeometry(5, 5);
        const floorMesh = new THREE.Mesh(floorGeometry, floorMaterial);
        floorMesh.rotation.x = -Math.PI / 2;
        floorMesh.position.y = 0.05;
        scene.add(floorMesh);

        // --- GUI (Desktop only) ---
        const gui = new GUI({ title: 'Vortex Controller' });
        const fShape = gui.addFolder('Geometry');
        fShape.add(params, 'baseWidth', 0.5, 4.0).onChange(generateGeometry);
        fShape.add(params, 'stemPinch', 0.1, 1.5).onChange(generateGeometry);
        fShape.add(params, 'bulbWidth', 1.0, 4.0).onChange(generateGeometry);
        fShape.add(params, 'bulbHeight', 3.0, 10.0).onChange(generateGeometry);
        fShape.add(params, 'totalHeight', 4.0, 12.0).onChange(generateGeometry);
        const fPlasma = gui.addFolder('Plasma');
        fPlasma.addColor(params, 'coreColor').onChange(v => plasmaMaterial.uniforms.uColorCore.value.set(v));
        fPlasma.add(params, 'flowSpeed', 0.0, 3.0).onChange(v => plasmaMaterial.uniforms.uFlowSpeed.value = v);

        // --- VR INTERACTION LOGIC ---
        
        // 1. Teleportation Logic
        function handleTeleport(controller) {
            controller.updateMatrixWorld();
            tempMatrix.identity().extractRotation(controller.matrixWorld);
            raycaster.ray.origin.setFromMatrixPosition(controller.matrixWorld);
            raycaster.ray.direction.set(0, 0, -1).applyMatrix4(tempMatrix);
            
            // Raycast against the invisible physical floor
            const intersects = raycaster.intersectObject(floorPhys);

            if (intersects.length > 0) {
                const intersect = intersects[0];
                const laser = controller.getObjectByName('laser');
                if (laser) laser.scale.z = intersect.distance;
                
                teleportMarker.position.copy(intersect.point);
                teleportMarker.position.y += 0.05; // hover slightly
                teleportMarker.visible = true;
                controller.userData.teleportTarget = intersect.point;
            } else {
                teleportMarker.visible = false;
                const laser = controller.getObjectByName('laser');
                if (laser) laser.scale.z = 5; // default length
                controller.userData.teleportTarget = null;
            }
        }

        // Event Listeners for Teleport (Trigger)
        function onSelectStart(event) { event.target.userData.isSelecting = true; }
        
        function onSelectEnd(event) { 
            const controller = event.target;
            controller.userData.isSelecting = false;
            
            if (controller.userData.teleportTarget) {
                const target = controller.userData.teleportTarget;
                // Teleport Dolly
                const offset = dolly.position.clone().sub(target).setY(0);
                dolly.position.sub(offset);
                // Also reset marker
                teleportMarker.visible = false;
                controller.userData.teleportTarget = null;
            }
        }

        controller1.addEventListener('selectstart', onSelectStart);
        controller1.addEventListener('selectend', onSelectEnd);
        controller2.addEventListener('selectstart', onSelectStart);
        controller2.addEventListener('selectend', onSelectEnd);

        // --- ANIMATION ---
        const clock = new THREE.Clock();
        
        document.getElementById('loading').style.opacity = 0;

        // WEBXR ANIMATION LOOP
        renderer.setAnimationLoop(function () {
            stats.begin();
            
            const delta = clock.getDelta();
            const time = clock.getElapsedTime();

            // Update Shaders
            plasmaMaterial.uniforms.uTime.value = time;
            shellMaterial.uniforms.uTime.value = time;
            floorMaterial.uniforms.uTime.value = time;

            // Update Controls (Desktop)
            if (!renderer.xr.isPresenting) {
                controls.update();
            }

            // VR Handling
            if (renderer.xr.isPresenting) {
                // 1. Raycasting for Teleport (Left or Right controller)
                if (controller1.userData.isSelecting) handleTeleport(controller1);
                else if (controller2.userData.isSelecting) handleTeleport(controller2);
                else teleportMarker.visible = false;

                // 2. Thumbstick Locomotion (Smooth Slide)
                [controller1, controller2].forEach(ctrl => {
                    const gamepad = ctrl.gamepad; // WebXR gamepad
                    if (gamepad && gamepad.axes) {
                        // Left Stick (Axes 2 & 3 usually) or Right Stick
                        // Simple check: if axes have value
                        const ax = gamepad.axes[2] || gamepad.axes[0]; 
                        const ay = gamepad.axes[3] || gamepad.axes[1];

                        // Smooth Movement (Deadzone check)
                        if (Math.abs(ax) > 0.1 || Math.abs(ay) > 0.1) {
                            const speed = 2.0 * delta;
                            const forward = new THREE.Vector3(0, 0, -1).applyQuaternion(dolly.quaternion);
                            const right = new THREE.Vector3(1, 0, 0).applyQuaternion(dolly.quaternion);
                            
                            // Move dolly based on joystick
                            dolly.position.add(right.multiplyScalar(ax * speed));
                            dolly.position.add(forward.multiplyScalar(ay * speed));
                        }
                    }
                });
            }

            renderer.render(scene, camera);
            stats.end();
        });

        window.addEventListener('resize', () => {
            camera.aspect = window.innerWidth / window.innerHeight;
            camera.updateProjectionMatrix();
            renderer.setSize(window.innerWidth, window.innerHeight);
        });

    </script>
</body>
</html>