<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>The Living Plasma Vortex</title>
    <style>
        body { margin: 0; overflow: hidden; background-color: #000; }
        canvas { display: block; }
        #loading {
            position: absolute; top: 50%; left: 50%; 
            transform: translate(-50%, -50%); 
            color: #d4af37; font-family: sans-serif; 
            font-size: 14px; letter-spacing: 2px;
            pointer-events: none;
        }
    </style>
</head>
<body>
    <div id="loading">GENERATING PLASMA...</div>
    
    <!-- Import Three.js from CDN -->
    <script type="importmap">
        {
            "imports": {
                "three": "https://unpkg.com/three@0.160.0/build/three.module.js"
            }
        }
    </script>

    <script type="module">
        import * as THREE from 'three';

        // --- CONFIGURATION ---
        const CONFIG = {
            twistSpeed: 0.8,
            riseSpeed: 0.4,
            plasmaScale: 2.5,
            shellPulseSpeed: 1.2
        };

        // --- SCENE SETUP ---
        const scene = new THREE.Scene();
        scene.background = new THREE.Color(0x000000); // Pitch black background
        scene.fog = new THREE.FogExp2(0x000000, 0.02);

        const camera = new THREE.PerspectiveCamera(45, window.innerWidth / window.innerHeight, 0.1, 100);
        camera.position.set(0, 4, 11);
        camera.lookAt(0, 3.5, 0);

        const renderer = new THREE.WebGLRenderer({ antialias: true, alpha: false });
        renderer.setSize(window.innerWidth, window.innerHeight);
        renderer.setPixelRatio(Math.min(window.devicePixelRatio, 2)); // Optimize for high DPI
        document.body.appendChild(renderer.domElement);

        // --- COMMON GLSL UTILS (Noise) ---
        // We inject this into our shaders to create organic patterns without textures
        const noiseChunk = `
            // Simplex 3D Noise 
            vec4 permute(vec4 x){return mod(((x*34.0)+1.0)*x, 289.0);}
            vec4 taylorInvSqrt(vec4 r){return 1.79284291400159 - 0.85373472095314 * r;}

            float snoise(vec3 v){ 
                const vec2  C = vec2(1.0/6.0, 1.0/3.0) ;
                const vec4  D = vec4(0.0, 0.5, 1.0, 2.0);

                // First corner
                vec3 i  = floor(v + dot(v, C.yyy) );
                vec3 x0 = v - i + dot(i, C.xxx) ;

                // Other corners
                vec3 g = step(x0.yzx, x0.xyz);
                vec3 l = 1.0 - g;
                vec3 i1 = min( g.xyz, l.zxy );
                vec3 i2 = max( g.xyz, l.zxy );

                //  x0 = x0 - 0.0 + 0.0 * C 
                vec3 x1 = x0 - i1 + 1.0 * C.xxx;
                vec3 x2 = x0 - i2 + 2.0 * C.xxx;
                vec3 x3 = x0 - 1.0 + 3.0 * C.xxx;

                // Permutations
                i = mod(i, 289.0 ); 
                vec4 p = permute( permute( permute( 
                            i.z + vec4(0.0, i1.z, i2.z, 1.0 ))
                          + i.y + vec4(0.0, i1.y, i2.y, 1.0 )) 
                          + i.x + vec4(0.0, i1.x, i2.x, 1.0 ));

                // Gradients
                float n_ = 1.0/7.0; // N=7
                vec3  ns = n_ * D.wyz - D.xzx;

                vec4 j = p - 49.0 * floor(p * ns.z *ns.z);  //  mod(p,N*N)

                vec4 x_ = floor(j * ns.z);
                vec4 y_ = floor(j - 7.0 * x_ );    // mod(j,N)

                vec4 x = x_ *ns.x + ns.yyyy;
                vec4 y = y_ *ns.x + ns.yyyy;
                vec4 h = 1.0 - abs(x) - abs(y);

                vec4 b0 = vec4( x.xy, y.xy );
                vec4 b1 = vec4( x.zw, y.zw );

                vec4 s0 = floor(b0)*2.0 + 1.0;
                vec4 s1 = floor(b1)*2.0 + 1.0;
                vec4 sh = -step(h, vec4(0.0));

                vec4 a0 = b0.xzyw + s0.xzyw*sh.xxyy ;
                vec4 a1 = b1.xzyw + s1.xzyw*sh.zzww ;

                vec3 p0 = vec3(a0.xy,h.x);
                vec3 p1 = vec3(a0.zw,h.y);
                vec3 p2 = vec3(a1.xy,h.z);
                vec3 p3 = vec3(a1.zw,h.w);

                //Normalise gradients
                vec4 norm = taylorInvSqrt(vec4(dot(p0,p0), dot(p1,p1), dot(p2, p2), dot(p3,p3)));
                p0 *= norm.x;
                p1 *= norm.y;
                p2 *= norm.z;
                p3 *= norm.w;

                // Mix final noise value
                vec4 m = max(0.6 - vec4(dot(x0,x0), dot(x1,x1), dot(x2,x2), dot(x3,x3)), 0.0);
                m = m * m;
                return 42.0 * dot( m*m, vec4( dot(p0,x0), dot(p1,x1), 
                                              dot(p2,x2), dot(p3,x3) ) );
            }
        `;

        // --- GEOMETRY GENERATION ---
        // Create the Inverted Teardrop / Whirlwind shape
        const points = [];
        // Base flare
        points.push(new THREE.Vector2(1.8, 0)); 
        points.push(new THREE.Vector2(0.6, 0.4)); 
        // Narrow twisted stem
        points.push(new THREE.Vector2(0.2, 1.5)); 
        points.push(new THREE.Vector2(0.25, 3.0)); 
        // Bulbous top
        points.push(new THREE.Vector2(1.8, 5.5)); 
        points.push(new THREE.Vector2(1.4, 6.5)); 
        points.push(new THREE.Vector2(0.6, 6.8)); 
        // Closed top
        points.push(new THREE.Vector2(0.0, 6.7)); // Close the loop at center

        const geometryCurve = new THREE.SplineCurve(points);
        // High segment count for smooth shader displacement
        const baseGeometry = new THREE.LatheGeometry(geometryCurve.getPoints(80), 64);
        
        // --- 1. THE PLASMA CORE MATERIAL ---
        const plasmaMaterial = new THREE.ShaderMaterial({
            uniforms: {
                uTime: { value: 0 },
                uColorCore: { value: new THREE.Color(0xfffdb0) }, // Hot White/Yellow
                uColorMid: { value: new THREE.Color(0xffaa00) },  // Gold/Orange
                uColorEdge: { value: new THREE.Color(0xaa2200) }  // Deep Amber/Red
            },
            vertexShader: `
                uniform float uTime;
                varying vec2 vUv;
                varying vec3 vPos;
                varying float vElevation;
                varying vec3 vViewPosition;
                varying vec3 vNormal;

                ${noiseChunk}

                void main() {
                    vUv = uv;
                    vNormal = normalize(normalMatrix * normal);
                    
                    // Base position
                    vec3 pos = position;
                    
                    // --- GEOMETRIC TWIST ---
                    // Twist the geometry based on height to create the spiral flow structure
                    float twistAmt = 1.0 * pos.y; 
                    float angle = twistAmt - uTime * 0.2; // Rotate slowly
                    
                    float s = sin(angle);
                    float c = cos(angle);
                    mat2 rot = mat2(c, -s, s, c);
                    pos.xz = rot * pos.xz;

                    // Add subtle waviness to geometry
                    float wave = snoise(vec3(pos.x * 1.5, pos.y * 0.5 - uTime * 0.5, pos.z * 1.5));
                    pos += normal * wave * 0.1;

                    vPos = pos;
                    vElevation = pos.y;
                    
                    vec4 mvPosition = modelViewMatrix * vec4(pos, 1.0);
                    vViewPosition = -mvPosition.xyz;
                    gl_Position = projectionMatrix * mvPosition;
                }
            `,
            fragmentShader: `
                uniform float uTime;
                uniform vec3 uColorCore;
                uniform vec3 uColorMid;
                uniform vec3 uColorEdge;
                
                varying vec2 vUv;
                varying vec3 vPos;
                varying vec3 vNormal;
                varying vec3 vViewPosition;

                ${noiseChunk}

                void main() {
                    // Upward Flow coordinates
                    vec3 flowPos = vPos * vec3(1.5, 0.8, 1.5);
                    flowPos.y -= uTime * 1.2; // Move UP

                    // --- VISCOUS FLUID SIMULATION ---
                    // Layered noise to create "ribbons" of energy
                    float n1 = snoise(flowPos);
                    
                    // Domain warping: distort the second noise layer with the first
                    vec3 warp = flowPos + vec3(n1 * 0.5);
                    float n2 = snoise(warp * 2.0 + vec3(0.0, uTime * 0.5, 0.0));
                    
                    // Create sharp ribbons
                    float ribbon = sin(n2 * 10.0 + flowPos.y * 2.0); 
                    ribbon = smoothstep(-0.2, 0.8, ribbon); // Sharpen contrast

                    // --- COLOR MAPPING ---
                    // Mix based on the ribbon intensity
                    vec3 finalColor = mix(uColorEdge, uColorMid, ribbon);
                    // Add hot core highlights
                    float coreIntensity = smoothstep(0.6, 1.0, n2 + ribbon * 0.5);
                    finalColor = mix(finalColor, uColorCore, coreIntensity);

                    // --- VERTICAL GRADIENT ---
                    // Hotter at base/stem, slightly cooling at top bulb
                    float heightFactor = smoothstep(0.0, 7.0, vPos.y);
                    finalColor *= mix(1.2, 0.8, heightFactor);

                    // --- FAKE GLOW / OPACITY ---
                    // Make edges softer, center brighter
                    float opacity = 0.8 + 0.2 * ribbon;
                    
                    // Bottom fade out (fusion to ground)
                    float groundFade = smoothstep(0.0, 0.5, vPos.y);
                    
                    gl_FragColor = vec4(finalColor * 1.5, opacity * groundFade);
                }
            `,
            transparent: true,
            blending: THREE.AdditiveBlending,
            side: THREE.DoubleSide,
            depthWrite: false // Disable depth write for internal glow effect
        });

        // --- 2. THE ALIVE SHELL MATERIAL ---
        const shellMaterial = new THREE.ShaderMaterial({
            uniforms: {
                uTime: { value: 0 },
                uColorRim: { value: new THREE.Color(0xaaccff) }, // Cool Blue/White
            },
            vertexShader: `
                uniform float uTime;
                varying vec3 vNormal;
                varying vec3 vViewPosition;

                ${noiseChunk}

                void main() {
                    vec3 pos = position;

                    // "Breathing" displacement - organic ripple
                    float breath = snoise(vec3(pos.x, pos.y * 0.5 + uTime * 0.5, pos.z));
                    pos += normal * breath * 0.08; 

                    vec4 mvPosition = modelViewMatrix * vec4(pos, 1.0);
                    vViewPosition = -mvPosition.xyz;
                    vNormal = normalize(normalMatrix * normal);
                    gl_Position = projectionMatrix * mvPosition;
                }
            `,
            fragmentShader: `
                uniform vec3 uColorRim;
                varying vec3 vNormal;
                varying vec3 vViewPosition;

                void main() {
                    // Fresnel Effect for the Rim
                    vec3 viewDir = normalize(vViewPosition);
                    vec3 normal = normalize(vNormal);
                    
                    float fresnel = dot(viewDir, normal);
                    fresnel = clamp(1.0 - fresnel, 0.0, 1.0);
                    
                    // Sharpen the rim
                    float rim = pow(fresnel, 3.0); 

                    // Transparency: Center is transparent, edges are glowing
                    float alpha = rim * 0.8;

                    // Tint the rim
                    vec3 color = uColorRim * 2.0; // Boost intensity

                    gl_FragColor = vec4(color, alpha);
                }
            `,
            transparent: true,
            blending: THREE.AdditiveBlending,
            side: THREE.FrontSide,
            depthWrite: false
        });

        // --- 3. FLOOR POOL GLOW (Fake Bloom for Base) ---
        const floorGeometry = new THREE.PlaneGeometry(5, 5);
        const floorMaterial = new THREE.ShaderMaterial({
            uniforms: {
                uTime: { value: 0 },
                uColor: { value: new THREE.Color(0xffaa00) }
            },
            vertexShader: `
                varying vec2 vUv;
                void main() {
                    vUv = uv;
                    gl_Position = projectionMatrix * modelViewMatrix * vec4(position, 1.0);
                }
            `,
            fragmentShader: `
                uniform float uTime;
                uniform vec3 uColor;
                varying vec2 vUv;
                
                ${noiseChunk}

                void main() {
                    vec2 uv = vUv - 0.5;
                    float dist = length(uv) * 2.0;
                    
                    // Radial gradient fade
                    float alpha = 1.0 - smoothstep(0.0, 1.0, dist);
                    
                    // Swirling noise in the pool
                    float angle = atan(uv.y, uv.x);
                    float noiseVal = snoise(vec3(uv * 5.0, uTime * 0.5));
                    
                    // Add spirals
                    float spiral = sin(dist * 10.0 - uTime * 2.0 + angle * 2.0);
                    
                    vec3 color = uColor * (1.5 + spiral * 0.5);
                    
                    gl_FragColor = vec4(color, alpha * 0.6 * (1.0 + noiseVal * 0.2));
                }
            `,
            transparent: true,
            blending: THREE.AdditiveBlending,
            depthWrite: false
        });

        // --- MESH ASSEMBLY ---
        
        // 1. The Core (Plasma)
        const coreMesh = new THREE.Mesh(baseGeometry, plasmaMaterial);
        scene.add(coreMesh);

        // 2. The Shell (Slightly larger copy)
        // We scale it slightly in the Vertex Shader logic effectively, 
        // but let's scale the mesh slightly here to ensure envelopment.
        const shellMesh = new THREE.Mesh(baseGeometry.clone(), shellMaterial);
        shellMesh.scale.set(1.05, 1.02, 1.05); 
        scene.add(shellMesh);

        // 3. The Floor Pool
        const floorMesh = new THREE.Mesh(floorGeometry, floorMaterial);
        floorMesh.rotation.x = -Math.PI / 2;
        floorMesh.position.y = 0.05; // Just above 0 to avoid z-fighting if there was a floor
        scene.add(floorMesh);

        // Remove loading text
        document.getElementById('loading').style.display = 'none';

        // --- ANIMATION LOOP ---
        const clock = new THREE.Clock();

        function animate() {
            requestAnimationFrame(animate);

            const time = clock.getElapsedTime();

            // Update Uniforms
            plasmaMaterial.uniforms.uTime.value = time;
            shellMaterial.uniforms.uTime.value = time;
            floorMaterial.uniforms.uTime.value = time;

            // Slow camera drift for cinematic effect
            camera.position.x = Math.sin(time * 0.1) * 2;
            camera.position.z = 11 + Math.cos(time * 0.15) * 1;
            camera.lookAt(0, 3.5, 0);

            renderer.render(scene, camera);
        }

        animate();

        // --- RESIZE HANDLER ---
        window.addEventListener('resize', () => {
            camera.aspect = window.innerWidth / window.innerHeight;
            camera.updateProjectionMatrix();
            renderer.setSize(window.innerWidth, window.innerHeight);
        });

    </script>
</body>
</html>