<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8">
    <title>Safe Sphere: Design Exhibit</title>
    <script src="https://aframe.io/releases/1.7.0/aframe.min.js"></script>
    <style>
      body { margin: 0; overflow: hidden; font-family: 'Segoe UI', sans-serif; user-select: none; background: #000; }

      #ui-container {
        position: absolute; bottom: 50px; left: 50%; transform: translateX(-50%);
        z-index: 100; display: flex; flex-direction: column; align-items: center;
        gap: 15px; background: rgba(0, 0, 0, 0.85); padding: 25px;
        border-radius: 24px; backdrop-filter: blur(12px);
        border: 1px solid rgba(255, 255, 255, 0.15);
        box-shadow: 0 10px 40px rgba(0,0,0,0.8); min-width: 300px;
      }

      #fence-info { 
        color: #00eaff; font-family: monospace; font-size: 14px; 
        text-transform: uppercase; letter-spacing: 2px; margin-bottom: 5px;
        text-shadow: 0 0 10px rgba(0, 234, 255, 0.5);
      }
      
      button {
        width: 100%;
        background: rgba(0, 234, 255, 0.1); 
        border: 1px solid rgba(0, 234, 255, 0.3); 
        color: #00eaff; 
        padding: 12px 30px; font-size: 14px; text-transform: uppercase;
        letter-spacing: 1px; cursor: pointer; border-radius: 12px; 
        transition: all 0.2s ease; outline: none; font-weight: 700;
      }
      
      button:hover { 
        background: rgba(0, 234, 255, 0.25); 
        box-shadow: 0 0 20px rgba(0, 234, 255, 0.4); 
        transform: translateY(-2px);
      }
      
      button:active { transform: translateY(1px); }
    </style>
  </head>
  <body>

<div id="ui-container">
  <span id="fence-info">1/11: Silk Cocoon</span>
  <button onclick="toggleFence()">Next Design</button>
</div>

<a-scene background="color: #050508" renderer="antialias: true; colorManagement: true; sortObjects: true; highRefreshRate: true">
  
  <!-- Lighting Setup optimized for Volumetric/Glassy materials -->
  <a-entity light="type: ambient; intensity: 0.4; color: #ffffff"></a-entity>
  <a-entity light="type: point; intensity: 1.5; distance: 20; decay: 2; color: #00eaff" position="5 5 5"></a-entity>
  <a-entity light="type: point; intensity: 1.0; distance: 20; decay: 2; color: #ff00ea" position="-5 -5 5"></a-entity>
  
  <!-- Rim light for highlighting curves -->
  <a-entity light="type: spot; intensity: 2.0; angle: 45; penumbra: 0.5; color: #ffffff" position="0 10 0" rotation="-90 0 0"></a-entity>

  <!-- The Safe Sphere Container -->
  <a-entity id="safe-sphere-container" position="0 1.6 0" fence-manager ambient-breathing></a-entity>

  <!-- Floor Reference -->
  <a-gridhelper size="50" divisions="50" colorCenter="#333" colorGrid="#222" position="0 0 0"></a-gridhelper>

  <a-entity position="0 1.6 4">
    <a-camera look-controls wasd-controls="fly: true; acceleration: 20"></a-camera>
  </a-entity>

</a-scene>

<script>
  /* ----------------------------------------------------------------
     FENCE MANAGER: 11 Designs (Updated 8, 9, 10)
     ---------------------------------------------------------------- */
  AFRAME.registerComponent('fence-manager', {
    init: function() {
      this.designs = [
        { name: "Silk Cocoon", method: this.createCocoon.bind(this) },
        { name: "Neural Lattice", method: this.createNeuralLattice.bind(this) },
        { name: "Quantum Cloud", method: this.createQuantumCloud.bind(this) },
        { name: "Planar Intersect", method: this.createPlanarIntersect.bind(this) },
        { name: "Crystal Facet", method: this.createCrystalFacet.bind(this) },
        { name: "Spiral Sentry", method: this.createSpiralSentry.bind(this) },
        { name: "Atomic Shell", method: this.createAtomicShell.bind(this) },
        
        // --- NEW PARAMETRIC DESIGNS ---
        { name: "Harmonic Ripple", method: this.createHarmonicRipple.bind(this) }, // Replaces Void Cube
        { name: "Infinity Weave", method: this.createInfinityWeave.bind(this) },   // Replaces Trinity Rings
        { name: "Fluid Field", method: this.createFluidField.bind(this) },         // Replaces Star Prism
        // ------------------------------

        { name: "Double Helix", method: this.createDoubleHelix.bind(this) }
      ];
      this.currentIndex = 0;
      this.meshGroup = new THREE.Group();
      this.el.setObject3D('mesh', this.meshGroup);
      
      this.updateFence();
    },

    updateFence: function() {
      // Cleanup
      while(this.meshGroup.children.length > 0){ 
        const child = this.meshGroup.children[0];
        this.meshGroup.remove(child);
        if(child.geometry) child.geometry.dispose();
        if(child.material) {
          if(Array.isArray(child.material)) child.material.forEach(m => m.dispose());
          else child.material.dispose();
        }
      }
      
      // Create New
      const design = this.designs[this.currentIndex];
      design.method(this.meshGroup);
      
      // Update UI
      const info = document.getElementById('fence-info');
      if(info) info.innerText = `${this.currentIndex + 1}/11: ${design.name}`;
    },

    next: function() {
      this.currentIndex = (this.currentIndex + 1) % this.designs.length;
      this.updateFence();
    },

    /* --- 1. Silk Cocoon --- */
    createCocoon: function(group) {
      const geom = new THREE.TorusKnotGeometry(1.0, 0.35, 128, 32, 2, 3);
      const mat = new THREE.MeshStandardMaterial({
        color: 0xffffff, wireframe: true, opacity: 0.15, transparent: true,
        side: THREE.DoubleSide, blending: THREE.AdditiveBlending, depthWrite: false
      });
      const mesh = new THREE.Mesh(geom, mat);
      mesh.scale.set(1.2, 1.2, 1.2);
      group.add(mesh);
    },

    /* --- 2. Neural Lattice --- */
    createNeuralLattice: function(group) {
      const geom = new THREE.IcosahedronGeometry(1.6, 2);
      const wireGeo = new THREE.WireframeGeometry(geom);
      const mat = new THREE.LineBasicMaterial({
        color: 0xffffff, transparent: true, opacity: 0.3, linewidth: 1
      });
      const mesh = new THREE.LineSegments(wireGeo, mat);
      const coreGeom = new THREE.IcosahedronGeometry(1.4, 1);
      const coreMat = new THREE.MeshBasicMaterial({
        color: 0xffffff, transparent: true, opacity: 0.05, wireframe: true
      });
      group.add(mesh);
      group.add(new THREE.Mesh(coreGeom, coreMat));
    },

    /* --- 3. Quantum Cloud --- */
    createQuantumCloud: function(group) {
      const particleCount = 1500;
      const geom = new THREE.BufferGeometry();
      const positions = [];
      const r = 1.8;
      for (let i = 0; i < particleCount; i++) {
        const theta = Math.random() * Math.PI * 2;
        const phi = Math.acos(2 * Math.random() - 1);
        const x = r * Math.sin(phi) * Math.cos(theta);
        const y = r * Math.sin(phi) * Math.sin(theta);
        const z = r * Math.cos(phi);
        positions.push(x, y, z);
      }
      geom.setAttribute('position', new THREE.Float32BufferAttribute(positions, 3));
      const mat = new THREE.PointsMaterial({
        color: 0xffffff, size: 0.03, transparent: true, opacity: 0.6, blending: THREE.AdditiveBlending
      });
      group.add(new THREE.Points(geom, mat));
    },

    /* --- 4. Planar Intersect --- */
    createPlanarIntersect: function(group) {
      const mat = new THREE.MeshPhysicalMaterial({
        color: 0xffffff, metalness: 0.1, roughness: 0.1, 
        transmission: 0.1, opacity: 0.2, transparent: true, side: THREE.DoubleSide
      });
      const wireMat = new THREE.MeshBasicMaterial({
        color: 0xffffff, wireframe: true, opacity: 0.3, transparent: true
      });
      const size = 3.2; const thick = 0.05;
      const boxGeom = new THREE.BoxGeometry(size, thick, size);
      const b1 = new THREE.Mesh(boxGeom, mat);
      const b2 = new THREE.Mesh(boxGeom, mat); b2.rotation.x = Math.PI/2;
      const b3 = new THREE.Mesh(boxGeom, mat); b3.rotation.z = Math.PI/2;
      b1.add(new THREE.Mesh(boxGeom, wireMat));
      b2.add(new THREE.Mesh(boxGeom, wireMat));
      b3.add(new THREE.Mesh(boxGeom, wireMat));
      group.add(b1); group.add(b2); group.add(b3);
    },

    /* --- 5. Crystal Facet --- */
    createCrystalFacet: function(group) {
      const geom = new THREE.IcosahedronGeometry(1.7, 0);
      const mat = new THREE.MeshPhysicalMaterial({
        color: 0xffffff, roughness: 0.0, metalness: 0.1,
        transmission: 0.6, opacity: 1, transparent: true,
        flatShading: true, side: THREE.DoubleSide
      });
      const mesh = new THREE.Mesh(geom, mat);
      const wireG = new THREE.IcosahedronGeometry(1.75, 0);
      const wireM = new THREE.MeshBasicMaterial({ color: 0xffffff, wireframe: true, opacity: 0.3, transparent: true });
      group.add(mesh);
      group.add(new THREE.Mesh(wireG, wireM));
    },

    /* --- 6. Spiral Sentry --- */
    createSpiralSentry: function(group) {
      const geom = new THREE.TorusKnotGeometry(1.2, 0.4, 150, 20, 5, 8); 
      const wireGeo = new THREE.WireframeGeometry(geom);
      const wireMat = new THREE.LineBasicMaterial({ color: 0xffffff, opacity: 0.15, transparent: true });
      group.add(new THREE.LineSegments(wireGeo, wireMat));
    },

    /* --- 7. Atomic Shell --- */
    createAtomicShell: function(group) {
      const baseGeom = new THREE.IcosahedronGeometry(1.8, 1);
      const positions = baseGeom.attributes.position.array;
      const atomGeom = new THREE.SphereGeometry(0.06, 8, 8);
      const atomMat = new THREE.MeshStandardMaterial({ color: 0xffffff, roughness: 0.2, metalness: 0.8 });
      for(let i=0; i<positions.length; i+=3){
        const x = positions[i]; const y = positions[i+1]; const z = positions[i+2];
        const atom = new THREE.Mesh(atomGeom, atomMat);
        atom.position.set(x, y, z);
        group.add(atom);
      }
      const wireMat = new THREE.MeshBasicMaterial({ color: 0xffffff, wireframe: true, opacity: 0.05, transparent: true });
      group.add(new THREE.Mesh(baseGeom, wireMat));
    },

    /* ----------------------------------------------------------
       NEW: 8. Harmonic Ripple (Replaces Void Cube)
       A sphere deformed by a 3D sine wave function.
       ---------------------------------------------------------- */
    createHarmonicRipple: function(group) {
      // High segment count for smooth deformation
      const geom = new THREE.SphereGeometry(1.6, 128, 128);
      const pos = geom.attributes.position;
      const v = new THREE.Vector3();
      
      // Apply mathematical displacement: 
      // Radius = Base + sin(x*freq) * cos(y*freq) * sin(z*freq)
      for(let i=0; i<pos.count; i++){
        v.fromBufferAttribute(pos, i);
        const freq = 2.5; 
        const amp = 0.2;
        const distortion = Math.sin(v.x * freq) * Math.cos(v.y * freq) * Math.sin(v.z * freq);
        
        // Normalize to sphere then apply ripple radius
        v.normalize().multiplyScalar(1.5 + distortion * amp);
        pos.setXYZ(i, v.x, v.y, v.z);
      }
      
      geom.computeVertexNormals();

      const mat = new THREE.MeshPhysicalMaterial({
        color: 0xffffff,
        metalness: 0.9,
        roughness: 0.1,
        transmission: 0.2, // Slight glassiness
        opacity: 0.8,
        transparent: true,
        clearcoat: 1.0,
        clearcoatRoughness: 0.1,
        side: THREE.DoubleSide,
        flatShading: false
      });

      const mesh = new THREE.Mesh(geom, mat);
      
      // Subtle wireframe overlay to accentuate the topology
      const wireMat = new THREE.MeshBasicMaterial({
        color: 0xffffff, wireframe: true, opacity: 0.03, transparent: true
      });
      
      mesh.add(new THREE.Mesh(geom, wireMat));
      group.add(mesh);
    },

    /* ----------------------------------------------------------
       NEW: 9. Infinity Weave (Replaces Trinity Rings)
       A volumetric Torus Knot with thick radius and complex winding.
       ---------------------------------------------------------- */
    createInfinityWeave: function(group) {
      // p=3, q=4 creates a beautiful interwoven symmetrical flower pattern
      // Thick tube radius (0.25) makes it look like a solid volume
      const geom = new THREE.TorusKnotGeometry(1.2, 0.25, 200, 32, 3, 4);
      
      const mat = new THREE.MeshPhysicalMaterial({
        color: 0xffffff,
        roughness: 0.2,
        metalness: 0.6,
        transmission: 0.1,
        opacity: 0.5,
        transparent: true,
        side: THREE.DoubleSide,
        depthWrite: false // Allows seeing through the layers better
      });

      const mesh = new THREE.Mesh(geom, mat);
      
      // Inner glowing core to highlight the negative space
      const coreGeom = new THREE.SphereGeometry(0.8, 32, 32);
      const coreMat = new THREE.MeshBasicMaterial({
        color: 0xffffff, transparent: true, opacity: 0.05, blending: THREE.AdditiveBlending
      });
      
      group.add(mesh);
      group.add(new THREE.Mesh(coreGeom, coreMat));
    },

    /* ----------------------------------------------------------
       NEW: 10. Fluid Field (Replaces Star Prism)
       Organic, randomized displacement simulating a liquid suspended in 0G.
       ---------------------------------------------------------- */
    createFluidField: function(group) {
      const geom = new THREE.SphereGeometry(1.6, 96, 96);
      const pos = geom.attributes.position;
      const v = new THREE.Vector3();

      // "Noise-like" displacement using trigonometric combinations
      for(let i=0; i<pos.count; i++){
        v.fromBufferAttribute(pos, i);
        // Simulating noise with multiple sine waves
        let d = 0;
        d += Math.sin(v.x * 2.0 + 1.0);
        d += Math.sin(v.y * 2.3 + 2.0);
        d += Math.sin(v.z * 2.7 + 3.0);
        
        v.normalize().multiplyScalar(1.5 + (d * 0.15));
        pos.setXYZ(i, v.x, v.y, v.z);
      }
      geom.computeVertexNormals();

      // A "Ghost" material - very transparent but highly reflective (specular)
      const mat = new THREE.MeshPhysicalMaterial({
        color: 0xffffff,
        roughness: 0.05,
        metalness: 0.1,
        transmission: 0.8, // Mostly see-through
        thickness: 1.0,
        ior: 1.5,          // Refractive like glass
        opacity: 1,
        transparent: true,
        side: THREE.DoubleSide
      });
      
      // Wireframe mesh slightly larger to act as a "cage"
      const cageGeom = geom.clone();
      const cagePos = cageGeom.attributes.position;
      for(let i=0; i<cagePos.count; i++){
         v.fromBufferAttribute(cagePos, i);
         v.multiplyScalar(1.02); // Slightly larger
         cagePos.setXYZ(i, v.x, v.y, v.z);
      }
      const cageMat = new THREE.MeshBasicMaterial({
         color: 0xffffff, wireframe: true, opacity: 0.08, transparent: true
      });

      group.add(new THREE.Mesh(geom, mat));
      group.add(new THREE.Mesh(cageGeom, cageMat));
    },

    /* --- 11. Double Helix --- */
    createDoubleHelix: function(group) {
      const geom = new THREE.TorusKnotGeometry(1.0, 0.1, 100, 16, 2, 3);
      const mat = new THREE.MeshBasicMaterial({ color: 0xffffff, wireframe: true, opacity: 0.3, transparent: true });
      const m1 = new THREE.Mesh(geom, mat);
      const m2 = new THREE.Mesh(geom, mat);
      m2.scale.set(1.2, 1.2, 1.2); 
      m2.rotation.z = Math.PI;     
      group.add(m1); group.add(m2);
    }
  });

  /* ----------------------------------------------------------------
     AMBIENT BREATHING: Colors logic
     ---------------------------------------------------------------- */
  AFRAME.registerComponent('ambient-breathing', {
    init: function() {
      this.colorA = new THREE.Color('#00d2d3'); // Cyan
      this.colorB = new THREE.Color('#5f27cd'); // Deep Purple
      this.currentColor = new THREE.Color();
    },
    tick: function(time) {
      const alpha = (Math.sin(time * 0.0005) + 1) / 2;
      this.currentColor.copy(this.colorB).lerp(this.colorA, alpha);
      const hex = this.currentColor.getHex();

      const meshGroup = this.el.getObject3D('mesh');
      if (meshGroup) {
        meshGroup.traverse((node) => {
          if (node.material) {
            if (node.isPoints || node.isLineSegments || node.isLine) {
              node.material.color.setHex(hex);
            } else if (node.isMesh) {
              node.material.color.setHex(hex);
              // Adjust emissive for volume objects to keep them glowing
              if(node.material.emissive) {
                 node.material.emissive.setHex(hex);
                 // Lower emissive intensity for glassier objects
                 node.material.emissiveIntensity = node.material.transmission > 0 ? 0.2 : 0.5;
              }
            }
          }
        });
      }
    }
  });

  function toggleFence() {
    const el = document.getElementById('safe-sphere-container');
    if(el && el.components['fence-manager']) {
      el.components['fence-manager'].next();
    }
  }
</script>
  </body>
</html>