<!DOCTYPE html>
<html>
<head>
    <meta charset="utf-8">
    <title>Safe Sphere - Interactive A-Frame Scene</title>
    <script src="https://aframe.io/releases/1.7.0/aframe.min.js"></script>
    <style>
        body {
            font-family: 'Arial', sans-serif;
        }
        
        #controls {
            position: fixed;
            bottom: 20px;
            left: 50%;
            transform: translateX(-50%);
            display: flex;
            gap: 10px;
            z-index: 999;
            background: rgba(0, 0, 0, 0.7);
            padding: 15px;
            border-radius: 15px;
            backdrop-filter: blur(10px);
            max-width: 95vw;
            flex-wrap: wrap;
            justify-content: center;
        }
        
        .mode-btn {
            padding: 12px 24px;
            font-size: 16px;
            font-weight: bold;
            border: none;
            border-radius: 8px;
            cursor: pointer;
            transition: all 0.3s ease;
            text-transform: uppercase;
            letter-spacing: 1px;
            position: relative;
            overflow: hidden;
        }
        
        .mode-btn:before {
            content: '';
            position: absolute;
            top: 50%;
            left: 50%;
            width: 0;
            height: 0;
            border-radius: 50%;
            transform: translate(-50%, -50%);
            transition: width 0.3s, height 0.3s;
        }
        
        .mode-btn:hover:before {
            width: 100%;
            height: 100%;
        }
        
        .mode-btn.active {
            box-shadow: 0 0 20px rgba(255, 255, 255, 0.5);
            transform: scale(1.05);
        }
        
        #attack-btn {
            background: linear-gradient(135deg, #ff4444, #cc0000);
            color: white;
        }
        
        #attack-btn:hover {
            background: linear-gradient(135deg, #ff6666, #ff0000);
            box-shadow: 0 4px 15px rgba(255, 68, 68, 0.4);
        }
        
        #pressure-btn {
            background: linear-gradient(135deg, #ff8c00, #ff4500);
            color: white;
        }
        
        #pressure-btn:hover {
            background: linear-gradient(135deg, #ffa500, #ff6347);
            box-shadow: 0 4px 15px rgba(255, 140, 0, 0.4);
        }
        
        #pushback-btn {
            background: linear-gradient(135deg, #90EE90, #3CB371);
            color: white;
        }
        
        #pushback-btn:hover {
            background: linear-gradient(135deg, #98FB98, #2E8B57);
            box-shadow: 0 4px 15px rgba(144, 238, 144, 0.4);
        }
        
        #chill-btn {
            background: linear-gradient(135deg, #87CEEB, #4682B4);
            color: white;
        }
        
        #chill-btn:hover {
            background: linear-gradient(135deg, #87DEEB, #5F9EA0);
            box-shadow: 0 4px 15px rgba(135, 206, 235, 0.4);
        }

        @media (max-width: 768px) {
            #controls {
                bottom: 10px;
                padding: 10px;
                gap: 5px;
            }

            .mode-btn {
                padding: 8px 12px;
                font-size: 12px;
                min-width: 70px;
            }
        }
    </style>
</head>
<body>
    <div id="controls">
        <button id="attack-btn" class="mode-btn" onclick="setMode('attack')">Attack</button>
        <button id="pressure-btn" class="mode-btn" onclick="setMode('pressure')">Pressure</button>
        <button id="pushback-btn" class="mode-btn" onclick="setMode('pushback')">Push Back</button>
        <button id="chill-btn" class="mode-btn active" onclick="setMode('chill')">Chill</button>
    </div>

    <a-scene vr-mode-ui="enabled: false" background="color: #001122">
        <!-- Camera -->
        <a-camera position="0 0 8" look-controls wasd-controls></a-camera>
        
        <!-- Lighting -->
        <a-light type="ambient" color="#223344" intensity="0.3"></a-light>
        <a-light type="point" position="0 3 0" color="#ffffff" intensity="0.5"></a-light>
        
        <!-- Central Safe Sphere with Wireframe -->
        <a-entity id="safe-sphere" position="0 0 0">
            <!-- Main sphere -->
            <a-sphere 
                radius="1.5" 
                color="#00BFFF" 
                opacity="0.2"
                material="emissive: #00BFFF; emissiveIntensity: 0.3">
            </a-sphere>
            <!-- Wireframe overlay -->
            <a-entity 
                geometry="primitive: sphere; radius: 1.52; segmentsWidth: 24; segmentsHeight: 18"
                material="wireframe: true; color: #00FFFF; opacity: 0.8; emissive: #00FFFF; emissiveIntensity: 0.5">
            </a-entity>
        </a-entity>
        
        <!-- Container for impact effects -->
        <a-entity id="impact-container"></a-entity>
        
        <!-- Container for balls -->
        <a-entity id="balls-container"></a-entity>
        
        <!-- Invisible walls for boundary -->
        <a-box position="0 0 -2.5" width="5" height="5" depth="0.1" visible="false"></a-box>
        <a-box position="0 0 2.5" width="5" height="5" depth="0.1" visible="false"></a-box>
        <a-box position="-2.5 0 0" width="0.1" height="5" depth="5" visible="false"></a-box>
        <a-box position="2.5 0 0" width="0.1" height="5" depth="5" visible="false"></a-box>
        <a-box position="0 2.5 0" width="5" height="0.1" depth="5" visible="false"></a-box>
        <a-box position="0 -2.5 0" width="5" height="0.1" depth="5" visible="false"></a-box>
    </a-scene>

    <script>
        // Configuration
        const NUM_BALLS = 100;
        const BOX_SIZE = 5;
        const SPHERE_RADIUS = 1.5;
        const BALL_RADIUS = 0.05;
        const IMPACT_DURATION = 500; // 0.5 seconds in milliseconds
        
        // State
        let currentMode = 'chill';
        let balls = [];
        let animationId = null;
        let impactEffects = [];
        
        // Color schemes for different modes
        const colorSchemes = {
            chill: ['#87CEEB', '#B0E0E6', '#ADD8E6', '#87CEFA', '#00BFFF', '#5F9EA0'],
            attack: ['#FF4444', '#FF6B6B', '#DC143C', '#B22222', '#FF0000', '#8B0000'],
            pressure: ['#FF8C00', '#FF7F50', '#FF6347', '#FF4500', '#D2691E', '#CD853F'],
            pushback: ['#90EE90', '#98FB98', '#7FFF00', '#7CFC00', '#ADFF2F', '#9ACD32']
        };
        
        // Impact effect class
        class ImpactEffect {
            constructor(position, normal, mode) {
                this.position = position;
                this.normal = normal; // Surface normal at impact point
                this.startTime = Date.now();
                this.element = null;
                this.mode = mode;
                this.createEffect();
            }
            
            createEffect() {
                const container = document.querySelector('#impact-container');
                const entity = document.createElement('a-entity');
                
                // Create very thin ring at impact point
                entity.setAttribute('geometry', 'primitive: torus; radius: 0.05; radiusTubular: 0.001; segmentsRadial: 16; segmentsTubular: 32');
                
                // Position exactly on sphere surface
                entity.setAttribute('position', `${this.position.x} ${this.position.y} ${this.position.z}`);
                
                // Make the ring look away from center (0,0,0) so it lies flat on the sphere surface
                // We need to create a look-at point that's further out along the normal
                const lookAtPoint = {
                    x: this.position.x + this.normal.x,
                    y: this.position.y + this.normal.y,
                    z: this.position.z + this.normal.z
                };
                
                entity.setAttribute('look-at', `${lookAtPoint.x} ${lookAtPoint.y} ${lookAtPoint.z}`);
                
                // Yellow color for all impacts
                const color = '#FFFF00'; // Bright yellow
                entity.setAttribute('material', `color: ${color}; emissive: ${color}; emissiveIntensity: 4; opacity: 1; transparent: true; side: double`);
                
                container.appendChild(entity);
                this.element = entity;
            }
            
            update() {
                const elapsed = Date.now() - this.startTime;
                const progress = elapsed / IMPACT_DURATION;
                
                if (progress >= 1) {
                    // Remove the effect
                    if (this.element && this.element.parentNode) {
                        this.element.parentNode.removeChild(this.element);
                    }
                    return false; // Signal to remove from array
                }
                
                // Fade out and expand the ring
                const opacity = 1 - progress;
                const scale = 1 + progress * 4; // Expand to 5x size
                const intensity = 4 * (1 - progress * 0.7); // Keep glowing longer
                
                this.element.setAttribute('material', `opacity: ${opacity}; emissiveIntensity: ${intensity}`);
                this.element.setAttribute('scale', `${scale} ${scale} ${scale}`);
                
                return true; // Keep updating
            }
        }
        
        // Ball class to manage individual ball physics
        class Ball {
            constructor(index) {
                this.index = index;
                this.position = {
                    x: (Math.random() - 0.5) * (BOX_SIZE - 0.5),
                    y: (Math.random() - 0.5) * (BOX_SIZE - 0.5),
                    z: (Math.random() - 0.5) * (BOX_SIZE - 0.5)
                };
                this.velocity = {
                    x: (Math.random() - 0.5) * 0.02,
                    y: (Math.random() - 0.5) * 0.02,
                    z: (Math.random() - 0.5) * 0.02
                };
                this.targetVelocity = {...this.velocity};
                this.color = this.getRandomColor('chill');
                this.targetColor = this.color;
                this.element = null;
                this.glowIntensity = 0.5 + Math.random() * 0.5;
                this.attackCooldown = 0;
                this.createEntity();
            }
            
            getRandomColor(mode) {
                const colors = colorSchemes[mode];
                return colors[Math.floor(Math.random() * colors.length)];
            }
            
            createEntity() {
                const container = document.querySelector('#balls-container');
                const entity = document.createElement('a-sphere');
                entity.setAttribute('radius', BALL_RADIUS);
                entity.setAttribute('position', `${this.position.x} ${this.position.y} ${this.position.z}`);
                entity.setAttribute('color', this.color);
                entity.setAttribute('material', `emissive: ${this.color}; emissiveIntensity: ${this.glowIntensity}`);
                entity.setAttribute('id', `ball-${this.index}`);
                container.appendChild(entity);
                this.element = entity;
            }
            
            update(deltaTime, mode, sphereRadius) {
                const dt = deltaTime * 0.001; // Convert to seconds
                
                // Smooth velocity transition
                this.velocity.x += (this.targetVelocity.x - this.velocity.x) * 0.1;
                this.velocity.y += (this.targetVelocity.y - this.velocity.y) * 0.1;
                this.velocity.z += (this.targetVelocity.z - this.velocity.z) * 0.1;
                
                // Apply mode-specific behaviors
                if (mode === 'attack' && this.attackCooldown <= 0 && Math.random() < 0.002) {
                    // Random balls attack the sphere
                    const toSphere = {
                        x: -this.position.x,
                        y: -this.position.y,
                        z: -this.position.z
                    };
                    const dist = Math.sqrt(toSphere.x ** 2 + toSphere.y ** 2 + toSphere.z ** 2);
                    this.targetVelocity = {
                        x: (toSphere.x / dist) * 0.15,
                        y: (toSphere.y / dist) * 0.15,
                        z: (toSphere.z / dist) * 0.15
                    };
                    this.attackCooldown = 100;
                } else if (mode === 'pressure') {
                    // Move toward sphere surface
                    const toSphere = {
                        x: -this.position.x,
                        y: -this.position.y,
                        z: -this.position.z
                    };
                    const dist = Math.sqrt(toSphere.x ** 2 + toSphere.y ** 2 + toSphere.z ** 2);
                    const targetDist = sphereRadius + BALL_RADIUS * 2;
                    
                    if (dist > targetDist) {
                        this.targetVelocity = {
                            x: (toSphere.x / dist) * 0.03,
                            y: (toSphere.y / dist) * 0.03,
                            z: (toSphere.z / dist) * 0.03
                        };
                    } else {
                        this.targetVelocity = {
                            x: this.targetVelocity.x * 0.95,
                            y: this.targetVelocity.y * 0.95,
                            z: this.targetVelocity.z * 0.95
                        };
                    }
                } else if (mode === 'pushback') {
                    // Move away from sphere
                    const fromSphere = {
                        x: this.position.x,
                        y: this.position.y,
                        z: this.position.z
                    };
                    const dist = Math.sqrt(fromSphere.x ** 2 + fromSphere.y ** 2 + fromSphere.z ** 2);
                    
                    if (dist < BOX_SIZE / 2 - BALL_RADIUS) {
                        this.targetVelocity = {
                            x: (fromSphere.x / dist) * 0.04,
                            y: (fromSphere.y / dist) * 0.04,
                            z: (fromSphere.z / dist) * 0.04
                        };
                    }
                } else if (mode === 'chill') {
                    // Random walk
                    if (Math.random() < 0.01) {
                        this.targetVelocity = {
                            x: (Math.random() - 0.5) * 0.02,
                            y: (Math.random() - 0.5) * 0.02,
                            z: (Math.random() - 0.5) * 0.02
                        };
                    }
                }
                
                if (this.attackCooldown > 0) this.attackCooldown--;
                
                // Update position
                this.position.x += this.velocity.x;
                this.position.y += this.velocity.y;
                this.position.z += this.velocity.z;
                
                // Check wall collisions
                const boundary = BOX_SIZE / 2 - BALL_RADIUS;
                if (Math.abs(this.position.x) > boundary) {
                    this.position.x = Math.sign(this.position.x) * boundary;
                    this.velocity.x *= -0.8;
                    this.targetVelocity.x *= -0.8;
                }
                if (Math.abs(this.position.y) > boundary) {
                    this.position.y = Math.sign(this.position.y) * boundary;
                    this.velocity.y *= -0.8;
                    this.targetVelocity.y *= -0.8;
                }
                if (Math.abs(this.position.z) > boundary) {
                    this.position.z = Math.sign(this.position.z) * boundary;
                    this.velocity.z *= -0.8;
                    this.targetVelocity.z *= -0.8;
                }
                
                // Check sphere collision
                const distToCenter = Math.sqrt(
                    this.position.x ** 2 + 
                    this.position.y ** 2 + 
                    this.position.z ** 2
                );
                
                if (distToCenter < sphereRadius + BALL_RADIUS) {
                    // Calculate impact position on sphere surface
                    const normal = {
                        x: this.position.x / distToCenter,
                        y: this.position.y / distToCenter,
                        z: this.position.z / distToCenter
                    };
                    
                    // Position exactly on sphere surface
                    const impactPos = {
                        x: normal.x * sphereRadius,
                        y: normal.y * sphereRadius,
                        z: normal.z * sphereRadius
                    };
                    
                    // Create impact effect for attack mode (always for attacking balls)
                    // or occasionally for other high-velocity impacts
                    if (mode === 'attack' && this.attackCooldown > 90) {
                        // Guaranteed impact flash for attacking balls
                        impactEffects.push(new ImpactEffect(impactPos, normal, mode));
                    } else if (Math.random() < 0.05 && 
                              Math.abs(this.velocity.x) + Math.abs(this.velocity.y) + Math.abs(this.velocity.z) > 0.08) {
                        // Occasional impact for high-velocity collisions in other modes
                        impactEffects.push(new ImpactEffect(impactPos, normal, mode));
                    }
                    
                    // Bounce off sphere
                    this.position.x = normal.x * (sphereRadius + BALL_RADIUS);
                    this.position.y = normal.y * (sphereRadius + BALL_RADIUS);
                    this.position.z = normal.z * (sphereRadius + BALL_RADIUS);
                    
                    const dotProduct = this.velocity.x * normal.x + 
                                     this.velocity.y * normal.y + 
                                     this.velocity.z * normal.z;
                    
                    this.velocity.x -= 2 * dotProduct * normal.x;
                    this.velocity.y -= 2 * dotProduct * normal.y;
                    this.velocity.z -= 2 * dotProduct * normal.z;
                    
                    this.velocity.x *= 0.8;
                    this.velocity.y *= 0.8;
                    this.velocity.z *= 0.8;
                    
                    this.targetVelocity = {...this.velocity};
                }
                
                // Update element position
                this.element.setAttribute('position', 
                    `${this.position.x} ${this.position.y} ${this.position.z}`);
            }
            
            checkCollision(other) {
                const dx = this.position.x - other.position.x;
                const dy = this.position.y - other.position.y;
                const dz = this.position.z - other.position.z;
                const distance = Math.sqrt(dx * dx + dy * dy + dz * dz);
                
                if (distance < BALL_RADIUS * 2) {
                    // Simple elastic collision
                    const normal = {
                        x: dx / distance,
                        y: dy / distance,
                        z: dz / distance
                    };
                    
                    // Separate balls
                    const overlap = BALL_RADIUS * 2 - distance;
                    this.position.x += normal.x * overlap * 0.5;
                    this.position.y += normal.y * overlap * 0.5;
                    this.position.z += normal.z * overlap * 0.5;
                    
                    other.position.x -= normal.x * overlap * 0.5;
                    other.position.y -= normal.y * overlap * 0.5;
                    other.position.z -= normal.z * overlap * 0.5;
                    
                    // Exchange velocities along collision normal
                    const v1 = this.velocity.x * normal.x + 
                              this.velocity.y * normal.y + 
                              this.velocity.z * normal.z;
                    const v2 = other.velocity.x * normal.x + 
                              other.velocity.y * normal.y + 
                              other.velocity.z * normal.z;
                    
                    this.velocity.x += (v2 - v1) * normal.x * 0.8;
                    this.velocity.y += (v2 - v1) * normal.y * 0.8;
                    this.velocity.z += (v2 - v1) * normal.z * 0.8;
                    
                    other.velocity.x += (v1 - v2) * normal.x * 0.8;
                    other.velocity.y += (v1 - v2) * normal.y * 0.8;
                    other.velocity.z += (v1 - v2) * normal.z * 0.8;
                    
                    this.targetVelocity = {...this.velocity};
                    other.targetVelocity = {...other.velocity};
                }
            }
            
            updateColor(mode) {
                const newColor = this.getRandomColor(mode);
                this.targetColor = newColor;
                
                // Smooth color transition
                const currentColor = this.element.getAttribute('color');
                const currentRGB = hexToRGB(currentColor);
                const targetRGB = hexToRGB(newColor);
                
                const r = Math.round(currentRGB.r + (targetRGB.r - currentRGB.r) * 0.05);
                const g = Math.round(currentRGB.g + (targetRGB.g - currentRGB.g) * 0.05);
                const b = Math.round(currentRGB.b + (targetRGB.b - currentRGB.b) * 0.05);
                
                const transitionColor = rgbToHex(r, g, b);
                this.element.setAttribute('color', transitionColor);
                this.element.setAttribute('material', 
                    `emissive: ${transitionColor}; emissiveIntensity: ${this.glowIntensity}`);
            }
        }
        
        // Utility functions for color manipulation
        function hexToRGB(hex) {
            const result = /^#?([a-f\d]{2})([a-f\d]{2})([a-f\d]{2})$/i.exec(hex);
            return result ? {
                r: parseInt(result[1], 16),
                g: parseInt(result[2], 16),
                b: parseInt(result[3], 16)
            } : { r: 135, g: 206, b: 235 };
        }
        
        function rgbToHex(r, g, b) {
            return "#" + ((1 << 24) + (r << 16) + (g << 8) + b).toString(16).slice(1);
        }
        
        // Initialize balls
        function initBalls() {
            const container = document.querySelector('#balls-container');
            container.innerHTML = ''; // Clear existing balls
            balls = [];
            
            for (let i = 0; i < NUM_BALLS; i++) {
                balls.push(new Ball(i));
            }
        }
        
        // Animation loop
        let lastTime = Date.now();
        let sphereRadius = SPHERE_RADIUS;
        let targetSphereRadius = SPHERE_RADIUS;
        let pushbackStartTime = 0;
        const PUSHBACK_DURATION = 3000; // 3 seconds for pushback to complete
        
        function animate() {
            const currentTime = Date.now();
            const deltaTime = currentTime - lastTime;
            lastTime = currentTime;
            
            // Update sphere radius based on mode
            if (currentMode === 'pressure') {
                targetSphereRadius = Math.max(0.8, SPHERE_RADIUS - 0.3);
                pushbackStartTime = 0; // Reset pushback timer
            } else if (currentMode === 'pushback') {
                targetSphereRadius = Math.min(2.2, SPHERE_RADIUS + 0.5);
                
                // Start pushback timer if not started
                if (pushbackStartTime === 0) {
                    pushbackStartTime = currentTime;
                }
                
                // Check if pushback is complete
                if (currentTime - pushbackStartTime > PUSHBACK_DURATION && 
                    Math.abs(sphereRadius - targetSphereRadius) < 0.01) {
                    // Auto-switch to chill mode
                    setMode('chill');
                    pushbackStartTime = 0;
                }
            } else {
                targetSphereRadius = SPHERE_RADIUS;
                pushbackStartTime = 0; // Reset pushback timer
            }
            
            // Smooth sphere size transition
            sphereRadius += (targetSphereRadius - sphereRadius) * 0.02;
            
            const sphere = document.querySelector('#safe-sphere a-sphere');
            const wireframe = document.querySelector('#safe-sphere a-entity');
            
            sphere.setAttribute('radius', sphereRadius);
            wireframe.setAttribute('geometry', `radius: ${sphereRadius + 0.02}`);
            
            // Update impact effects
            impactEffects = impactEffects.filter(effect => effect.update());
            
            // Update ball colors smoothly
            balls.forEach(ball => ball.updateColor(currentMode));
            
            // Update ball physics
            balls.forEach(ball => ball.update(deltaTime, currentMode, sphereRadius));
            
            // Check ball-to-ball collisions
            for (let i = 0; i < balls.length; i++) {
                for (let j = i + 1; j < balls.length; j++) {
                    balls[i].checkCollision(balls[j]);
                }
            }
            
            animationId = requestAnimationFrame(animate);
        }
        
        // Mode switching
        function setMode(mode) {
            currentMode = mode;
            
            // Update button states
            document.querySelectorAll('.mode-btn').forEach(btn => {
                btn.classList.remove('active');
            });
            document.querySelector(`#${mode}-btn`).classList.add('active');
            
            // Update sphere color based on mode
            const sphere = document.querySelector('#safe-sphere a-sphere');
            const wireframe = document.querySelector('#safe-sphere a-entity');
            
            const sphereColors = {
                chill: '#00BFFF',
                attack: '#FF69B4',
                pressure: '#FFA500',
                pushback: '#00FF00'
            };
            
            sphere.setAttribute('color', sphereColors[mode]);
            sphere.setAttribute('material', `emissive: ${sphereColors[mode]}; emissiveIntensity: 0.3`);
            wireframe.setAttribute('material', `color: ${sphereColors[mode]}; emissive: ${sphereColors[mode]}; emissiveIntensity: 0.5`);
        }
        
        // Start the scene
        document.addEventListener('DOMContentLoaded', function() {
            setTimeout(() => {
                initBalls();
                animate();
                setMode('chill'); // Start in chill mode
            }, 1000);
        });
        
        // Clean up on page unload
        window.addEventListener('beforeunload', () => {
            if (animationId) {
                cancelAnimationFrame(animationId);
            }
        });
    </script>
</body>
</html>