<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>TerrainShader Pro v5 | Final Edition</title>
    <style>
        :root {
            --bg-color: #121212;
            --panel-color: #1e1e1e;
            --text-color: #e0e0e0;
            --accent-color: #ff9f1c; /* Sun/Gold Accent */
            --accent-hover: #e08e1a;
            --border-color: #333;
            --input-bg: #2a2a2a;
        }

        body { margin: 0; overflow: hidden; font-family: 'Segoe UI', sans-serif; background: var(--bg-color); color: var(--text-color); display: flex; height: 100vh; }
        
        /* Layout */
        #dashboard {
            width: 350px; background: var(--panel-color); border-right: 1px solid var(--border-color);
            display: flex; flex-direction: column; z-index: 10; box-shadow: 4px 0 15px rgba(0,0,0,0.4);
        }
        .header { padding: 20px; border-bottom: 1px solid var(--border-color); font-weight: 700; font-size: 1.2em; letter-spacing: 1px; color: #fff; background: linear-gradient(45deg, #1e1e1e, #2a2a2a); }
        .header span { color: var(--accent-color); }
        
        .scroll-area { flex: 1; overflow-y: auto; padding: 15px; }
        .scroll-area::-webkit-scrollbar { width: 6px; }
        .scroll-area::-webkit-scrollbar-thumb { background: #444; border-radius: 3px; }

        /* UI Components */
        .panel { background: #262626; border: 1px solid var(--border-color); border-radius: 6px; margin-bottom: 16px; overflow: hidden; }
        .panel-header { padding: 12px 15px; background: #2f2f2f; font-size: 0.85em; font-weight: 600; text-transform: uppercase; letter-spacing: 0.5px; border-bottom: 1px solid var(--border-color); display: flex; justify-content: space-between; align-items: center; }
        .panel-content { padding: 15px; }

        .control-group { margin-bottom: 15px; }
        .control-group label { display: flex; justify-content: space-between; margin-bottom: 6px; font-size: 0.85em; color: #aaa; }
        
        input[type="range"] { width: 100%; -webkit-appearance: none; background: transparent; cursor: pointer; }
        input[type="range"]::-webkit-slider-runnable-track { width: 100%; height: 4px; background: #444; border-radius: 2px; }
        input[type="range"]::-webkit-slider-thumb { -webkit-appearance: none; height: 14px; width: 14px; border-radius: 50%; background: var(--accent-color); margin-top: -5px; box-shadow: 0 0 5px rgba(0,0,0,0.5); }
        
        input[type="color"] { width: 100%; height: 30px; border: none; background: none; cursor: pointer; }
        select { width: 100%; padding: 10px; background: var(--input-bg); border: 1px solid var(--border-color); color: white; border-radius: 4px; outline: none; }

        button { width: 100%; padding: 10px; background: var(--input-bg); border: 1px solid var(--border-color); color: white; border-radius: 4px; cursor: pointer; font-size: 0.9em; transition: 0.2s; margin-bottom: 6px; }
        button:hover { background: #353535; }
        button.active { background: var(--accent-color); border-color: var(--accent-color); color: #000; font-weight: bold; }
        button.primary { background: var(--accent-color); color: #000; font-weight: bold; border: none; margin-top: 5px;}
        button.primary:hover { background: var(--accent-hover); }

        .tool-grid { display: grid; grid-template-columns: 1fr 1fr; gap: 8px; }
        
        /* Viewport */
        #viewport { flex: 1; position: relative; background: #000; cursor: default; }
        #overlay { position: absolute; top: 20px; left: 20px; pointer-events: none; background: rgba(0,0,0,0.6); padding: 10px 15px; border-radius: 4px; font-size: 0.85em; color: #fff; backdrop-filter: blur(4px); border: 1px solid rgba(255,255,255,0.1); }
        
        #gps-tooltip { position: fixed; background: rgba(0,0,0,0.85); border: 1px solid var(--accent-color); color: var(--accent-color); padding: 6px 12px; border-radius: 4px; font-family: monospace; font-size: 0.85em; pointer-events: none; display: none; z-index: 1000; transform: translate(15px, 15px); }

        /* Modal */
        #code-modal { display: none; position: fixed; top: 0; left: 0; width: 100%; height: 100%; background: rgba(0,0,0,0.9); z-index: 100; justify-content: center; align-items: center; }
        .modal-box { background: #1e1e1e; width: 80%; height: 85%; border-radius: 8px; display: flex; flex-direction: column; border: 1px solid #444; box-shadow: 0 0 40px rgba(0,0,0,0.6); }
        .modal-header { padding:15px; border-bottom:1px solid #444; background:#222; display:flex; justify-content:space-between; align-items: center; }
        textarea { flex: 1; background: #151515; color: #aaddff; border: none; padding: 20px; font-family: monospace; resize: none; font-size: 0.9em; outline: none; }
    </style>
    
    <script type="importmap">
        {
            "imports": {
                "three": "https://unpkg.com/three@0.160.0/build/three.module.js",
                "three/addons/": "https://unpkg.com/three@0.160.0/examples/jsm/"
            }
        }
    </script>
</head>
<body>

    <div id="dashboard">
        <div class="header">Terrain<span>Shader Pro v5</span></div>
        <div class="scroll-area">

            <!-- World Config -->
            <div class="panel">
                <div class="panel-header">World Settings</div>
                <div class="panel-content">
                    <div class="control-group">
                        <label>Size (Meters) <span id="val-size">400m</span></label>
                        <input type="range" id="inp-size" min="100" max="1000" step="50" value="400">
                    </div>
                    <div class="control-group">
                        <label>Grid Resolution <span id="val-res">256</span></label>
                        <input type="range" id="inp-res" min="64" max="512" step="64" value="256">
                        <small style="color:#777; font-size:0.75em;">‚ö†Ô∏è Resets terrain shape</small>
                    </div>
                </div>
            </div>

            <!-- Tools -->
            <div class="panel">
                <div class="panel-header">Tools</div>
                <div class="panel-content">
                    <div class="tool-grid">
                        <button class="active" onclick="setTool('mountain', this)">‚õ∞Ô∏è Mountain</button>
                        <button onclick="setTool('valley', this)">üìâ Valley</button>
                        <button onclick="setTool('flatten', this)">üìê Flatten</button>
                        <button onclick="setTool('smooth', this)">üí® Smooth</button>
                        <button onclick="setTool('gps', this)">üìç GPS Probe</button>
                        <button onclick="setTool('sun', this)">‚òÄÔ∏è Move Sun</button>
                        <!-- Added Walk Tool -->
                        <button id="btn-walk" onclick="handleWalkButton(this)" style="grid-column: span 2;">üö∂ Take a Walk</button>
                        <button onclick="setTool('nav', this)" style="grid-column: span 2; background:#333; color:white;">‚úã Navigate / Rotate</button>
                    </div>
                    <div class="control-group" style="margin-top:10px;">
                        <label>Brush Size <span id="val-radius">25</span></label>
                        <input type="range" id="inp-radius" min="5" max="60" value="25">
                    </div>
                    <div class="control-group">
                        <label>Intensity <span id="val-str">5</span></label>
                        <input type="range" id="inp-str" min="1" max="20" value="5">
                    </div>
                </div>
            </div>

            <!-- Atmosphere -->
            <div class="panel">
                <div class="panel-header">Atmosphere</div>
                <div class="panel-content">
                    <div class="control-group">
                        <label>Ambient Light <span id="val-ambient">60%</span></label>
                        <input type="range" id="inp-ambient" min="0" max="1" step="0.05" value="0.6">
                    </div>
                    <div class="control-group">
                        <label>Water Level <span id="val-water">0m</span></label>
                        <input type="range" id="inp-water" min="-20" max="20" value="0">
                    </div>
                    <div class="control-group">
                        <label>Fog Density <span id="val-fog">0.005</span></label>
                        <input type="range" id="inp-fog" min="0" max="0.02" step="0.001" value="0.005">
                    </div>
                </div>
            </div>

            <!-- Shaders -->
            <div class="panel">
                <div class="panel-header">Biome Shaders</div>
                <div class="panel-content">
                    <div class="control-group">
                        <label>Snow Level <span id="val-snow">45m</span></label>
                        <input type="range" id="sh-snow-h" min="10" max="80" value="45">
                    </div>
                    <div class="control-group"><label>Grass Color</label><input type="color" id="col-grass" value="#416135"></div>
                    <div class="control-group"><label>Rock Color</label><input type="color" id="col-rock" value="#5a4d41"></div>
                    <div class="control-group"><label>Sand Color</label><input type="color" id="col-sand" value="#d4c79e"></div>
                    <div class="control-group"><label>Water Color</label><input type="color" id="col-water" value="#006994"></div>
                </div>
            </div>

            <!-- Nature -->
            <div class="panel">
                <div class="panel-header">Vegetation</div>
                <div class="panel-content">
                    <button onclick="scatterVegetation()">üå≤ Regenerate Forest</button>
                    <div class="control-group" style="margin-top:10px">
                        <label>Tree Density</label>
                        <input type="range" id="inp-trees" min="0" max="5000" value="1000">
                    </div>
                </div>
            </div>

            <div class="panel">
                <div class="panel-content">
                    <button class="primary" onclick="openExportModal()">Export Code...</button>
                </div>
            </div>

        </div>
    </div>

    <!-- VIEWPORT -->
    <div id="viewport">
        <div id="overlay">
            LMB: Action ‚Ä¢ RMB: Rotate ‚Ä¢ Scroll: Zoom<br>
            <span id="tool-status" style="color:#aaa; font-size:0.9em">Tool: MOUNTAIN</span>
            <div id="walk-help" style="display:none; color: var(--accent-color);">WASD to Move ‚Ä¢ Mouse to Look ‚Ä¢ ESC to Exit</div>
        </div>
        <div id="gps-tooltip">X: 0.0 Z: 0.0 H: 0.0m</div>
    </div>

    <!-- CODE MODAL -->
    <div id="code-modal">
        <div class="modal-box">
            <div class="modal-header">
                <span style="color:#fff; font-weight:bold">Export Project Code</span>
                <select id="export-mode" style="width: 220px; padding: 5px; background:#333; color:white; border:1px solid #555;" onchange="exportSystem()">
                    <option value="full">Full Scene (Water+Lights)</option>
                    <option value="geo_shader">Geometry + Shaders</option>
                    <option value="geo_parts">Geometry with Named Parts</option>
                    <option value="geo_only">Geometry Only</option>
                </select>
                <button onclick="document.getElementById('code-modal').style.display='none'" style="width:auto; padding:5px 15px; margin:0;">Close</button>
            </div>
            <textarea id="code-output" readonly></textarea>
        </div>
    </div>

    <!-- MAIN LOGIC -->
    <script type="module">
        import * as THREE from 'three';
        import { OrbitControls } from 'three/addons/controls/OrbitControls.js';
        import { TransformControls } from 'three/addons/controls/TransformControls.js';
        import { Sky } from 'three/addons/objects/Sky.js';
        import { PointerLockControls } from 'three/addons/controls/PointerLockControls.js';

        // ==========================================
        // 1. GLOBAL VARIABLES (Declared Before Use)
        // ==========================================
        let scene, camera, renderer, controls, transformControl, walkControls;
        let terrainMesh, waterMesh, brushHelper, sunSphere, sunLight, sky, treesMesh;
        
        // Terrain Data
        let SEGMENTS = 256;
        let WORLD_SIZE = 400;
        let heightData = new Float32Array((SEGMENTS+1)*(SEGMENTS+1)).fill(0);
        
        // Interaction
        const raycaster = new THREE.Raycaster();
        const pointer = new THREE.Vector2();
        const gpsTip = document.getElementById('gps-tooltip');
        const heightRaycaster = new THREE.Raycaster(); // Dedicated for walking physics

        // Walk Mode Variables
        let isWalking = false;
        let moveForward = false;
        let moveBackward = false;
        let moveLeft = false;
        let moveRight = false;
        const velocity = new THREE.Vector3();
        const direction = new THREE.Vector3();
        const walkSpeed = 30.0;
        let prevTime = performance.now();

        // Application State
        const state = {
            tool: 'mountain', 
            radius: 25,
            strength: 5,
            isDrawing: false,
            ambientIntensity: 0.6,
            waterLevel: 0,
            snowLevel: 45,
            flattenHeight: null,
            colors: {
                grass: new THREE.Color('#416135'),
                rock: new THREE.Color('#5a4d41'),
                sand: new THREE.Color('#d4c79e'),
                water: new THREE.Color('#006994'),
                snow: new THREE.Color('#ffffff')
            }
        };

        // ==========================================
        // 2. SHADER DEFINITIONS
        // ==========================================
        const terrainVertexShader = `
            varying vec3 vNormal;
            varying vec3 vPosition;
            varying float vSlope;
            void main() {
                vec4 worldPosition = modelMatrix * vec4(position, 1.0);
                vPosition = worldPosition.xyz;
                vNormal = normalize(mat3(modelMatrix) * normal);
                vSlope = dot(vNormal, vec3(0.0, 1.0, 0.0));
                gl_Position = projectionMatrix * viewMatrix * worldPosition;
            }
        `;

        const terrainFragmentShader = `
            uniform vec3 uColorGrass;
            uniform vec3 uColorRock;
            uniform vec3 uColorSand;
            uniform vec3 uColorSnow;
            uniform float uSnowLevel;
            uniform float uSandLevel;
            uniform vec3 uSunDirection;
            uniform vec3 uSunColor;
            uniform vec3 uAmbientColor;
            uniform float uAmbientIntensity;

            varying vec3 vNormal;
            varying vec3 vPosition;
            varying float vSlope;

            float hash(vec2 p) { return fract(1e4 * sin(17.0 * p.x + p.y * 0.1) * (0.1 + abs(sin(p.y * 13.0 + p.x)))); }

            void main() {
                float h = vPosition.y;
                float diff = max(dot(vNormal, uSunDirection), 0.0);
                vec3 lighting = (uAmbientColor * uAmbientIntensity) + (uSunColor * diff * 1.2);

                vec3 col = uColorGrass;
                // Rock blending based on slope and noise
                float rockNoise = hash(vPosition.xz * 0.1);
                float rockFactor = smoothstep(0.7 + rockNoise*0.1, 0.4, vSlope);
                col = mix(col, uColorRock, rockFactor);

                // Sand blending based on height
                float sandFactor = 1.0 - smoothstep(uSandLevel, uSandLevel + 3.0, h);
                col = mix(col, uColorSand, sandFactor);

                // Snow blending based on height
                float snowHeight = uSnowLevel + (rockNoise * 5.0);
                float snowFactor = smoothstep(snowHeight, snowHeight + 10.0, h);
                snowFactor *= smoothstep(0.3, 0.6, vSlope); // Remove snow from steep cliffs
                col = mix(col, uColorSnow, snowFactor);

                gl_FragColor = vec4(col * lighting, 1.0);
            }
        `;

        const waterVertexShader = `
            uniform float uTime;
            varying vec3 vPosition;
            void main() {
                vec3 pos = position;
                // Simple sine wave displacement
                float wave = sin(pos.x * 0.1 + uTime) * 0.5 + sin(pos.z * 0.08 + uTime * 0.8) * 0.5;
                pos.y += wave;
                vec4 worldPosition = modelMatrix * vec4(pos, 1.0);
                vPosition = worldPosition.xyz;
                gl_Position = projectionMatrix * viewMatrix * worldPosition;
            }
        `;

        const waterFragmentShader = `
            uniform vec3 uColorWater;
            uniform vec3 uSunDirection;
            uniform vec3 uSunColor;
            varying vec3 vPosition;
            void main() {
                vec3 viewVector = normalize(cameraPosition - vPosition);
                vec3 normal = vec3(0.0, 1.0, 0.0);
                vec3 halfDir = normalize(uSunDirection + viewVector);
                // Specular highlight
                float spec = pow(max(dot(normal, halfDir), 0.0), 100.0);
                vec3 col = uColorWater + (uSunColor * spec);
                gl_FragColor = vec4(col, 0.85); 
            }
        `;

        // ==========================================
        // 3. LOGIC FUNCTIONS
        // ==========================================

        function createTerrainMesh() {
            if(terrainMesh) {
                scene.remove(terrainMesh);
                terrainMesh.geometry.dispose();
            }
            if (heightData.length !== (SEGMENTS+1)*(SEGMENTS+1)) {
                 heightData = new Float32Array((SEGMENTS+1)*(SEGMENTS+1)).fill(0);
            }

            const geo = new THREE.PlaneGeometry(WORLD_SIZE, WORLD_SIZE, SEGMENTS, SEGMENTS);
            geo.rotateX(-Math.PI / 2);
            
            const pos = geo.attributes.position;
            for(let i=0; i < pos.count; i++) {
                pos.setY(i, heightData[i]);
            }
            geo.computeVertexNormals();
            
            const mat = new THREE.ShaderMaterial({
                uniforms: {
                    uColorGrass: { value: state.colors.grass },
                    uColorRock: { value: state.colors.rock },
                    uColorSand: { value: state.colors.sand },
                    uColorSnow: { value: state.colors.snow },
                    uSnowLevel: { value: state.snowLevel },
                    uSandLevel: { value: state.waterLevel + 2.0 },
                    uSunDirection: { value: new THREE.Vector3(0,1,0) },
                    uSunColor: { value: new THREE.Color(0xffffff) },
                    uAmbientColor: { value: new THREE.Color(0x404040) },
                    uAmbientIntensity: { value: state.ambientIntensity }
                },
                vertexShader: terrainVertexShader,
                fragmentShader: terrainFragmentShader,
                side: THREE.DoubleSide
            });

            terrainMesh = new THREE.Mesh(geo, mat);
            terrainMesh.receiveShadow = true;
            terrainMesh.castShadow = true;
            scene.add(terrainMesh);
        }

        function createWaterMesh() {
            if(waterMesh) { scene.remove(waterMesh); waterMesh.geometry.dispose(); }
            const waterGeo = new THREE.PlaneGeometry(WORLD_SIZE, WORLD_SIZE, 64, 64);
            waterGeo.rotateX(-Math.PI/2);
            const waterMat = new THREE.ShaderMaterial({
                uniforms: {
                    uTime: { value: 0 },
                    uColorWater: { value: state.colors.water },
                    uSunDirection: { value: new THREE.Vector3(0,1,0) },
                    uSunColor: { value: new THREE.Color(0xffffff) }
                },
                vertexShader: waterVertexShader,
                fragmentShader: waterFragmentShader,
                transparent: true,
                side: THREE.DoubleSide
            });
            waterMesh = new THREE.Mesh(waterGeo, waterMat);
            waterMesh.position.y = state.waterLevel;
            scene.add(waterMesh);
        }

        function scatterVegetation() {
            if (treesMesh) { scene.remove(treesMesh); treesMesh.dispose(); }
            const count = parseInt(document.getElementById('inp-trees').value);
            if (count === 0) return;
            
            const geom = new THREE.ConeGeometry(1, 4, 8);
            geom.translate(0, 2, 0); 
            const mat = new THREE.MeshLambertMaterial({ color: 0x2d4c1e });
            treesMesh = new THREE.InstancedMesh(geom, mat, count);
            treesMesh.castShadow = true;
            treesMesh.receiveShadow = true;
            
            const dummy = new THREE.Object3D();
            const posAttr = terrainMesh.geometry.attributes.position;
            const normAttr = terrainMesh.geometry.attributes.normal;
            
            let placed = 0;
            for(let i=0; i<count * 3; i++) {
                if (placed >= count) break;
                const rx = Math.floor(Math.random() * SEGMENTS);
                const rz = Math.floor(Math.random() * SEGMENTS);
                const idx = rx + rz * (SEGMENTS + 1);
                
                const y = posAttr.getY(idx);
                const ny = normAttr.getY(idx);
                
                if (y > state.waterLevel + 1 && y < state.snowLevel - 5) {
                    if (ny > 0.8) {
                        const x = posAttr.getX(idx);
                        const z = posAttr.getZ(idx);
                        dummy.position.set(x, y, z);
                        const s = 1 + Math.random();
                        dummy.scale.set(s, s * (0.8 + Math.random()*0.4), s);
                        dummy.updateMatrix();
                        treesMesh.setMatrixAt(placed, dummy.matrix);
                        placed++;
                    }
                }
            }
            treesMesh.count = placed;
            scene.add(treesMesh);
        }
        
        function updateVegetationY() {
            if (!treesMesh) return;
            const dummy = new THREE.Object3D();
            const posAttr = terrainMesh.geometry.attributes.position;
            const matrix = new THREE.Matrix4();
            const position = new THREE.Vector3();
            for(let i=0; i<treesMesh.count; i++) {
                treesMesh.getMatrixAt(i, matrix);
                position.setFromMatrixPosition(matrix);
                
                const gx = Math.round(((position.x + WORLD_SIZE/2)/WORLD_SIZE)*SEGMENTS);
                const gz = Math.round(((position.z + WORLD_SIZE/2)/WORLD_SIZE)*SEGMENTS);
                
                if (gx >= 0 && gx <= SEGMENTS && gz >=0 && gz <= SEGMENTS) {
                    const idx = gx + gz * (SEGMENTS+1);
                    const h = posAttr.getY(idx);
                    
                    if (h < state.waterLevel) {
                         matrix.makeScale(0,0,0);
                    } else {
                        const sx = new THREE.Vector3();
                        matrix.decompose(position, new THREE.Quaternion(), sx);
                        if (sx.x < 0.1) sx.set(1.5, 1.5, 1.5); 
                        dummy.position.set(position.x, h, position.z);
                        dummy.scale.copy(sx);
                        dummy.updateMatrix();
                        treesMesh.setMatrixAt(i, dummy.matrix);
                    }
                }
            }
            treesMesh.instanceMatrix.needsUpdate = true;
        }

        function updateSunLogic() {
            sunLight.position.copy(sunSphere.position);
            const uniforms = sky.material.uniforms;
            uniforms['sunPosition'].value.copy(sunSphere.position);
            const sunDir = sunSphere.position.clone().normalize();
            terrainMesh.material.uniforms.uSunDirection.value.copy(sunDir);
            waterMesh.material.uniforms.uSunDirection.value.copy(sunDir);
            if(scene.fog) {
                if(sunSphere.position.y < 0) scene.fog.color.set(0x050510);
                else scene.fog.color.set(0xcceeff);
            }
        }

        function updateShadowCamera() {
            sunLight.shadow.camera.left = -WORLD_SIZE/2;
            sunLight.shadow.camera.right = WORLD_SIZE/2;
            sunLight.shadow.camera.top = WORLD_SIZE/2;
            sunLight.shadow.camera.bottom = -WORLD_SIZE/2;
            sunLight.shadow.camera.updateProjectionMatrix();
        }

        // ==========================================
        // 4. EVENTS
        // ==========================================

        function onPointerMove(e) {
            const rect = renderer.domElement.getBoundingClientRect();
            pointer.x = ((e.clientX - rect.left) / rect.width) * 2 - 1;
            pointer.y = -((e.clientY - rect.top) / rect.height) * 2 + 1;

            // GPS Tool
            if (state.tool === 'gps') {
                raycaster.setFromCamera(pointer, camera);
                const intersects = raycaster.intersectObject(terrainMesh);
                if (intersects.length > 0) {
                    const pt = intersects[0].point;
                    brushHelper.position.copy(pt);
                    brushHelper.position.y += 0.5;
                    brushHelper.scale.set(1,1,1);
                    brushHelper.visible = true;
                    gpsTip.style.display = 'block';
                    gpsTip.style.left = (e.clientX + 15) + 'px';
                    gpsTip.style.top = (e.clientY + 15) + 'px';
                    gpsTip.innerHTML = `X:${pt.x.toFixed(1)} Z:${pt.z.toFixed(1)} H:${pt.y.toFixed(1)}m`;
                } else {
                    gpsTip.style.display = 'none';
                    brushHelper.visible = false;
                }
                return;
            } else {
                gpsTip.style.display = 'none';
            }

            // Walk Tool (Selection Phase)
            if (state.tool === 'walk' && !isWalking) {
                raycaster.setFromCamera(pointer, camera);
                const intersects = raycaster.intersectObject(terrainMesh);
                if (intersects.length > 0) {
                    const pt = intersects[0].point;
                    brushHelper.position.copy(pt);
                    brushHelper.position.y += 0.5;
                    // Radius 1m
                    brushHelper.scale.set(1, 1, 1);
                    brushHelper.visible = true;
                } else {
                    brushHelper.visible = false;
                }
                return;
            }

            if (state.tool === 'sun' || state.tool === 'nav' || isWalking) {
                brushHelper.visible = false;
                return;
            }

            // Sculpting Tools
            raycaster.setFromCamera(pointer, camera);
            const intersects = raycaster.intersectObject(terrainMesh);
            if (intersects.length > 0) {
                const pt = intersects[0].point;
                brushHelper.position.copy(pt);
                brushHelper.position.y = Math.max(pt.y + 1, state.waterLevel + 1);
                brushHelper.scale.set(state.radius, state.radius, state.radius);
                brushHelper.visible = true;
                if (state.isDrawing) applySculpt(pt);
            } else {
                brushHelper.visible = false;
            }
        }

        function onPointerDown(e) {
            if (e.button === 0) {
                if (state.tool === 'gps' || state.tool === 'sun' || state.tool === 'nav') return;
                
                // Walk Tool Activation
                if (state.tool === 'walk' && !isWalking) {
                     raycaster.setFromCamera(pointer, camera);
                     const intersects = raycaster.intersectObject(terrainMesh);
                     if (intersects.length > 0) {
                         const pt = intersects[0].point;
                         enterWalkMode(pt);
                     }
                     return;
                }
                
                // Sculpting
                state.isDrawing = true;
                controls.enabled = false; 
                
                raycaster.setFromCamera(pointer, camera);
                const intersects = raycaster.intersectObject(terrainMesh);
                if (intersects.length > 0) {
                    const pt = intersects[0].point;
                    if (state.tool === 'flatten') state.flattenHeight = pt.y; 
                    applySculpt(pt);
                }
            }
        }

        function onPointerUp() {
            state.isDrawing = false;
            state.flattenHeight = null;
            if (state.tool !== 'sun' && !isWalking) controls.enabled = true; 
            updateVegetationY();
        }

        function applySculpt(center) {
            const posAttr = terrainMesh.geometry.attributes.position;
            const gridX = Math.floor(((center.x + WORLD_SIZE/2) / WORLD_SIZE) * SEGMENTS);
            const gridZ = Math.floor(((center.z + WORLD_SIZE/2) / WORLD_SIZE) * SEGMENTS);
            const rGrid = Math.ceil((state.radius / WORLD_SIZE) * SEGMENTS);
            
            let dirty = false;
            const startX = Math.max(0, gridX - rGrid);
            const endX = Math.min(SEGMENTS, gridX + rGrid);
            const startZ = Math.max(0, gridZ - rGrid);
            const endZ = Math.min(SEGMENTS, gridZ + rGrid);

            for (let x = startX; x <= endX; x++) {
                for (let z = startZ; z <= endZ; z++) {
                    const dx = x - gridX;
                    const dz = z - gridZ;
                    const dist = Math.sqrt(dx*dx + dz*dz);
                    
                    if (dist < rGrid) {
                        const idx = x + z * (SEGMENTS + 1);
                        const oldY = heightData[idx];
                        const factor = Math.cos((dist/rGrid) * (Math.PI/2)); 
                        let newY = oldY;
                        const delta = state.strength * factor * 0.4;

                        switch (state.tool) {
                            case 'mountain': newY += delta; break;
                            case 'valley': newY -= delta; break;
                            case 'flatten':
                                if (state.flattenHeight !== null) newY = THREE.MathUtils.lerp(oldY, state.flattenHeight, 0.1 * factor * state.strength); 
                                break;
                            case 'smooth':
                                const localAvg = (oldY + (center.y || oldY)) / 2;
                                newY = THREE.MathUtils.lerp(oldY, localAvg, 0.05 * factor);
                                break;
                        }
                        if (newY !== oldY) {
                            heightData[idx] = newY;
                            posAttr.setY(idx, newY);
                            dirty = true;
                        }
                    }
                }
            }
            if (dirty) {
                posAttr.needsUpdate = true;
                terrainMesh.geometry.computeVertexNormals();
            }
        }

        function onResize() {
            const el = document.getElementById('viewport');
            camera.aspect = el.clientWidth / el.clientHeight;
            camera.updateProjectionMatrix();
            renderer.setSize(el.clientWidth, el.clientHeight);
        }

        // ==========================================
        // 5. WALK MODE LOGIC
        // ==========================================
        
        function enterWalkMode(startPos) {
            isWalking = true;
            controls.enabled = false; // Disable orbit
            
            // Move camera to start pos
            camera.position.set(startPos.x, startPos.y + 1.75, startPos.z);
            
            // Activate pointer lock
            walkControls.lock();
            
            // UI Updates
            const btn = document.getElementById('btn-walk');
            btn.innerText = "Back to God view";
            btn.classList.add('active');
            document.getElementById('walk-help').style.display = "block";
        }
        
        function exitWalkMode() {
            isWalking = false;
            walkControls.unlock();
            
            // Move camera up
            camera.position.set(0, 100, 250);
            camera.lookAt(0,0,0);
            
            controls.enabled = true;
            
            const btn = document.getElementById('btn-walk');
            btn.innerText = "üö∂ Take a Walk";
            btn.classList.remove('active');
            document.getElementById('walk-help').style.display = "none";
        }

        // ==========================================
        // 6. ANIMATION LOOP
        // ==========================================

        function animate() {
            requestAnimationFrame(animate);
            const time = performance.now();
            const delta = (time - prevTime) / 1000;

            if (isWalking) {
                // Walk Physics
                velocity.x -= velocity.x * 10.0 * delta;
                velocity.z -= velocity.z * 10.0 * delta;

                direction.z = Number(moveForward) - Number(moveBackward);
                direction.x = Number(moveRight) - Number(moveLeft);
                direction.normalize();

                if (moveForward || moveBackward) velocity.z -= direction.z * walkSpeed * delta;
                if (moveLeft || moveRight) velocity.x -= direction.x * walkSpeed * delta;

                walkControls.moveRight(-velocity.x * delta);
                walkControls.moveForward(-velocity.z * delta);

                // Snap Height to Terrain
                heightRaycaster.set(camera.position, new THREE.Vector3(0, -1, 0));
                // Raycast from high up just to be safe in case we clipped
                const rayOrigin = camera.position.clone();
                rayOrigin.y = 500; 
                heightRaycaster.set(rayOrigin, new THREE.Vector3(0, -1, 0));
                
                const hits = heightRaycaster.intersectObject(terrainMesh);
                if (hits.length > 0) {
                    camera.position.y = hits[0].point.y + 1.75;
                }
            }

            if(transformControl.dragging) updateSunLogic();
            waterMesh.material.uniforms.uTime.value = time * 0.001;
            
            if(!isWalking) controls.update(); // Only update Orbit if not walking
            
            renderer.render(scene, camera);
            prevTime = time;
        }

        // ==========================================
        // 7. INITIALIZATION
        // ==========================================

        function init() {
            const container = document.getElementById('viewport');
            scene = new THREE.Scene();

            camera = new THREE.PerspectiveCamera(55, container.clientWidth / container.clientHeight, 1, 2000);
            camera.position.set(0, 100, 250);

            renderer = new THREE.WebGLRenderer({ antialias: true, alpha: false });
            renderer.setSize(container.clientWidth, container.clientHeight);
            renderer.shadowMap.enabled = true;
            renderer.shadowMap.type = THREE.PCFSoftShadowMap;
            renderer.toneMapping = THREE.ACESFilmicToneMapping;
            renderer.toneMappingExposure = 0.8;
            container.appendChild(renderer.domElement);

            controls = new OrbitControls(camera, renderer.domElement);
            controls.enableDamping = true;
            controls.maxPolarAngle = Math.PI / 2 - 0.02;
            controls.mouseButtons.LEFT = null;

            // Setup PointerLockControls for walking
            walkControls = new PointerLockControls(camera, document.body);
            // Listen for unlock event to handle ESC key or programmatic exit
            walkControls.addEventListener('unlock', function () {
                if(isWalking) exitWalkMode();
            });

            // WASD Listeners
            const onKeyDown = function (event) {
                switch (event.code) {
                    case 'ArrowUp':
                    case 'KeyW': moveForward = true; break;
                    case 'ArrowLeft':
                    case 'KeyA': moveLeft = true; break;
                    case 'ArrowDown':
                    case 'KeyS': moveBackward = true; break;
                    case 'ArrowRight':
                    case 'KeyD': moveRight = true; break;
                }
            };
            const onKeyUp = function (event) {
                switch (event.code) {
                    case 'ArrowUp':
                    case 'KeyW': moveForward = false; break;
                    case 'ArrowLeft':
                    case 'KeyA': moveLeft = false; break;
                    case 'ArrowDown':
                    case 'KeyS': moveBackward = false; break;
                    case 'ArrowRight':
                    case 'KeyD': moveRight = false; break;
                }
            };
            document.addEventListener('keydown', onKeyDown);
            document.addEventListener('keyup', onKeyUp);

            // Scene Objects
            scene.fog = new THREE.FogExp2(0xcceeff, 0.005);
            sky = new Sky();
            sky.scale.setScalar(450000);
            scene.add(sky);

            const sunGeo = new THREE.SphereGeometry(10, 16, 16);
            const sunMat = new THREE.MeshBasicMaterial({ color: 0xffffaa });
            sunSphere = new THREE.Mesh(sunGeo, sunMat);
            sunSphere.position.set(100, 200, 100);
            scene.add(sunSphere);

            sunLight = new THREE.DirectionalLight(0xffffff, 2.0);
            sunLight.castShadow = true;
            sunLight.shadow.mapSize.width = 2048;
            sunLight.shadow.mapSize.height = 2048;
            scene.add(sunLight);

            transformControl = new TransformControls(camera, renderer.domElement);
            transformControl.addEventListener('dragging-changed', function (event) {
                controls.enabled = !event.value;
            });
            transformControl.attach(sunSphere);
            transformControl.visible = false; 
            scene.add(transformControl);

            createTerrainMesh();
            createWaterMesh();

            // Brush
            const bGeo = new THREE.RingGeometry(0.5, 1, 32);
            bGeo.rotateX(-Math.PI/2);
            brushHelper = new THREE.Mesh(bGeo, new THREE.MeshBasicMaterial({ color: 0xff0000, transparent:true, opacity:0.5 }));
            scene.add(brushHelper);

            // Listeners
            container.addEventListener('pointermove', onPointerMove);
            container.addEventListener('pointerdown', onPointerDown);
            container.addEventListener('pointerup', onPointerUp);
            window.addEventListener('resize', onResize);

            initUI();
            updateSunLogic();
            updateShadowCamera();
            scatterVegetation();
            animate();
        }

        // ==========================================
        // 8. UI & EXPORT HANDLERS
        // ==========================================

        window.setTool = (t, el) => {
            if(isWalking) return; // Prevent tool switching while walking unless exiting
            state.tool = t;
            
            document.querySelectorAll('.tool-grid button').forEach(b => b.classList.remove('active'));
            if(el) el.classList.add('active');
            
            transformControl.visible = (t === 'sun');
            transformControl.enabled = (t === 'sun');
            
            if (t === 'gps' || t === 'sun' || t === 'nav') {
                controls.mouseButtons.LEFT = THREE.MOUSE.ROTATE;
                document.getElementById('viewport').style.cursor = "grab";
            } else if (t === 'walk') {
                controls.mouseButtons.LEFT = null; 
                document.getElementById('viewport').style.cursor = "crosshair";
            } else {
                controls.mouseButtons.LEFT = null; 
                document.getElementById('viewport').style.cursor = "default";
            }

            document.getElementById('tool-status').innerText = "Tool: " + t.toUpperCase();
            if (t !== 'gps') document.getElementById('gps-tooltip').style.display = 'none';
        };

        window.handleWalkButton = (el) => {
            if (isWalking) {
                // If clicked while walking, exit logic
                exitWalkMode();
            } else {
                // Select the tool logic
                window.setTool('walk', el);
            }
        };

        window.scatterVegetation = scatterVegetation;
        window.openExportModal = () => { document.getElementById('code-modal').style.display='flex'; window.exportSystem(); };

        window.exportSystem = function() {
            const mode = document.getElementById('export-mode').value;
            const heights = Array.from(heightData).map(x=>x.toFixed(2)).join(',');
            let output = "";

            if (mode === 'geo_only') {
                output = `import * as THREE from 'three';
export function createGeometry() {
    const geo = new THREE.PlaneGeometry(${WORLD_SIZE}, ${WORLD_SIZE}, ${SEGMENTS}, ${SEGMENTS});
    geo.rotateX(-Math.PI/2);
    const heights = [${heights}];
    const pos = geo.attributes.position;
    for(let i=0; i<pos.count; i++) pos.setY(i, heights[i]);
    geo.computeVertexNormals();
    return geo;
}`;
            } else if (mode === 'geo_parts') {
                output = `import * as THREE from 'three';
// Returns Mesh with MultiMaterial. 0=Sand, 1=Grass, 2=Rock, 3=Snow
export function createPartMesh() {
    const geo = new THREE.PlaneGeometry(${WORLD_SIZE}, ${WORLD_SIZE}, ${SEGMENTS}, ${SEGMENTS});
    geo.rotateX(-Math.PI/2);
    const heights = [${heights}];
    const pos = geo.attributes.position;
    const norm = geo.attributes.normal;
    for(let i=0; i<pos.count; i++) pos.setY(i, heights[i]);
    geo.computeVertexNormals();
    
    const snowH = ${state.snowLevel};
    const waterH = ${state.waterLevel};
    
    for(let i=0; i<geo.index.count; i+=3) {
        const a = geo.index.array[i];
        const y = pos.getY(a);
        const ny = norm.getY(a); 
        let matIndex = 1; // Grass
        if(y < waterH + 2) matIndex = 0; // Sand
        else if(ny < 0.7) matIndex = 2; // Rock
        else if(y > snowH) matIndex = 3; // Snow
        geo.addGroup(i, 3, matIndex);
    }
    
    const materials = [
        new THREE.MeshStandardMaterial({color: "${state.colors.sand.getHexString()}"}),
        new THREE.MeshStandardMaterial({color: "${state.colors.grass.getHexString()}"}),
        new THREE.MeshStandardMaterial({color: "${state.colors.rock.getHexString()}"}),
        new THREE.MeshStandardMaterial({color: "${state.colors.snow.getHexString()}"})
    ];
    return new THREE.Mesh(geo, materials);
}`;
            } else {
                const shaderPart = `
    const material = new THREE.ShaderMaterial({
        uniforms: {
            uColorGrass: { value: new THREE.Color("${state.colors.grass.getHexString()}") },
            uColorRock: { value: new THREE.Color("${state.colors.rock.getHexString()}") },
            uColorSnow: { value: new THREE.Color("${state.colors.snow.getHexString()}") },
            uColorSand: { value: new THREE.Color("${state.colors.sand.getHexString()}") },
            uSnowLevel: { value: ${state.snowLevel} },
            uSandLevel: { value: ${state.waterLevel + 2.0} },
            uSunDirection: { value: new THREE.Vector3(${sunSphere.position.x}, ${sunSphere.position.y}, ${sunSphere.position.z}).normalize() },
            uAmbientColor: { value: new THREE.Color(0x404040) },
            uAmbientIntensity: { value: ${state.ambientIntensity} },
            uSunColor: { value: new THREE.Color(0xffffff) }
        },
        vertexShader: \`${terrainVertexShader}\`,
        fragmentShader: \`${terrainFragmentShader}\`
    });`;

                output = `import * as THREE from 'three';
export function createScene() {
    const geo = new THREE.PlaneGeometry(${WORLD_SIZE}, ${WORLD_SIZE}, ${SEGMENTS}, ${SEGMENTS});
    geo.rotateX(-Math.PI/2);
    const heights = [${heights}];
    const pos = geo.attributes.position;
    for(let i=0; i<pos.count; i++) pos.setY(i, heights[i]);
    geo.computeVertexNormals();
    ${shaderPart}
    const mesh = new THREE.Mesh(geo, material);
    ${mode === 'full' ? `
    const wGeo = new THREE.PlaneGeometry(${WORLD_SIZE}, ${WORLD_SIZE}, 64, 64);
    wGeo.rotateX(-Math.PI/2);
    const wMat = new THREE.ShaderMaterial({
        uniforms: {
            uTime: { value: 0 },
            uColorWater: { value: new THREE.Color("${state.colors.water.getHexString()}") },
            uSunDirection: { value: new THREE.Vector3(0,1,0) },
            uSunColor: { value: new THREE.Color(0xffffff) }
        },
        vertexShader: \`${waterVertexShader}\`,
        fragmentShader: \`${waterFragmentShader}\`,
        transparent: true
    });
    const water = new THREE.Mesh(wGeo, wMat);
    water.position.y = ${state.waterLevel};
    return { terrain: mesh, water: water };` : `return mesh;`}
}`;
            }
            document.getElementById('code-output').value = output.trim();
        };

        function initUI() {
            const bindVal = (id, suffix, cb) => {
                const el = document.getElementById(id);
                el.addEventListener('input', e => {
                    const v = e.target.value;
                    const dispId = id.replace('inp','val').replace('sh','val');
                    const disp = document.getElementById(dispId);
                    if(disp) disp.innerText = v + suffix;
                    if(cb) cb(parseFloat(v));
                });
            };

            bindVal('inp-size', 'm', (v) => { WORLD_SIZE = v; createTerrainMesh(); createWaterMesh(); updateShadowCamera(); scatterVegetation(); });
            bindVal('inp-res', '', (v) => { SEGMENTS = v; createTerrainMesh(); scatterVegetation(); });
            bindVal('inp-radius', '', (v) => state.radius = v);
            bindVal('inp-str', '', (v) => state.strength = v);
            bindVal('inp-ambient', '', (v) => { state.ambientIntensity = v; terrainMesh.material.uniforms.uAmbientIntensity.value = v; });
            bindVal('inp-water', 'm', (v) => { state.waterLevel = v; waterMesh.position.y = v; terrainMesh.material.uniforms.uSandLevel.value = v+2.0; updateVegetationY(); });
            bindVal('inp-fog', '', (v) => scene.fog.density = v);
            bindVal('sh-snow-h', 'm', (v) => { state.snowLevel = v; terrainMesh.material.uniforms.uSnowLevel.value = v; });

            const bindColor = (id, u) => {
                 document.getElementById(id).addEventListener('input', e => terrainMesh.material.uniforms[u].value.set(e.target.value));
            };
            bindColor('col-grass', 'uColorGrass');
            bindColor('col-rock', 'uColorRock');
            bindColor('col-sand', 'uColorSand');
            document.getElementById('col-water').addEventListener('input', e => waterMesh.material.uniforms.uColorWater.value.set(e.target.value));
            document.getElementById('inp-trees').addEventListener('change', scatterVegetation);
        }

        init();
    </script>
</body>
</html>