<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Abstract Luminous Tornado</title>
    <style>
        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
        }
        
        body {
            overflow: hidden;
            background: #000;
            font-family: 'Segoe UI', Tahoma, Geneva, Verdana, sans-serif;
        }
        
        #canvas-container {
            width: 100vw;
            height: 100vh;
            position: relative;
        }
        
        #controls {
            position: absolute;
            top: 20px;
            right: 20px;
            background: rgba(0, 0, 0, 0.85);
            padding: 20px;
            border-radius: 10px;
            color: #fff;
            max-width: 320px;
            max-height: 90vh;
            overflow-y: auto;
            backdrop-filter: blur(10px);
            border: 1px solid rgba(255, 255, 255, 0.1);
            box-shadow: 0 8px 32px rgba(0, 0, 0, 0.5);
        }
        
        #controls::-webkit-scrollbar {
            width: 8px;
        }
        
        #controls::-webkit-scrollbar-track {
            background: rgba(255, 255, 255, 0.05);
            border-radius: 4px;
        }
        
        #controls::-webkit-scrollbar-thumb {
            background: rgba(255, 255, 255, 0.2);
            border-radius: 4px;
        }
        
        h2 {
            margin-bottom: 15px;
            font-size: 18px;
            color: #ffa500;
            text-transform: uppercase;
            letter-spacing: 1px;
        }
        
        .control-group {
            margin-bottom: 20px;
            padding-bottom: 15px;
            border-bottom: 1px solid rgba(255, 255, 255, 0.1);
        }
        
        .control-group:last-child {
            border-bottom: none;
        }
        
        label {
            display: block;
            margin-bottom: 5px;
            font-size: 12px;
            color: #aaa;
            text-transform: uppercase;
            letter-spacing: 0.5px;
        }
        
        input[type="range"] {
            width: 100%;
            margin-bottom: 10px;
            height: 6px;
            border-radius: 3px;
            background: rgba(255, 255, 255, 0.1);
            outline: none;
            -webkit-appearance: none;
        }
        
        input[type="range"]::-webkit-slider-thumb {
            -webkit-appearance: none;
            appearance: none;
            width: 16px;
            height: 16px;
            border-radius: 50%;
            background: #ffa500;
            cursor: pointer;
            box-shadow: 0 0 10px rgba(255, 165, 0, 0.5);
        }
        
        input[type="range"]::-moz-range-thumb {
            width: 16px;
            height: 16px;
            border-radius: 50%;
            background: #ffa500;
            cursor: pointer;
            box-shadow: 0 0 10px rgba(255, 165, 0, 0.5);
            border: none;
        }
        
        input[type="color"] {
            width: 100%;
            height: 35px;
            border: none;
            border-radius: 5px;
            cursor: pointer;
            background: transparent;
        }
        
        .value-display {
            display: inline-block;
            float: right;
            color: #ffa500;
            font-weight: bold;
            font-size: 12px;
        }
        
        button {
            width: 100%;
            padding: 10px;
            margin-top: 10px;
            background: linear-gradient(135deg, #ff6b00, #ffa500);
            border: none;
            border-radius: 5px;
            color: white;
            font-weight: bold;
            cursor: pointer;
            text-transform: uppercase;
            letter-spacing: 1px;
            transition: all 0.3s;
        }
        
        button:hover {
            transform: translateY(-2px);
            box-shadow: 0 5px 20px rgba(255, 165, 0, 0.4);
        }
        
        button:active {
            transform: translateY(0);
        }
        
        .section-title {
            font-size: 14px;
            color: #fff;
            margin-bottom: 10px;
            font-weight: bold;
        }
    </style>
</head>
<body>
    <div id="canvas-container"></div>
    
    <div id="controls">
        <h2>üå™Ô∏è Tornado Controls</h2>
        
        <div class="control-group">
            <div class="section-title">Physical Parameters</div>
            
            <label>Height <span class="value-display" id="heightValue">1.6m</span></label>
            <input type="range" id="height" min="0.5" max="5" step="0.1" value="1.6">
            
            <label>Base Radius <span class="value-display" id="baseRadiusValue">0.10</span></label>
            <input type="range" id="baseRadius" min="0.1" max="1" step="0.01" value="0.10">
            
            <label>Top Radius <span class="value-display" id="topRadiusValue">0.78</span></label>
            <input type="range" id="topRadius" min="0.3" max="2" step="0.01" value="0.78">
            
            <label>Twist Amount <span class="value-display" id="twistValue">3.1</span></label>
            <input type="range" id="twist" min="1" max="20" step="0.1" value="3.1">
        </div>
        
        <div class="control-group">
            <div class="section-title">Thread Parameters</div>
            
            <label>Thread Count <span class="value-display" id="threadCountValue">21</span></label>
            <input type="range" id="threadCount" min="10" max="100" step="1" value="21">
            
            <label>Thread Segments <span class="value-display" id="segmentsValue">50</span></label>
            <input type="range" id="segments" min="50" max="300" step="10" value="50">
            
            <label>Thread Thickness <span class="value-display" id="thicknessValue">8.0</span></label>
            <input type="range" id="thickness" min="0.5" max="8" step="0.1" value="8.0">
            
            <label>Thread Opacity <span class="value-display" id="opacityValue">1.00</span></label>
            <input type="range" id="opacity" min="0.1" max="1" step="0.05" value="1.0">
        </div>
        
        <div class="control-group">
            <div class="section-title">Animation & Dynamics</div>
            
            <label>Rotation Speed <span class="value-display" id="rotationSpeedValue">0.0</span></label>
            <input type="range" id="rotationSpeed" min="0" max="5" step="0.1" value="0.0">
            
            <label>Flow Speed <span class="value-display" id="flowSpeedValue">0.3</span></label>
            <input type="range" id="flowSpeed" min="0" max="3" step="0.1" value="0.3">
            
            <label>Turbulence <span class="value-display" id="turbulenceValue">0.02</span></label>
            <input type="range" id="turbulence" min="0" max="1" step="0.01" value="0.02">
            
            <label>Pulse Intensity <span class="value-display" id="pulseValue">0.3</span></label>
            <input type="range" id="pulse" min="0" max="1" step="0.05" value="0.3">
            
            <label>Cap Animation <span class="value-display" id="capAnimationValue">Animated</span></label>
            <input type="range" id="capAnimation" min="0" max="1" step="1" value="1">
        </div>
        
        <div class="control-group">
            <div class="section-title">Colors</div>
            
            <label>Core Color</label>
            <input type="color" id="coreColor" value="#ff6600">
            
            <label>Mid Color</label>
            <input type="color" id="midColor" value="#ffaa00">
            
            <label>Outer Color</label>
            <input type="color" id="outerColor" value="#00ccff">
        </div>
        
        <div class="control-group">
            <div class="section-title">Environment</div>
            
            <label>Ambient Light <span class="value-display" id="ambientValue">0.2</span></label>
            <input type="range" id="ambient" min="0" max="1" step="0.05" value="0.2">
            
            <label>Bloom Strength <span class="value-display" id="bloomValue">1.5</span></label>
            <input type="range" id="bloom" min="0" max="3" step="0.1" value="1.5">
            
            <label>Camera Distance <span class="value-display" id="cameraDistanceValue">4.0</span></label>
            <input type="range" id="cameraDistance" min="2" max="10" step="0.1" value="4">
        </div>
        
        <button id="reset">Reset to Default</button>
    </div>

    <script src="https://cdnjs.cloudflare.com/ajax/libs/three.js/r128/three.min.js"></script>
    <script src="https://cdn.jsdelivr.net/npm/three@0.128.0/examples/js/controls/OrbitControls.js"></script>
    <script src="https://cdn.jsdelivr.net/npm/three@0.128.0/examples/js/shaders/CopyShader.js"></script>
    <script src="https://cdn.jsdelivr.net/npm/three@0.128.0/examples/js/shaders/LuminosityHighPassShader.js"></script>
    <script src="https://cdn.jsdelivr.net/npm/three@0.128.0/examples/js/postprocessing/Pass.js"></script>
    <script src="https://cdn.jsdelivr.net/npm/three@0.128.0/examples/js/postprocessing/ShaderPass.js"></script>
    <script src="https://cdn.jsdelivr.net/npm/three@0.128.0/examples/js/postprocessing/EffectComposer.js"></script>
    <script src="https://cdn.jsdelivr.net/npm/three@0.128.0/examples/js/postprocessing/RenderPass.js"></script>
    <script src="https://cdn.jsdelivr.net/npm/three@0.128.0/examples/js/postprocessing/UnrealBloomPass.js"></script>
    
    <script>
        // Scene setup
        const container = document.getElementById('canvas-container');
        const scene = new THREE.Scene();
        const camera = new THREE.PerspectiveCamera(75, window.innerWidth / window.innerHeight, 0.1, 1000);
        const renderer = new THREE.WebGLRenderer({ antialias: true, alpha: true });
        
        renderer.setSize(window.innerWidth, window.innerHeight);
        renderer.setPixelRatio(window.devicePixelRatio);
        container.appendChild(renderer.domElement);
        
        // Camera position - inside tornado at base of hemisphere cap
        const capStartRatio = 0.7;
        const capStartY = capStartRatio * 1.6 - 1.6 / 2;
        camera.position.set(0, capStartY, 0);
        
        // Drag to look controls
        let isDragging = false;
        let previousMouseX = 0;
        let previousMouseY = 0;
        let rotationX = 0;
        let rotationY = 0;
        
        document.addEventListener('mousedown', (event) => {
            isDragging = true;
            previousMouseX = event.clientX;
            previousMouseY = event.clientY;
        });
        
        document.addEventListener('mouseup', () => {
            isDragging = false;
        });
        
        document.addEventListener('mousemove', (event) => {
            if (!isDragging) return;
            
            const deltaX = event.clientX - previousMouseX;
            const deltaY = event.clientY - previousMouseY;
            
            previousMouseX = event.clientX;
            previousMouseY = event.clientY;
            
            rotationY += deltaX * 0.005; // Left/right rotation
            rotationX += deltaY * 0.005; // Up/down rotation
            
            // Clamp vertical rotation to avoid flipping
            rotationX = Math.max(-Math.PI / 2, Math.min(Math.PI / 2, rotationX));
        });
        
        // WASD movement controls
        const keys = {};
        const moveSpeed = 0.05;
        
        document.addEventListener('keydown', (event) => {
            keys[event.key.toLowerCase()] = true;
        });
        
        document.addEventListener('keyup', (event) => {
            keys[event.key.toLowerCase()] = false;
        });
        
        function updateMovement() {
            const forward = new THREE.Vector3();
            const right = new THREE.Vector3();
            
            // Get forward and right vectors based on camera rotation (horizontal only)
            forward.set(-Math.sin(rotationY), 0, -Math.cos(rotationY));
            right.set(Math.cos(rotationY), 0, -Math.sin(rotationY));
            
            if (keys['w']) {
                camera.position.x += forward.x * moveSpeed;
                camera.position.z += forward.z * moveSpeed;
            }
            if (keys['s']) {
                camera.position.x -= forward.x * moveSpeed;
                camera.position.z -= forward.z * moveSpeed;
            }
            if (keys['a']) {
                camera.position.x -= right.x * moveSpeed;
                camera.position.z -= right.z * moveSpeed;
            }
            if (keys['d']) {
                camera.position.x += right.x * moveSpeed;
                camera.position.z += right.z * moveSpeed;
            }
        }
        
        // Lighting
        let ambientLight = new THREE.AmbientLight(0xffffff, 0.2);
        scene.add(ambientLight);
        
        // Tornado parameters
        let params = {
            height: 1.6,
            baseRadius: 0.10,
            topRadius: 0.78,
            twist: 3.1,
            threadCount: 21,
            segments: 50,
            thickness: 8.0,
            opacity: 1.0,
            rotationSpeed: 0.0,
            flowSpeed: 0.3,
            turbulence: 0.02,
            pulse: 0.3,
            capAnimation: 1,
            coreColor: new THREE.Color(0xff6600),
            midColor: new THREE.Color(0xffaa00),
            outerColor: new THREE.Color(0x00ccff),
            ambient: 0.2,
            bloom: 1.5,
            cameraDistance: 4.0
        };
        
        // Tornado group
        let tornadoGroup = new THREE.Group();
        scene.add(tornadoGroup);
        
        // Thread lines
        let threads = [];
        
        // Animation time
        let time = 0;
        
        // Create tornado threads
        function createTornado() {
            // Clear existing threads
            threads.forEach(thread => {
                tornadoGroup.remove(thread);
                thread.geometry.dispose();
                thread.material.dispose();
            });
            threads = [];
            
            for (let i = 0; i < params.threadCount; i++) {
                const angle = (i / params.threadCount) * Math.PI * 2;
                const points = [];
                
                // Calculate how many segments for the main tornado body vs hemisphere cap
                const capStartRatio = 0.7; // Cap starts at 70% height
                const bodySegments = Math.floor(params.segments * capStartRatio);
                const capSegments = params.segments - bodySegments;
                
                // Main tornado body
                for (let j = 0; j <= bodySegments; j++) {
                    const t = j / params.segments;
                    const y = t * params.height - params.height / 2;
                    const radius = params.baseRadius + (params.topRadius - params.baseRadius) * t;
                    
                    // Add spiral twist
                    const spiralAngle = angle + t * params.twist;
                    
                    // Add some randomness for organic feel
                    const noise = Math.sin(i * 0.5 + j * 0.1) * 0.05;
                    const radiusWithNoise = radius * (1 + noise);
                    
                    const x = Math.cos(spiralAngle) * radiusWithNoise;
                    const z = Math.sin(spiralAngle) * radiusWithNoise;
                    
                    points.push(new THREE.Vector3(x, y, z));
                }
                
                // Hemisphere cap
                // Ensure neck stays open by starting from the top radius (not closing)
                const capStartT = bodySegments / params.segments;
                const capStartY = capStartT * params.height - params.height / 2;
                const neckRadius = params.baseRadius + (params.topRadius - params.baseRadius) * capStartT;
                
                for (let j = 1; j <= capSegments; j++) {
                    const capT = j / capSegments;
                    // Use asin to create hemisphere that starts at neckRadius and curves inward
                    const phi = Math.asin(capT); // 0 to œÄ/2, maps more area at base
                    
                    // Radius decreases from neckRadius to 0 at top, but keeps neck open
                    const localRadius = neckRadius * Math.cos(phi);
                    const y = capStartY + neckRadius * Math.sin(phi);
                    
                    // Continue the spiral into the cap
                    const t = (bodySegments + j) / params.segments;
                    const spiralAngle = angle + t * params.twist;
                    
                    const noise = Math.sin(i * 0.5 + (bodySegments + j) * 0.1) * 0.05;
                    const radiusWithNoise = localRadius * (1 + noise);
                    
                    const x = Math.cos(spiralAngle) * radiusWithNoise;
                    const z = Math.sin(spiralAngle) * radiusWithNoise;
                    
                    points.push(new THREE.Vector3(x, y, z));
                }
                
                const geometry = new THREE.BufferGeometry().setFromPoints(points);
                
                // Color gradient based on height
                const colors = [];
                for (let j = 0; j <= params.segments; j++) {
                    const t = j / params.segments;
                    let color;
                    
                    if (t < 0.3) {
                        color = params.coreColor.clone().lerp(params.midColor, t / 0.3);
                    } else if (t < 0.7) {
                        color = params.midColor.clone().lerp(params.outerColor, (t - 0.3) / 0.4);
                    } else {
                        color = params.outerColor.clone();
                    }
                    
                    colors.push(color.r, color.g, color.b);
                }
                
                geometry.setAttribute('color', new THREE.Float32BufferAttribute(colors, 3));
                
                const material = new THREE.LineBasicMaterial({
                    vertexColors: true,
                    transparent: true,
                    opacity: params.opacity,
                    linewidth: params.thickness,
                    blending: THREE.AdditiveBlending
                });
                
                const line = new THREE.Line(geometry, material);
                threads.push(line);
                tornadoGroup.add(line);
            }
        }
        
        // Update thread animation
        function updateThreads(deltaTime) {
            threads.forEach((thread, threadIdx) => {
                const positions = thread.geometry.attributes.position.array;
                const colors = thread.geometry.attributes.color.array;
                
                const capStartRatio = 0.7;
                const bodySegments = Math.floor(params.segments * capStartRatio);
                const capSegments = params.segments - bodySegments;
                const capStartT = bodySegments / params.segments;
                const capStartY = capStartT * params.height - params.height / 2;
                const neckRadius = params.baseRadius + (params.topRadius - params.baseRadius) * capStartT;
                
                for (let i = 0; i <= params.segments; i++) {
                    const idx = i * 3;
                    const t = i / params.segments;
                    
                    // Base angle for this thread
                    const baseAngle = (threadIdx / params.threadCount) * Math.PI * 2;
                    
                    if (i <= bodySegments) {
                        // Main tornado body
                        const y = t * params.height - params.height / 2;
                        const radius = params.baseRadius + (params.topRadius - params.baseRadius) * t;
                        
                        // Add upward flow animation to the spiral angle
                        const spiralAngle = baseAngle + t * params.twist - time * params.flowSpeed;
                        const rotationAngle = spiralAngle + time * params.rotationSpeed;
                        
                        // Add turbulence
                        const turbulence = Math.sin(time * 3 + threadIdx + i * 0.1) * params.turbulence;
                        const radiusWithTurb = radius * (1 + turbulence);
                        
                        // Add pulse effect
                        const pulse = 1 + Math.sin(time * 2 - t * Math.PI) * params.pulse * 0.2;
                        
                        const x = Math.cos(rotationAngle) * radiusWithTurb * pulse;
                        const z = Math.sin(rotationAngle) * radiusWithTurb * pulse;
                        
                        positions[idx] = x;
                        positions[idx + 1] = y;
                        positions[idx + 2] = z;
                    } else {
                        // Hemisphere cap
                        const capIdx = i - bodySegments;
                        const capT = capIdx / capSegments;
                        const phi = Math.asin(capT);
                        
                        const localRadius = neckRadius * Math.cos(phi);
                        const y = capStartY + neckRadius * Math.sin(phi);
                        
                        // Cap animation control: 0 = fixed, 1 = animated
                        let spiralAngle = baseAngle + t * params.twist;
                        let rotationAngle = spiralAngle;
                        
                        if (params.capAnimation === 1) {
                            spiralAngle = baseAngle + t * params.twist - time * params.flowSpeed;
                            rotationAngle = spiralAngle + time * params.rotationSpeed;
                        }
                        
                        // Add turbulence
                        const turbulence = Math.sin(time * 3 + threadIdx + i * 0.1) * params.turbulence;
                        const radiusWithTurb = localRadius * (1 + turbulence * params.capAnimation);
                        
                        // Add pulse effect (reduced for cap)
                        const pulse = 1 + Math.sin(time * 2 - t * Math.PI) * params.pulse * 0.1 * params.capAnimation;
                        
                        const x = Math.cos(rotationAngle) * radiusWithTurb * pulse;
                        const z = Math.sin(rotationAngle) * radiusWithTurb * pulse;
                        
                        positions[idx] = x;
                        positions[idx + 1] = y;
                        positions[idx + 2] = z;
                    }
                }
                
                thread.geometry.attributes.position.needsUpdate = true;
            });
        }
        
        // Post-processing (Bloom effect)
        const composer = new THREE.EffectComposer(renderer);
        const renderPass = new THREE.RenderPass(scene, camera);
        composer.addPass(renderPass);
        
        const bloomPass = new THREE.UnrealBloomPass(
            new THREE.Vector2(window.innerWidth, window.innerHeight),
            params.bloom,
            0.4,
            0.85
        );
        composer.addPass(bloomPass);
        
        // Initialize
        createTornado();
        
        // Animation loop
        function animate() {
            requestAnimationFrame(animate);
            
            const deltaTime = 0.016; // Approximately 60fps
            time += deltaTime * params.flowSpeed;
            
            updateThreads(deltaTime);
            updateMovement();
            
            // Update camera rotation based on drag
            camera.rotation.order = 'YXZ';
            camera.rotation.y = rotationY;
            camera.rotation.x = rotationX;
            
            composer.render();
        }
        
        animate();
        
        // Control handlers
        function updateDisplay(id, value, suffix = '') {
            document.getElementById(id + 'Value').textContent = value + suffix;
        }
        
        document.getElementById('height').addEventListener('input', (e) => {
            params.height = parseFloat(e.target.value);
            updateDisplay('height', params.height.toFixed(1), 'm');
            createTornado();
        });
        
        document.getElementById('baseRadius').addEventListener('input', (e) => {
            params.baseRadius = parseFloat(e.target.value);
            updateDisplay('baseRadius', params.baseRadius.toFixed(2));
            createTornado();
        });
        
        document.getElementById('topRadius').addEventListener('input', (e) => {
            params.topRadius = parseFloat(e.target.value);
            updateDisplay('topRadius', params.topRadius.toFixed(2));
            createTornado();
        });
        
        document.getElementById('twist').addEventListener('input', (e) => {
            params.twist = parseFloat(e.target.value);
            updateDisplay('twist', params.twist.toFixed(1));
            createTornado();
        });
        
        document.getElementById('threadCount').addEventListener('input', (e) => {
            params.threadCount = parseInt(e.target.value);
            updateDisplay('threadCount', params.threadCount);
            createTornado();
        });
        
        document.getElementById('segments').addEventListener('input', (e) => {
            params.segments = parseInt(e.target.value);
            updateDisplay('segments', params.segments);
            createTornado();
        });
        
        document.getElementById('thickness').addEventListener('input', (e) => {
            params.thickness = parseFloat(e.target.value);
            updateDisplay('thickness', params.thickness.toFixed(1));
            threads.forEach(thread => thread.material.linewidth = params.thickness);
        });
        
        document.getElementById('opacity').addEventListener('input', (e) => {
            params.opacity = parseFloat(e.target.value);
            updateDisplay('opacity', params.opacity.toFixed(2));
            threads.forEach(thread => thread.material.opacity = params.opacity);
        });
        
        document.getElementById('rotationSpeed').addEventListener('input', (e) => {
            params.rotationSpeed = parseFloat(e.target.value);
            updateDisplay('rotationSpeed', params.rotationSpeed.toFixed(1));
        });
        
        document.getElementById('flowSpeed').addEventListener('input', (e) => {
            params.flowSpeed = parseFloat(e.target.value);
            updateDisplay('flowSpeed', params.flowSpeed.toFixed(1));
        });
        
        document.getElementById('turbulence').addEventListener('input', (e) => {
            params.turbulence = parseFloat(e.target.value);
            updateDisplay('turbulence', params.turbulence.toFixed(2));
        });
        
        document.getElementById('pulse').addEventListener('input', (e) => {
            params.pulse = parseFloat(e.target.value);
            updateDisplay('pulse', params.pulse.toFixed(2));
        });
        
        document.getElementById('capAnimation').addEventListener('input', (e) => {
            params.capAnimation = parseInt(e.target.value);
            updateDisplay('capAnimation', params.capAnimation === 0 ? 'Fixed' : 'Animated', '');
        });
        
        document.getElementById('coreColor').addEventListener('input', (e) => {
            params.coreColor.set(e.target.value);
            createTornado();
        });
        
        document.getElementById('midColor').addEventListener('input', (e) => {
            params.midColor.set(e.target.value);
            createTornado();
        });
        
        document.getElementById('outerColor').addEventListener('input', (e) => {
            params.outerColor.set(e.target.value);
            createTornado();
        });
        
        document.getElementById('ambient').addEventListener('input', (e) => {
            params.ambient = parseFloat(e.target.value);
            updateDisplay('ambient', params.ambient.toFixed(2));
            ambientLight.intensity = params.ambient;
        });
        
        document.getElementById('bloom').addEventListener('input', (e) => {
            params.bloom = parseFloat(e.target.value);
            updateDisplay('bloom', params.bloom.toFixed(1));
            bloomPass.strength = params.bloom;
        });
        
        document.getElementById('cameraDistance').addEventListener('input', (e) => {
            params.cameraDistance = parseFloat(e.target.value);
            updateDisplay('cameraDistance', params.cameraDistance.toFixed(1));
            const direction = camera.position.clone().normalize();
            camera.position.copy(direction.multiplyScalar(params.cameraDistance));
        });
        
        // Reset button
        document.getElementById('reset').addEventListener('click', () => {
            document.getElementById('height').value = 1.6;
            document.getElementById('baseRadius').value = 0.10;
            document.getElementById('topRadius').value = 0.78;
            document.getElementById('twist').value = 3.1;
            document.getElementById('threadCount').value = 21;
            document.getElementById('segments').value = 50;
            document.getElementById('thickness').value = 8.0;
            document.getElementById('opacity').value = 1.0;
            document.getElementById('rotationSpeed').value = 0.0;
            document.getElementById('flowSpeed').value = 0.3;
            document.getElementById('turbulence').value = 0.02;
            document.getElementById('pulse').value = 0.3;
            document.getElementById('capAnimation').value = 1;
            document.getElementById('coreColor').value = '#ff6600';
            document.getElementById('midColor').value = '#ffaa00';
            document.getElementById('outerColor').value = '#00ccff';
            document.getElementById('ambient').value = 0.2;
            document.getElementById('bloom').value = 1.5;
            document.getElementById('cameraDistance').value = 4.0;
            
            params = {
                height: 1.6,
                baseRadius: 0.10,
                topRadius: 0.78,
                twist: 3.1,
                threadCount: 21,
                segments: 50,
                thickness: 8.0,
                opacity: 1.0,
                rotationSpeed: 0.0,
                flowSpeed: 0.3,
                turbulence: 0.02,
                pulse: 0.3,
                capAnimation: 1,
                coreColor: new THREE.Color(0xff6600),
                midColor: new THREE.Color(0xffaa00),
                outerColor: new THREE.Color(0x00ccff),
                ambient: 0.2,
                bloom: 1.5,
                cameraDistance: 4.0
            };
            
            ambientLight.intensity = params.ambient;
            bloomPass.strength = params.bloom;
            
            // Reset camera to inside position
            const capStartRatio = 0.7;
            const capStartY = capStartRatio * params.height - params.height / 2;
            camera.position.set(0, capStartY, 0);
            rotationX = 0;
            rotationY = 0;
            camera.rotation.set(0, 0, 0);
            
            // Update all displays
            updateDisplay('height', params.height.toFixed(1), 'm');
            updateDisplay('baseRadius', params.baseRadius.toFixed(2));
            updateDisplay('topRadius', params.topRadius.toFixed(2));
            updateDisplay('twist', params.twist.toFixed(1));
            updateDisplay('threadCount', params.threadCount);
            updateDisplay('segments', params.segments);
            updateDisplay('thickness', params.thickness.toFixed(1));
            updateDisplay('opacity', params.opacity.toFixed(2));
            updateDisplay('rotationSpeed', params.rotationSpeed.toFixed(1));
            updateDisplay('flowSpeed', params.flowSpeed.toFixed(1));
            updateDisplay('turbulence', params.turbulence.toFixed(2));
            updateDisplay('pulse', params.pulse.toFixed(2));
            updateDisplay('capAnimation', params.capAnimation === 0 ? 'Fixed' : 'Animated', '');
            updateDisplay('ambient', params.ambient.toFixed(2));
            updateDisplay('bloom', params.bloom.toFixed(1));
            updateDisplay('cameraDistance', params.cameraDistance.toFixed(1));
            
            createTornado();
        });
        
        // Handle window resize
        window.addEventListener('resize', () => {
            camera.aspect = window.innerWidth / window.innerHeight;
            camera.updateProjectionMatrix();
            renderer.setSize(window.innerWidth, window.innerHeight);
            composer.setSize(window.innerWidth, window.innerHeight);
        });
    </script>
</body>
</html>
