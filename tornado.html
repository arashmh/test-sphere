<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Abstract Luminous Tornado</title>
    <style>
        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
        }
        
        body {
            overflow: hidden;
            background: #000;
            font-family: 'Segoe UI', Tahoma, Geneva, Verdana, sans-serif;
        }
        
        #canvas-container {
            width: 100vw;
            height: 100vh;
            position: relative;
        }
        
        #controls {
            position: absolute;
            top: 20px;
            right: 20px;
            background: rgba(0, 0, 0, 0.85);
            padding: 20px;
            border-radius: 10px;
            color: #fff;
            max-width: 320px;
            max-height: 90vh;
            overflow-y: auto;
            backdrop-filter: blur(10px);
            border: 1px solid rgba(255, 255, 255, 0.1);
            box-shadow: 0 8px 32px rgba(0, 0, 0, 0.5);
        }
        
        #controls::-webkit-scrollbar {
            width: 8px;
        }
        
        #controls::-webkit-scrollbar-track {
            background: rgba(255, 255, 255, 0.05);
            border-radius: 4px;
        }
        
        #controls::-webkit-scrollbar-thumb {
            background: rgba(255, 255, 255, 0.2);
            border-radius: 4px;
        }
        
        h2 {
            margin-bottom: 15px;
            font-size: 18px;
            color: #ffa500;
            text-transform: uppercase;
            letter-spacing: 1px;
        }
        
        .control-group {
            margin-bottom: 20px;
            padding-bottom: 15px;
            border-bottom: 1px solid rgba(255, 255, 255, 0.1);
        }
        
        .control-group:last-child {
            border-bottom: none;
        }
        
        label {
            display: block;
            margin-bottom: 5px;
            font-size: 12px;
            color: #aaa;
            text-transform: uppercase;
            letter-spacing: 0.5px;
        }
        
        input[type="range"] {
            width: 100%;
            margin-bottom: 10px;
            height: 6px;
            border-radius: 3px;
            background: rgba(255, 255, 255, 0.1);
            outline: none;
            -webkit-appearance: none;
        }
        
        input[type="range"]::-webkit-slider-thumb {
            -webkit-appearance: none;
            appearance: none;
            width: 16px;
            height: 16px;
            border-radius: 50%;
            background: #ffa500;
            cursor: pointer;
            box-shadow: 0 0 10px rgba(255, 165, 0, 0.5);
        }
        
        input[type="range"]::-moz-range-thumb {
            width: 16px;
            height: 16px;
            border-radius: 50%;
            background: #ffa500;
            cursor: pointer;
            box-shadow: 0 0 10px rgba(255, 165, 0, 0.5);
            border: none;
        }
        
        input[type="color"] {
            width: 100%;
            height: 35px;
            border: none;
            border-radius: 5px;
            cursor: pointer;
            background: transparent;
        }
        
        .value-display {
            display: inline-block;
            float: right;
            color: #ffa500;
            font-weight: bold;
            font-size: 12px;
        }
        
        button {
            width: 100%;
            padding: 10px;
            margin-top: 10px;
            background: linear-gradient(135deg, #ff6b00, #ffa500);
            border: none;
            border-radius: 5px;
            color: white;
            font-weight: bold;
            cursor: pointer;
            text-transform: uppercase;
            letter-spacing: 1px;
            transition: all 0.3s;
        }
        
        button:hover {
            transform: translateY(-2px);
            box-shadow: 0 5px 20px rgba(255, 165, 0, 0.4);
        }
        
        button:active {
            transform: translateY(0);
        }
        
        .section-title {
            font-size: 14px;
            color: #fff;
            margin-bottom: 10px;
            font-weight: bold;
        }
    </style>
</head>
<body>
    <div id="canvas-container"></div>
    
    <div id="controls">
        <h2>üå™Ô∏è Tornado Controls</h2>
        
        <div class="control-group">
            <div class="section-title">Physical Parameters</div>
            
            <label>Height <span class="value-display" id="heightValue">2.0m</span></label>
            <input type="range" id="height" min="0.5" max="5" step="0.1" value="2">
            
            <label>Base Radius <span class="value-display" id="baseRadiusValue">0.3</span></label>
            <input type="range" id="baseRadius" min="0.1" max="1" step="0.01" value="0.3">
            
            <label>Top Radius <span class="value-display" id="topRadiusValue">0.8</span></label>
            <input type="range" id="topRadius" min="0.3" max="2" step="0.01" value="0.8">
            
            <label>Twist Amount <span class="value-display" id="twistValue">8.0</span></label>
            <input type="range" id="twist" min="1" max="20" step="0.1" value="8">
        </div>
        
        <div class="control-group">
            <div class="section-title">Thread Parameters</div>
            
            <label>Thread Count <span class="value-display" id="threadCountValue">30</span></label>
            <input type="range" id="threadCount" min="10" max="100" step="1" value="30">
            
            <label>Thread Segments <span class="value-display" id="segmentsValue">100</span></label>
            <input type="range" id="segments" min="50" max="300" step="10" value="100">
            
            <label>Thread Thickness <span class="value-display" id="thicknessValue">2.0</span></label>
            <input type="range" id="thickness" min="0.5" max="8" step="0.1" value="2">
            
            <label>Thread Opacity <span class="value-display" id="opacityValue">0.7</span></label>
            <input type="range" id="opacity" min="0.1" max="1" step="0.05" value="0.7">
        </div>
        
        <div class="control-group">
            <div class="section-title">Animation & Dynamics</div>
            
            <label>Rotation Speed <span class="value-display" id="rotationSpeedValue">1.0</span></label>
            <input type="range" id="rotationSpeed" min="0" max="5" step="0.1" value="1">
            
            <label>Flow Speed <span class="value-display" id="flowSpeedValue">0.5</span></label>
            <input type="range" id="flowSpeed" min="0" max="3" step="0.1" value="0.5">
            
            <label>Turbulence <span class="value-display" id="turbulenceValue">0.15</span></label>
            <input type="range" id="turbulence" min="0" max="1" step="0.01" value="0.15">
            
            <label>Pulse Intensity <span class="value-display" id="pulseValue">0.3</span></label>
            <input type="range" id="pulse" min="0" max="1" step="0.05" value="0.3">
        </div>
        
        <div class="control-group">
            <div class="section-title">Particle Lights</div>
            
            <label>Particle Count <span class="value-display" id="particleCountValue">500</span></label>
            <input type="range" id="particleCount" min="100" max="2000" step="50" value="500">
            
            <label>Particle Size <span class="value-display" id="particleSizeValue">0.02</span></label>
            <input type="range" id="particleSize" min="0.005" max="0.05" step="0.005" value="0.02">
            
            <label>Particle Speed <span class="value-display" id="particleSpeedValue">0.8</span></label>
            <input type="range" id="particleSpeed" min="0.1" max="2" step="0.1" value="0.8">
            
            <label>Light Intensity <span class="value-display" id="lightIntensityValue">1.5</span></label>
            <input type="range" id="lightIntensity" min="0.5" max="3" step="0.1" value="1.5">
        </div>
        
        <div class="control-group">
            <div class="section-title">Colors</div>
            
            <label>Core Color</label>
            <input type="color" id="coreColor" value="#ff6600">
            
            <label>Mid Color</label>
            <input type="color" id="midColor" value="#ffaa00">
            
            <label>Outer Color</label>
            <input type="color" id="outerColor" value="#00ccff">
            
            <label>Particle Color</label>
            <input type="color" id="particleColor" value="#ffaa00">
        </div>
        
        <div class="control-group">
            <div class="section-title">Environment</div>
            
            <label>Ambient Light <span class="value-display" id="ambientValue">0.2</span></label>
            <input type="range" id="ambient" min="0" max="1" step="0.05" value="0.2">
            
            <label>Bloom Strength <span class="value-display" id="bloomValue">1.5</span></label>
            <input type="range" id="bloom" min="0" max="3" step="0.1" value="1.5">
            
            <label>Camera Distance <span class="value-display" id="cameraDistanceValue">4.0</span></label>
            <input type="range" id="cameraDistance" min="2" max="10" step="0.1" value="4">
        </div>
        
        <button id="reset">Reset to Default</button>
    </div>

    <script src="https://cdnjs.cloudflare.com/ajax/libs/three.js/r128/three.min.js"></script>
    <script src="https://cdn.jsdelivr.net/npm/three@0.128.0/examples/js/controls/OrbitControls.js"></script>
    <script src="https://cdn.jsdelivr.net/npm/three@0.128.0/examples/js/shaders/CopyShader.js"></script>
    <script src="https://cdn.jsdelivr.net/npm/three@0.128.0/examples/js/shaders/LuminosityHighPassShader.js"></script>
    <script src="https://cdn.jsdelivr.net/npm/three@0.128.0/examples/js/postprocessing/Pass.js"></script>
    <script src="https://cdn.jsdelivr.net/npm/three@0.128.0/examples/js/postprocessing/ShaderPass.js"></script>
    <script src="https://cdn.jsdelivr.net/npm/three@0.128.0/examples/js/postprocessing/EffectComposer.js"></script>
    <script src="https://cdn.jsdelivr.net/npm/three@0.128.0/examples/js/postprocessing/RenderPass.js"></script>
    <script src="https://cdn.jsdelivr.net/npm/three@0.128.0/examples/js/postprocessing/UnrealBloomPass.js"></script>
    
    <script>
        // Scene setup
        const container = document.getElementById('canvas-container');
        const scene = new THREE.Scene();
        const camera = new THREE.PerspectiveCamera(75, window.innerWidth / window.innerHeight, 0.1, 1000);
        const renderer = new THREE.WebGLRenderer({ antialias: true, alpha: true });
        
        renderer.setSize(window.innerWidth, window.innerHeight);
        renderer.setPixelRatio(window.devicePixelRatio);
        container.appendChild(renderer.domElement);
        
        // Camera position
        camera.position.set(0, 1, 4);
        
        // Orbit controls
        const controls = new THREE.OrbitControls(camera, renderer.domElement);
        controls.enableDamping = true;
        controls.dampingFactor = 0.05;
        controls.minDistance = 2;
        controls.maxDistance = 10;
        
        // Lighting
        let ambientLight = new THREE.AmbientLight(0xffffff, 0.2);
        scene.add(ambientLight);
        
        // Tornado parameters
        let params = {
            height: 2.0,
            baseRadius: 0.3,
            topRadius: 0.8,
            twist: 8.0,
            threadCount: 30,
            segments: 100,
            thickness: 2.0,
            opacity: 0.7,
            rotationSpeed: 1.0,
            flowSpeed: 0.5,
            turbulence: 0.15,
            pulse: 0.3,
            particleCount: 500,
            particleSize: 0.02,
            particleSpeed: 0.8,
            lightIntensity: 1.5,
            coreColor: new THREE.Color(0xff6600),
            midColor: new THREE.Color(0xffaa00),
            outerColor: new THREE.Color(0x00ccff),
            particleColor: new THREE.Color(0xffaa00),
            ambient: 0.2,
            bloom: 1.5,
            cameraDistance: 4.0
        };
        
        // Tornado group
        let tornadoGroup = new THREE.Group();
        scene.add(tornadoGroup);
        
        // Thread lines
        let threads = [];
        let particles = null;
        let particleVelocities = [];
        
        // Animation time
        let time = 0;
        
        // Create tornado threads
        function createTornado() {
            // Clear existing threads
            threads.forEach(thread => {
                tornadoGroup.remove(thread);
                thread.geometry.dispose();
                thread.material.dispose();
            });
            threads = [];
            
            for (let i = 0; i < params.threadCount; i++) {
                const angle = (i / params.threadCount) * Math.PI * 2;
                const points = [];
                
                for (let j = 0; j <= params.segments; j++) {
                    const t = j / params.segments;
                    const y = t * params.height - params.height / 2;
                    const radius = params.baseRadius + (params.topRadius - params.baseRadius) * t;
                    
                    // Add spiral twist
                    const spiralAngle = angle + t * params.twist;
                    
                    // Add some randomness for organic feel
                    const noise = Math.sin(i * 0.5 + j * 0.1) * 0.05;
                    const radiusWithNoise = radius * (1 + noise);
                    
                    const x = Math.cos(spiralAngle) * radiusWithNoise;
                    const z = Math.sin(spiralAngle) * radiusWithNoise;
                    
                    points.push(new THREE.Vector3(x, y, z));
                }
                
                const geometry = new THREE.BufferGeometry().setFromPoints(points);
                
                // Color gradient based on height
                const colors = [];
                for (let j = 0; j <= params.segments; j++) {
                    const t = j / params.segments;
                    let color;
                    
                    if (t < 0.3) {
                        color = params.coreColor.clone().lerp(params.midColor, t / 0.3);
                    } else if (t < 0.7) {
                        color = params.midColor.clone().lerp(params.outerColor, (t - 0.3) / 0.4);
                    } else {
                        color = params.outerColor.clone();
                    }
                    
                    colors.push(color.r, color.g, color.b);
                }
                
                geometry.setAttribute('color', new THREE.Float32BufferAttribute(colors, 3));
                
                const material = new THREE.LineBasicMaterial({
                    vertexColors: true,
                    transparent: true,
                    opacity: params.opacity,
                    linewidth: params.thickness,
                    blending: THREE.AdditiveBlending
                });
                
                const line = new THREE.Line(geometry, material);
                threads.push(line);
                tornadoGroup.add(line);
            }
        }
        
        // Create particles
        function createParticles() {
            if (particles) {
                tornadoGroup.remove(particles);
                particles.geometry.dispose();
                particles.material.dispose();
            }
            
            const geometry = new THREE.BufferGeometry();
            const positions = [];
            const colors = [];
            const sizes = [];
            particleVelocities = [];
            
            for (let i = 0; i < params.particleCount; i++) {
                const t = Math.random();
                const angle = Math.random() * Math.PI * 2;
                const radius = params.baseRadius + (params.topRadius - params.baseRadius) * t;
                const radiusVariation = radius * (0.5 + Math.random() * 0.5);
                
                const y = t * params.height - params.height / 2;
                const x = Math.cos(angle) * radiusVariation;
                const z = Math.sin(angle) * radiusVariation;
                
                positions.push(x, y, z);
                
                // Color variation
                const color = params.particleColor.clone();
                const brightness = 0.5 + Math.random() * 0.5;
                color.multiplyScalar(brightness);
                colors.push(color.r, color.g, color.b);
                
                // Size variation
                sizes.push(params.particleSize * (0.5 + Math.random() * 1.5));
                
                // Velocity
                particleVelocities.push({
                    angle: angle,
                    speed: 0.5 + Math.random() * 0.5,
                    offset: Math.random() * Math.PI * 2
                });
            }
            
            geometry.setAttribute('position', new THREE.Float32BufferAttribute(positions, 3));
            geometry.setAttribute('color', new THREE.Float32BufferAttribute(colors, 3));
            geometry.setAttribute('size', new THREE.Float32BufferAttribute(sizes, 1));
            
            const material = new THREE.ShaderMaterial({
                uniforms: {
                    intensity: { value: params.lightIntensity }
                },
                vertexShader: `
                    attribute float size;
                    attribute vec3 color;
                    varying vec3 vColor;
                    
                    void main() {
                        vColor = color;
                        vec4 mvPosition = modelViewMatrix * vec4(position, 1.0);
                        gl_PointSize = size * 300.0 / -mvPosition.z;
                        gl_Position = projectionMatrix * mvPosition;
                    }
                `,
                fragmentShader: `
                    uniform float intensity;
                    varying vec3 vColor;
                    
                    void main() {
                        float dist = length(gl_PointCoord - vec2(0.5));
                        if (dist > 0.5) discard;
                        
                        float alpha = 1.0 - (dist * 2.0);
                        alpha = pow(alpha, 2.0);
                        
                        vec3 glowColor = vColor * intensity;
                        gl_FragColor = vec4(glowColor, alpha);
                    }
                `,
                transparent: true,
                blending: THREE.AdditiveBlending,
                depthWrite: false
            });
            
            particles = new THREE.Points(geometry, material);
            tornadoGroup.add(particles);
        }
        
        // Update particle animation
        function updateParticles(deltaTime) {
            if (!particles) return;
            
            const positions = particles.geometry.attributes.position.array;
            
            for (let i = 0; i < params.particleCount; i++) {
                const idx = i * 3;
                const vel = particleVelocities[i];
                
                // Get current position
                let y = positions[idx + 1];
                
                // Move upward
                y += params.particleSpeed * deltaTime * vel.speed * 0.5;
                
                // Reset to bottom when reaching top
                if (y > params.height / 2) {
                    y = -params.height / 2;
                }
                
                // Calculate position based on height
                const t = (y + params.height / 2) / params.height;
                const radius = params.baseRadius + (params.topRadius - params.baseRadius) * t;
                
                // Spiral motion
                vel.angle += params.rotationSpeed * deltaTime * 0.5;
                const spiralAngle = vel.angle + t * params.twist;
                
                // Add turbulence
                const turbX = Math.sin(time * 2 + vel.offset) * params.turbulence;
                const turbZ = Math.cos(time * 2 + vel.offset + 1) * params.turbulence;
                
                const radiusWithVariation = radius * (0.3 + Math.random() * 0.7);
                const x = Math.cos(spiralAngle) * radiusWithVariation + turbX;
                const z = Math.sin(spiralAngle) * radiusWithVariation + turbZ;
                
                positions[idx] = x;
                positions[idx + 1] = y;
                positions[idx + 2] = z;
            }
            
            particles.geometry.attributes.position.needsUpdate = true;
        }
        
        // Update thread animation
        function updateThreads(deltaTime) {
            threads.forEach((thread, threadIdx) => {
                const positions = thread.geometry.attributes.position.array;
                
                for (let i = 0; i <= params.segments; i++) {
                    const idx = i * 3;
                    const t = i / params.segments;
                    const y = t * params.height - params.height / 2;
                    const radius = params.baseRadius + (params.topRadius - params.baseRadius) * t;
                    
                    // Base angle for this thread
                    const baseAngle = (threadIdx / params.threadCount) * Math.PI * 2;
                    const spiralAngle = baseAngle + t * params.twist + time * params.rotationSpeed;
                    
                    // Add turbulence
                    const turbulence = Math.sin(time * 3 + threadIdx + i * 0.1) * params.turbulence;
                    const radiusWithTurb = radius * (1 + turbulence);
                    
                    // Add pulse effect
                    const pulse = 1 + Math.sin(time * 2 - t * Math.PI) * params.pulse * 0.2;
                    
                    const x = Math.cos(spiralAngle) * radiusWithTurb * pulse;
                    const z = Math.sin(spiralAngle) * radiusWithTurb * pulse;
                    
                    positions[idx] = x;
                    positions[idx + 1] = y;
                    positions[idx + 2] = z;
                }
                
                thread.geometry.attributes.position.needsUpdate = true;
            });
        }
        
        // Post-processing (Bloom effect)
        const composer = new THREE.EffectComposer(renderer);
        const renderPass = new THREE.RenderPass(scene, camera);
        composer.addPass(renderPass);
        
        const bloomPass = new THREE.UnrealBloomPass(
            new THREE.Vector2(window.innerWidth, window.innerHeight),
            params.bloom,
            0.4,
            0.85
        );
        composer.addPass(bloomPass);
        
        // Initialize
        createTornado();
        createParticles();
        
        // Animation loop
        function animate() {
            requestAnimationFrame(animate);
            
            const deltaTime = 0.016; // Approximately 60fps
            time += deltaTime * params.flowSpeed;
            
            updateThreads(deltaTime);
            updateParticles(deltaTime);
            
            controls.update();
            composer.render();
        }
        
        animate();
        
        // Control handlers
        function updateDisplay(id, value, suffix = '') {
            document.getElementById(id + 'Value').textContent = value + suffix;
        }
        
        document.getElementById('height').addEventListener('input', (e) => {
            params.height = parseFloat(e.target.value);
            updateDisplay('height', params.height.toFixed(1), 'm');
            createTornado();
            createParticles();
        });
        
        document.getElementById('baseRadius').addEventListener('input', (e) => {
            params.baseRadius = parseFloat(e.target.value);
            updateDisplay('baseRadius', params.baseRadius.toFixed(2));
            createTornado();
            createParticles();
        });
        
        document.getElementById('topRadius').addEventListener('input', (e) => {
            params.topRadius = parseFloat(e.target.value);
            updateDisplay('topRadius', params.topRadius.toFixed(2));
            createTornado();
            createParticles();
        });
        
        document.getElementById('twist').addEventListener('input', (e) => {
            params.twist = parseFloat(e.target.value);
            updateDisplay('twist', params.twist.toFixed(1));
            createTornado();
        });
        
        document.getElementById('threadCount').addEventListener('input', (e) => {
            params.threadCount = parseInt(e.target.value);
            updateDisplay('threadCount', params.threadCount);
            createTornado();
        });
        
        document.getElementById('segments').addEventListener('input', (e) => {
            params.segments = parseInt(e.target.value);
            updateDisplay('segments', params.segments);
            createTornado();
        });
        
        document.getElementById('thickness').addEventListener('input', (e) => {
            params.thickness = parseFloat(e.target.value);
            updateDisplay('thickness', params.thickness.toFixed(1));
            threads.forEach(thread => thread.material.linewidth = params.thickness);
        });
        
        document.getElementById('opacity').addEventListener('input', (e) => {
            params.opacity = parseFloat(e.target.value);
            updateDisplay('opacity', params.opacity.toFixed(2));
            threads.forEach(thread => thread.material.opacity = params.opacity);
        });
        
        document.getElementById('rotationSpeed').addEventListener('input', (e) => {
            params.rotationSpeed = parseFloat(e.target.value);
            updateDisplay('rotationSpeed', params.rotationSpeed.toFixed(1));
        });
        
        document.getElementById('flowSpeed').addEventListener('input', (e) => {
            params.flowSpeed = parseFloat(e.target.value);
            updateDisplay('flowSpeed', params.flowSpeed.toFixed(1));
        });
        
        document.getElementById('turbulence').addEventListener('input', (e) => {
            params.turbulence = parseFloat(e.target.value);
            updateDisplay('turbulence', params.turbulence.toFixed(2));
        });
        
        document.getElementById('pulse').addEventListener('input', (e) => {
            params.pulse = parseFloat(e.target.value);
            updateDisplay('pulse', params.pulse.toFixed(2));
        });
        
        document.getElementById('particleCount').addEventListener('input', (e) => {
            params.particleCount = parseInt(e.target.value);
            updateDisplay('particleCount', params.particleCount);
            createParticles();
        });
        
        document.getElementById('particleSize').addEventListener('input', (e) => {
            params.particleSize = parseFloat(e.target.value);
            updateDisplay('particleSize', params.particleSize.toFixed(3));
            createParticles();
        });
        
        document.getElementById('particleSpeed').addEventListener('input', (e) => {
            params.particleSpeed = parseFloat(e.target.value);
            updateDisplay('particleSpeed', params.particleSpeed.toFixed(1));
        });
        
        document.getElementById('lightIntensity').addEventListener('input', (e) => {
            params.lightIntensity = parseFloat(e.target.value);
            updateDisplay('lightIntensity', params.lightIntensity.toFixed(1));
            if (particles) {
                particles.material.uniforms.intensity.value = params.lightIntensity;
            }
        });
        
        document.getElementById('coreColor').addEventListener('input', (e) => {
            params.coreColor.set(e.target.value);
            createTornado();
        });
        
        document.getElementById('midColor').addEventListener('input', (e) => {
            params.midColor.set(e.target.value);
            createTornado();
        });
        
        document.getElementById('outerColor').addEventListener('input', (e) => {
            params.outerColor.set(e.target.value);
            createTornado();
        });
        
        document.getElementById('particleColor').addEventListener('input', (e) => {
            params.particleColor.set(e.target.value);
            createParticles();
        });
        
        document.getElementById('ambient').addEventListener('input', (e) => {
            params.ambient = parseFloat(e.target.value);
            updateDisplay('ambient', params.ambient.toFixed(2));
            ambientLight.intensity = params.ambient;
        });
        
        document.getElementById('bloom').addEventListener('input', (e) => {
            params.bloom = parseFloat(e.target.value);
            updateDisplay('bloom', params.bloom.toFixed(1));
            bloomPass.strength = params.bloom;
        });
        
        document.getElementById('cameraDistance').addEventListener('input', (e) => {
            params.cameraDistance = parseFloat(e.target.value);
            updateDisplay('cameraDistance', params.cameraDistance.toFixed(1));
            const direction = camera.position.clone().normalize();
            camera.position.copy(direction.multiplyScalar(params.cameraDistance));
        });
        
        // Reset button
        document.getElementById('reset').addEventListener('click', () => {
            document.getElementById('height').value = 2.0;
            document.getElementById('baseRadius').value = 0.3;
            document.getElementById('topRadius').value = 0.8;
            document.getElementById('twist').value = 8.0;
            document.getElementById('threadCount').value = 30;
            document.getElementById('segments').value = 100;
            document.getElementById('thickness').value = 2.0;
            document.getElementById('opacity').value = 0.7;
            document.getElementById('rotationSpeed').value = 1.0;
            document.getElementById('flowSpeed').value = 0.5;
            document.getElementById('turbulence').value = 0.15;
            document.getElementById('pulse').value = 0.3;
            document.getElementById('particleCount').value = 500;
            document.getElementById('particleSize').value = 0.02;
            document.getElementById('particleSpeed').value = 0.8;
            document.getElementById('lightIntensity').value = 1.5;
            document.getElementById('coreColor').value = '#ff6600';
            document.getElementById('midColor').value = '#ffaa00';
            document.getElementById('outerColor').value = '#00ccff';
            document.getElementById('particleColor').value = '#ffaa00';
            document.getElementById('ambient').value = 0.2;
            document.getElementById('bloom').value = 1.5;
            document.getElementById('cameraDistance').value = 4.0;
            
            params = {
                height: 2.0,
                baseRadius: 0.3,
                topRadius: 0.8,
                twist: 8.0,
                threadCount: 30,
                segments: 100,
                thickness: 2.0,
                opacity: 0.7,
                rotationSpeed: 1.0,
                flowSpeed: 0.5,
                turbulence: 0.15,
                pulse: 0.3,
                particleCount: 500,
                particleSize: 0.02,
                particleSpeed: 0.8,
                lightIntensity: 1.5,
                coreColor: new THREE.Color(0xff6600),
                midColor: new THREE.Color(0xffaa00),
                outerColor: new THREE.Color(0x00ccff),
                particleColor: new THREE.Color(0xffaa00),
                ambient: 0.2,
                bloom: 1.5,
                cameraDistance: 4.0
            };
            
            ambientLight.intensity = params.ambient;
            bloomPass.strength = params.bloom;
            camera.position.set(0, 1, 4);
            
            // Update all displays
            updateDisplay('height', params.height.toFixed(1), 'm');
            updateDisplay('baseRadius', params.baseRadius.toFixed(2));
            updateDisplay('topRadius', params.topRadius.toFixed(2));
            updateDisplay('twist', params.twist.toFixed(1));
            updateDisplay('threadCount', params.threadCount);
            updateDisplay('segments', params.segments);
            updateDisplay('thickness', params.thickness.toFixed(1));
            updateDisplay('opacity', params.opacity.toFixed(2));
            updateDisplay('rotationSpeed', params.rotationSpeed.toFixed(1));
            updateDisplay('flowSpeed', params.flowSpeed.toFixed(1));
            updateDisplay('turbulence', params.turbulence.toFixed(2));
            updateDisplay('pulse', params.pulse.toFixed(2));
            updateDisplay('particleCount', params.particleCount);
            updateDisplay('particleSize', params.particleSize.toFixed(3));
            updateDisplay('particleSpeed', params.particleSpeed.toFixed(1));
            updateDisplay('lightIntensity', params.lightIntensity.toFixed(1));
            updateDisplay('ambient', params.ambient.toFixed(2));
            updateDisplay('bloom', params.bloom.toFixed(1));
            updateDisplay('cameraDistance', params.cameraDistance.toFixed(1));
            
            createTornado();
            createParticles();
        });
        
        // Handle window resize
        window.addEventListener('resize', () => {
            camera.aspect = window.innerWidth / window.innerHeight;
            camera.updateProjectionMatrix();
            renderer.setSize(window.innerWidth, window.innerHeight);
            composer.setSize(window.innerWidth, window.innerHeight);
        });
    </script>
</body>
</html>
