<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8">
    <title>A-Frame Swarm: Dynamic Pressure Audio</title>
    <script src="https://aframe.io/releases/1.7.0/aframe.min.js"></script>
    <style>
      body { margin: 0; overflow: hidden; font-family: 'Segoe UI', sans-serif; user-select: none; }
      
      #ui-container {
        position: absolute; bottom: 30px; left: 50%; transform: translateX(-50%);
        z-index: 100; display: flex; flex-direction: column; align-items: center;
        gap: 15px; background: rgba(0, 0, 0, 0.85); padding: 20px;
        border-radius: 24px; backdrop-filter: blur(12px);
        border: 1px solid rgba(255, 255, 255, 0.15);
        box-shadow: 0 10px 30px rgba(0,0,0,0.6); max-width: 95vw;
      }

      #btn-row { display: flex; gap: 10px; }

      button {
        background: rgba(255, 255, 255, 0.05); border: 1px solid rgba(255, 255, 255, 0.2);
        color: #ddd; padding: 10px 20px; font-size: 13px; text-transform: uppercase;
        letter-spacing: 1px; cursor: pointer; border-radius: 12px; transition: all 0.2s ease;
        outline: none; font-weight: 700;
      }
      button:hover { background: rgba(255, 255, 255, 0.2); transform: translateY(-2px); }

      button#btn-attack.active { background: #ff4757; border-color: #ff4757; color: white; box-shadow: 0 0 20px rgba(255, 71, 87, 0.5); }
      button#btn-pressure.active { background: #ffa502; border-color: #ffa502; color: white; box-shadow: 0 0 20px rgba(255, 165, 2, 0.5); }
      button#btn-push.active { background: #bdc3c7; border-color: #bdc3c7; color: #333; box-shadow: 0 0 20px rgba(189, 195, 199, 0.5); }
      button#btn-chill.active { background: #2ed573; border-color: #2ed573; color: white; box-shadow: 0 0 20px rgba(46, 213, 115, 0.5); }

      .slider-row { width: 100%; display: flex; flex-direction: row; gap: 25px; min-width: 300px; }
      
      .slider-container { 
        display: flex; flex-direction: column; gap: 8px; flex: 1; 
        color: rgba(255,255,255,0.9); font-size: 11px; text-transform: uppercase; font-weight: 600; 
      }
      
      .label-row { display: flex; justify-content: space-between; width: 100%; }
      .val-display { color: #00eaff; font-family: monospace; font-size: 12px; }
      
      input[type=range] { -webkit-appearance: none; width: 100%; background: transparent; }
      input[type=range]::-webkit-slider-thumb { -webkit-appearance: none; height: 14px; width: 14px; border-radius: 50%; background: #ffffff; cursor: pointer; margin-top: -5px; box-shadow: 0 0 8px rgba(255,255,255,0.8); }
      input[type=range]::-webkit-slider-runnable-track { width: 100%; height: 4px; cursor: pointer; background: rgba(255,255,255,0.2); border-radius: 2px; }

      #audio-debug {
        position: absolute; top: 10px; right: 10px; background: rgba(0,0,0,0.7);
        color: #0f0; font-family: monospace; font-size: 11px; padding: 8px;
        border-radius: 4px; display: none;
      }
    </style>
  </head>
  <body>

    <div id="audio-debug">
      Density: <span id="pressure-load">0%</span> | 
      Force: <span id="debug-force">0.1</span>
    </div>

    <div id="ui-container">
      <div id="btn-row">
        <button id="btn-attack" onclick="setMode('attack')">Attack</button>
        <button id="btn-pressure" onclick="setMode('pressure')">Pressure</button>
        <button id="btn-push" onclick="setMode('pushback')">Push Back</button>
        <button id="btn-chill" class="active" onclick="setMode('chill')">Chill</button>
      </div>
      
      <div class="slider-row">
        <div class="slider-container">
          <div class="label-row">
            <span>Swarm Force</span>
            <span id="val-force" class="val-display">0.10</span>
          </div>
          <input type="range" id="intensitySlider" min="0.01" max="1.5" step="0.01" value="0.1">
        </div>
        <div class="slider-container">
          <div class="label-row">
            <span>Master Vol</span>
            <span id="val-vol" class="val-display">30%</span>
          </div>
          <input type="range" id="volumeSlider" min="0.0" max="1.0" step="0.05" value="0.30">
        </div>
      </div>
      
      <div style="width: 100%; display: flex; justify-content: space-between; align-items: center; gap: 15px; margin-top: 5px; padding-top: 15px; border-top: 1px solid rgba(255,255,255,0.1);">
        <button onclick="cycleFenceDesign(-1)" style="padding: 8px 16px;">◀ Prev Fence</button>
        <div style="flex: 1; text-align: center; color: rgba(255,255,255,0.9); font-size: 11px; text-transform: uppercase; font-weight: 600;">
          <div id="fence-name" style="color: #00eaff; font-size: 13px; margin-bottom: 3px;">Simple Wire</div>
          <div id="fence-id" style="color: rgba(255,255,255,0.5); font-size: 10px;">Design 1/7</div>
        </div>
        <button onclick="cycleFenceDesign(1)" style="padding: 8px 16px;">Next Fence ▶</button>
      </div>
    </div>

    <a-scene stats background="color: #050508" renderer="antialias: true; colorManagement: true; sortObjects: true;" xr-mode-ui>
      
      <a-entity light="type: ambient; intensity: 0.3; color: #ffffff"></a-entity>
      <a-entity light="type: point; intensity: 1.2; distance: 10; decay: 2; color: #00eaff" position="0 0 0"></a-entity>
      <a-entity light="type: directional; intensity: 0.5; position: 2 4 3"></a-entity>

      <a-entity id="safe-sphere-container" position="0 0 0" ambient-breathing fence-manager>
        <a-sphere id="safe-core" radius="1.5" segments-width="64" segments-height="64" material="color: #00a8ff; opacity: 0.12; transparent: true; roughness: 0.1; metalness: 0.0; side: double; blending: additive; depthWrite: false"></a-sphere>
        <a-sphere id="safe-wire" radius="1.51" segments-width="24" segments-height="16" material="color: #48dbfb; wireframe: true; opacity: 0.2; transparent: true; side: double; depthWrite: false"></a-sphere>
      </a-entity>

      <a-entity id="swarm-controller" swarm-logic></a-entity>
      <a-entity id="pool-container"></a-entity>

      <a-entity id="rig" movement-controls position="0.5 0 0">
  <a-entity id="camera" camera look-controls="fly: true"  wasd-controls="acceleration:15"  position="0 0 0"></a-entity>

  <!-- Left controller -->
  <a-entity id="leftHand"
            hand-controls="hand: left; handModelStyle: lowPoly; color: #FF0000">
  </a-entity>

  <!-- Right controller -->
  <a-entity id="rightHand"
            hand-controls="hand: right; handModelStyle: lowPoly; color: #0000FF">
  </a-entity>
</a-entity>

    </a-scene>

    <script>
      /**
       * FENCE DESIGN SYSTEM - Custom Shaders & Geometries
       */
      
      const FENCE_DESIGNS = [
        { id: 0, name: 'Simple Wire' },
        { id: 1, name: 'Nested Harmonic Shells' },
        { id: 2, name: 'Veil Lattice Aurora' },
        { id: 3, name: 'Petal Arc Bloom' },
        { id: 4, name: 'Fractal Mesh Dissolve' },
        { id: 5, name: 'Halo Bead Filigree' },
        { id: 6, name: 'Connected Bead Network' }
      ];
      
      let currentFenceIndex = 0;
      
      function cycleFenceDesign(direction) {
        currentFenceIndex = (currentFenceIndex + direction + FENCE_DESIGNS.length) % FENCE_DESIGNS.length;
        const design = FENCE_DESIGNS[currentFenceIndex];
        document.getElementById('fence-name').innerText = design.name;
        document.getElementById('fence-id').innerText = `Design ${design.id + 1}/7`;
        
        const fenceManager = document.querySelector('[fence-manager]');
        if (fenceManager && fenceManager.components['fence-manager']) {
          fenceManager.components['fence-manager'].switchToDesign(currentFenceIndex);
        }
      }
      
      /**
       * FENCE MANAGER COMPONENT
       */
      AFRAME.registerComponent('fence-manager', {
        init: function() {
          this.currentDesign = 0;
          this.fenceObjects = [];
          this.originalWire = this.el.querySelector('#safe-wire');
          
          // Create all fence designs
          this.createAllDesigns();
          this.switchToDesign(0);
        },
        
        createAllDesigns: function() {
          // Design 1: Nested Harmonic Shells
          this.fenceObjects[1] = this.createNestedShells();
          
          // Design 2: Veil Lattice with Aurora
          this.fenceObjects[2] = this.createVeilLattice();
          
          // Design 3: Petal Arc Bloom
          this.fenceObjects[3] = this.createPetalBloom();
          
          // Design 4: Fractal Mesh Dissolve
          this.fenceObjects[4] = this.createFractalMesh();
          
          // Design 5: Halo Bead Filigree
          this.fenceObjects[5] = this.createHaloBeads();
          
          // Design 6: Connected Bead Network
          this.fenceObjects[6] = this.createConnectedBeads();
        },
        
        switchToDesign: function(index) {
          this.currentDesign = index;
          
          // Hide all
          if (this.originalWire) this.originalWire.object3D.visible = (index === 0);
          for (let i = 1; i < this.fenceObjects.length; i++) {
            if (this.fenceObjects[i]) {
              this.fenceObjects[i].visible = (i === index);
            }
          }
        },
        
        /**
         * DESIGN 1: NESTED HARMONIC SHELLS
         */
        createNestedShells: function() {
          const group = new THREE.Group();
          const radii = [1.48, 1.51, 1.54];
          const colors = [
            new THREE.Color('#7ff9ff'),
            new THREE.Color('#33c7ff'),
            new THREE.Color('#c9ffff')
          ];
          const phases = [0, 4000, 8000];
          
          radii.forEach((radius, idx) => {
            const geometry = new THREE.IcosahedronGeometry(radius, 2);
            const material = new THREE.ShaderMaterial({
              uniforms: {
                time: { value: 0 },
                color1: { value: colors[idx] },
                color2: { value: colors[idx].clone().multiplyScalar(0.7) },
                phase: { value: phases[idx] },
                baseOpacity: { value: 0.15 + idx * 0.05 }
              },
              vertexShader: `
                varying vec3 vPosition;
                varying vec3 vNormal;
                void main() {
                  vPosition = position;
                  vNormal = normalize(normalMatrix * normal);
                  gl_Position = projectionMatrix * modelViewMatrix * vec4(position, 1.0);
                }
              `,
              fragmentShader: `
                uniform float time;
                uniform vec3 color1;
                uniform vec3 color2;
                uniform float phase;
                uniform float baseOpacity;
                varying vec3 vPosition;
                varying vec3 vNormal;
                
                void main() {
                  float dist = length(vPosition);
                  float latFade = abs(vPosition.y / dist);
                  float alpha = baseOpacity * (1.0 - latFade * 0.15);
                  
                  vec3 color = mix(color2, color1, latFade);
                  
                  // Emissive glow
                  float glow = 0.3 + 0.2 * sin(time * 0.0005 + phase * 0.001);
                  
                  gl_FragColor = vec4(color * (1.0 + glow), alpha);
                }
              `,
              transparent: true,
              side: THREE.DoubleSide,
              wireframe: true,
              depthWrite: false,
              blending: THREE.AdditiveBlending
            });
            
            const mesh = new THREE.LineSegments(
              new THREE.EdgesGeometry(geometry),
              material
            );
            mesh.userData.phaseOffset = phases[idx];
            mesh.userData.isShell = true;
            group.add(mesh);
          });
          
          this.el.object3D.add(group);
          return group;
        },
        
        /**
         * DESIGN 2: VEIL LATTICE WITH AURORA RIBBONS
         */
        createVeilLattice: function() {
          const group = new THREE.Group();
          const radius = 1.51;
          
          // Sparse lattice
          const latticeGeo = new THREE.BufferGeometry();
          const latticePoints = [];
          const segments = 24;
          
          // Meridians (every 3rd)
          for (let lng = 0; lng < 360; lng += 45) {
            for (let lat = -90; lat <= 90; lat += 5) {
              const phi = (90 - lat) * Math.PI / 180;
              const theta = lng * Math.PI / 180;
              latticePoints.push(
                radius * Math.sin(phi) * Math.cos(theta),
                radius * Math.cos(phi),
                radius * Math.sin(phi) * Math.sin(theta)
              );
            }
          }
          
          // Parallels (smoothed)
          for (let lat = -60; lat <= 60; lat += 30) {
            for (let lng = 0; lng <= 360; lng += 5) {
              const phi = (90 - lat) * Math.PI / 180;
              const theta = lng * Math.PI / 180;
              latticePoints.push(
                radius * Math.sin(phi) * Math.cos(theta),
                radius * Math.cos(phi),
                radius * Math.sin(phi) * Math.sin(theta)
              );
            }
          }
          
          latticeGeo.setAttribute('position', new THREE.Float32BufferAttribute(latticePoints, 3));
          const latticeMat = new THREE.LineBasicMaterial({
            color: '#d6fff6',
            transparent: true,
            opacity: 0.25,
            blending: THREE.AdditiveBlending
          });
          const latticeLines = new THREE.LineSegments(latticeGeo, latticeMat);
          group.add(latticeLines);
          
          // Aurora ribbons
          const goldenRatio = 1.618033988749;
          const ribbonLats = [];
          for (let i = 0; i < 5; i++) {
            ribbonLats.push(-60 + (i * goldenRatio * 30) % 120);
          }
          
          ribbonLats.forEach((lat, idx) => {
            const ribbonGeo = new THREE.BufferGeometry();
            const ribbonPoints = [];
            const ribbonColors = [];
            
            for (let lng = 0; lng <= 360; lng += 2) {
              const phi = (90 - lat) * Math.PI / 180;
              const theta = lng * Math.PI / 180;
              const r = radius + 0.02;
              
              ribbonPoints.push(
                r * Math.sin(phi) * Math.cos(theta),
                r * Math.cos(phi),
                r * Math.sin(phi) * Math.sin(theta)
              );
              
              const colorMix = (lng / 360);
              const color = new THREE.Color().setHSL(0.5 + colorMix * 0.1, 0.4, 0.8);
              ribbonColors.push(color.r, color.g, color.b);
            }
            
            ribbonGeo.setAttribute('position', new THREE.Float32BufferAttribute(ribbonPoints, 3));
            ribbonGeo.setAttribute('color', new THREE.Float32BufferAttribute(ribbonColors, 3));
            
            const ribbonMat = new THREE.ShaderMaterial({
              uniforms: {
                time: { value: 0 },
                ribbonIndex: { value: idx }
              },
              vertexShader: `
                attribute vec3 color;
                varying vec3 vColor;
                varying vec3 vPosition;
                uniform float time;
                uniform float ribbonIndex;
                
                void main() {
                  vColor = color;
                  vPosition = position;
                  
                  vec3 pos = position;
                  float rotation = time * 0.00002 * (ribbonIndex + 1.0);
                  float cosR = cos(rotation);
                  float sinR = sin(rotation);
                  pos.x = position.x * cosR - position.z * sinR;
                  pos.z = position.x * sinR + position.z * cosR;
                  
                  gl_Position = projectionMatrix * modelViewMatrix * vec4(pos, 1.0);
                }
              `,
              fragmentShader: `
                varying vec3 vColor;
                varying vec3 vPosition;
                uniform float time;
                
                void main() {
                  float shimmer = 0.5 + 0.05 * sin(time * 0.003 + vPosition.x * 10.0);
                  vec3 color = mix(vec3(0.49, 0.87, 0.86), vec3(0.89, 1.0, 0.98), shimmer);
                  float alpha = 0.35 * (1.0 - abs(vPosition.y) / 2.0);
                  gl_FragColor = vec4(color, alpha);
                }
              `,
              transparent: true,
              side: THREE.DoubleSide,
              blending: THREE.AdditiveBlending,
              depthWrite: false
            });
            
            const ribbon = new THREE.Line(ribbonGeo, ribbonMat);
            ribbon.userData.isRibbon = true;
            group.add(ribbon);
          });
          
          this.el.object3D.add(group);
          return group;
        },
        
        /**
         * DESIGN 3: PETAL ARC BLOOM
         */
        createPetalBloom: function() {
          const group = new THREE.Group();
          const radius = 1.51;
          const petalCount = 24;
          
          for (let i = 0; i < petalCount; i++) {
            const angle = (i / petalCount) * Math.PI * 2;
            const curve = new THREE.CubicBezierCurve3(
              new THREE.Vector3(0, radius, 0),
              new THREE.Vector3(
                Math.cos(angle) * radius * 0.5,
                radius * 0.5,
                Math.sin(angle) * radius * 0.5
              ),
              new THREE.Vector3(
                Math.cos(angle) * radius * 0.5,
                -radius * 0.5,
                Math.sin(angle) * radius * 0.5
              ),
              new THREE.Vector3(0, -radius, 0)
            );
            
            const points = curve.getPoints(50);
            const geometry = new THREE.BufferGeometry().setFromPoints(points);
            
            const colors = [];
            points.forEach((pt, idx) => {
              const t = idx / points.length;
              const color = new THREE.Color().lerpColors(
                new THREE.Color('#058e9e'),
                new THREE.Color('#4ddde8'),
                t
              );
              colors.push(color.r, color.g, color.b);
            });
            geometry.setAttribute('color', new THREE.Float32BufferAttribute(colors, 3));
            
            const material = new THREE.ShaderMaterial({
              uniforms: {
                time: { value: 0 },
                petalIndex: { value: i }
              },
              vertexShader: `
                attribute vec3 color;
                varying vec3 vColor;
                varying float vAlpha;
                uniform float time;
                uniform float petalIndex;
                
                void main() {
                  vColor = color;
                  
                  // Rotation for alternate petals
                  vec3 pos = position;
                  float rotAmount = 0.0;
                  if (mod(petalIndex, 2.0) == 0.0) {
                    rotAmount = sin(time * 0.0003) * 0.014;
                  } else {
                    rotAmount = sin(time * 0.0003 + 3.14159) * 0.014;
                  }
                  
                  float cosR = cos(rotAmount);
                  float sinR = sin(rotAmount);
                  float newX = pos.x * cosR - pos.z * sinR;
                  float newZ = pos.x * sinR + pos.z * cosR;
                  pos.x = newX;
                  pos.z = newZ;
                  
                  vec4 mvPosition = modelViewMatrix * vec4(pos, 1.0);
                  gl_Position = projectionMatrix * mvPosition;
                  
                  // Glancing angle fade
                  vec3 viewDir = normalize(-mvPosition.xyz);
                  vec3 worldNormal = normalize((modelMatrix * vec4(normalize(pos), 0.0)).xyz);
                  float facing = abs(dot(viewDir, worldNormal));
                  vAlpha = mix(0.25, 0.55, facing);
                }
              `,
              fragmentShader: `
                varying vec3 vColor;
                varying float vAlpha;
                uniform float time;
                
                void main() {
                  float glow = 0.3 + 0.2 * sin(time * 0.001);
                  gl_FragColor = vec4(vColor * (1.0 + glow), vAlpha);
                }
              `,
              transparent: true,
              side: THREE.DoubleSide,
              blending: THREE.AdditiveBlending,
              depthWrite: false
            });
            
            const line = new THREE.Line(geometry, material);
            line.userData.isPetal = true;
            group.add(line);
          }
          
          // Microfilament rings at specific latitudes
          [30, 60, 120].forEach(latDeg => {
            const lat = (latDeg - 90) * Math.PI / 180;
            const ringRadius = radius * Math.sin(Math.PI / 2 - Math.abs(lat));
            const ringY = radius * Math.cos(Math.PI / 2 - Math.abs(lat)) * Math.sign(latDeg - 90);
            
            const ringGeo = new THREE.RingGeometry(ringRadius - 0.01, ringRadius + 0.01, 64);
            const ringMat = new THREE.MeshBasicMaterial({
              color: '#2d9fa7',
              transparent: true,
              opacity: 0.15,
              side: THREE.DoubleSide
            });
            const ring = new THREE.Mesh(ringGeo, ringMat);
            ring.rotation.x = Math.PI / 2;
            ring.position.y = ringY;
            group.add(ring);
          });
          
          this.el.object3D.add(group);
          return group;
        },
        
        /**
         * DESIGN 4: FRACTAL MESH DISSOLVE
         */
        createFractalMesh: function() {
          const group = new THREE.Group();
          const radius = 1.51;
          
          // Three resolution layers
          const subdivisions = [0, 1, 2];
          const opacities = [0.25, 0.15, 0.1];
          
          subdivisions.forEach((subdiv, layerIdx) => {
            const geo = new THREE.IcosahedronGeometry(radius + layerIdx * 0.01, subdiv);
            
            // Apply spherical noise for organic scaling
            const positions = geo.attributes.position.array;
            for (let i = 0; i < positions.length; i += 3) {
              const x = positions[i];
              const y = positions[i + 1];
              const z = positions[i + 2];
              
              const noise = (Math.sin(x * 3.7) * Math.cos(y * 4.2) * Math.sin(z * 3.9) + 1) * 0.5;
              const scale = 1.0 + noise * 0.03;
              
              positions[i] *= scale;
              positions[i + 1] *= scale;
              positions[i + 2] *= scale;
            }
            geo.attributes.position.needsUpdate = true;
            
            const edgesGeo = new THREE.EdgesGeometry(geo);
            const material = new THREE.ShaderMaterial({
              uniforms: {
                time: { value: 0 },
                layerIndex: { value: layerIdx },
                baseOpacity: { value: opacities[layerIdx] }
              },
              vertexShader: `
                varying vec3 vPosition;
                void main() {
                  vPosition = position;
                  gl_Position = projectionMatrix * modelViewMatrix * vec4(position, 1.0);
                }
              `,
              fragmentShader: `
                uniform float time;
                uniform float layerIndex;
                uniform float baseOpacity;
                varying vec3 vPosition;
                
                void main() {
                  vec3 jadeMint = vec3(0.73, 0.96, 0.91);
                  vec3 blueGreen = vec3(0.18, 0.62, 0.65);
                  
                  float dist = length(vPosition);
                  vec3 color = mix(jadeMint, blueGreen, dist / 1.6);
                  
                  float opacity = baseOpacity;
                  
                  // Fine layer pulses
                  if (layerIndex > 1.5) {
                    opacity *= 0.35 + 0.2 * sin(time * 0.0002);
                  }
                  
                  float glow = 0.2 + 0.1 * sin(time * 0.001 + vPosition.x * 5.0);
                  
                  gl_FragColor = vec4(color * (1.0 + glow), opacity);
                }
              `,
              transparent: true,
              blending: THREE.AdditiveBlending,
              depthWrite: false
            });
            
            const mesh = new THREE.LineSegments(edgesGeo, material);
            mesh.userData.isFractalLayer = true;
            group.add(mesh);
          });
          
          this.el.object3D.add(group);
          return group;
        },
        
        /**
         * DESIGN 5: AWARD-WINNING HALO BEAD FILIGREE WITH DELRIN THREADS
         * Professional celestial jewelry design with visible connections
         */
        createHaloBeads: function() {
          const group = new THREE.Group();
          const radius = 1.51;
          const beadRadius = 0.018;
          
          const colors = [
            new THREE.Color('#e8fff9'),
            new THREE.Color('#b2f6eb'),
            new THREE.Color('#7de0d5'),
            new THREE.Color('#c9ffff')
          ];
          
          const beadPositions = [];
          const beadObjects = [];
          
          // Create meridian beads (longitude lines) - These ONLY go on meridians
          for (let lng = 0; lng < 360; lng += 15) {
            const theta = lng * Math.PI / 180;
            const meridianBeads = [];
            
            for (let lat = -90; lat <= 90; lat += 12) {
              const phi = (90 - lat) * Math.PI / 180;
              
              const x = radius * Math.sin(phi) * Math.cos(theta);
              const y = radius * Math.cos(phi);
              const z = radius * Math.sin(phi) * Math.sin(theta);
              
              const pos = new THREE.Vector3(x, y, z);
              
              // Artistic micro-jitter for organic feel
              pos.x += (Math.random() - 0.5) * 0.008;
              pos.y += (Math.random() - 0.5) * 0.008;
              pos.z += (Math.random() - 0.5) * 0.008;
              
              const isPole = (Math.abs(lat) === 90);
              const isAnchor = (lat % 30 === 0) && !isPole;
              const beadSize = isPole ? beadRadius * 2.2 : (isAnchor ? beadRadius * 1.5 : beadRadius);
              
              const beadGeo = new THREE.SphereGeometry(beadSize, 10, 10);
              const beadColor = colors[Math.floor((Math.abs(lat) / 90) * 3)];
              
              const beadMat = new THREE.MeshBasicMaterial({
                color: beadColor,
                transparent: true,
                opacity: isPole ? 0.85 : (isAnchor ? 0.75 : 0.65),
                blending: THREE.AdditiveBlending
              });
              
              const bead = new THREE.Mesh(beadGeo, beadMat);
              bead.position.copy(pos);
              bead.userData.isBead = true;
              bead.userData.isAnchor = isAnchor || isPole;
              bead.userData.isPole = isPole;
              bead.userData.baseColor = beadColor.clone();
              bead.userData.baseOpacity = beadMat.opacity;
              bead.userData.beadType = 'meridian';
              group.add(bead);
              beadObjects.push(bead);
              
              meridianBeads.push({ pos: pos, bead: bead });
            }
            
            // Connect beads along this meridian with delicate threads
            for (let i = 0; i < meridianBeads.length - 1; i++) {
              const pos1 = meridianBeads[i].pos;
              const pos2 = meridianBeads[i + 1].pos;
              
              const threadGeo = new THREE.BufferGeometry().setFromPoints([pos1, pos2]);
              const threadMat = new THREE.LineBasicMaterial({
                color: '#c2fff5',
                transparent: true,
                opacity: 0.3,
                blending: THREE.AdditiveBlending
              });
              const thread = new THREE.Line(threadGeo, threadMat);
              thread.userData.isThread = true;
              group.add(thread);
            }
          }
          
          // Create latitude rings (parallel circles) - ONLY on specific latitudes to avoid overlap
          const latitudes = [-75, -60, -45, -30, -15, 0, 15, 30, 45, 60, 75];
          
          latitudes.forEach((lat, ringIdx) => {
            const phi = (90 - lat) * Math.PI / 180;
            const ringRadius = radius * Math.sin(phi);
            const ringY = radius * Math.cos(phi);
            const ringBeads = [];
            
            for (let lng = 0; lng <= 345; lng += 18) {
              const theta = lng * Math.PI / 180;
              
              const x = ringRadius * Math.cos(theta);
              const z = ringRadius * Math.sin(theta);
              
              const pos = new THREE.Vector3(x, ringY, z);
              
              // Artistic jitter
              pos.x += (Math.random() - 0.5) * 0.008;
              pos.y += (Math.random() - 0.5) * 0.005;
              pos.z += (Math.random() - 0.5) * 0.008;
              
              const isAnchor = (lng % 90 === 0);
              const beadSize = isAnchor ? beadRadius * 1.4 : beadRadius * 0.95;
              
              const beadGeo = new THREE.SphereGeometry(beadSize, 10, 10);
              const beadColor = colors[(ringIdx % 3) + 1];
              
              const beadMat = new THREE.MeshBasicMaterial({
                color: beadColor,
                transparent: true,
                opacity: isAnchor ? 0.7 : 0.6,
                blending: THREE.AdditiveBlending
              });
              
              const bead = new THREE.Mesh(beadGeo, beadMat);
              bead.position.copy(pos);
              bead.userData.isBead = true;
              bead.userData.isAnchor = isAnchor;
              bead.userData.baseColor = beadColor.clone();
              bead.userData.baseOpacity = beadMat.opacity;
              bead.userData.beadType = 'latitude';
              group.add(bead);
              beadObjects.push(bead);
              
              ringBeads.push({ pos: pos, bead: bead });
            }
            
            // Connect beads around this latitude ring
            for (let i = 0; i < ringBeads.length; i++) {
              const pos1 = ringBeads[i].pos;
              const pos2 = ringBeads[(i + 1) % ringBeads.length].pos;
              
              const threadGeo = new THREE.BufferGeometry().setFromPoints([pos1, pos2]);
              const threadMat = new THREE.LineBasicMaterial({
                color: '#d8fff7',
                transparent: true,
                opacity: 0.28,
                blending: THREE.AdditiveBlending
              });
              const thread = new THREE.Line(threadGeo, threadMat);
              thread.userData.isThread = true;
              group.add(thread);
            }
          });
          
          this.el.object3D.add(group);
          return group;
        },
        
        /**
         * DESIGN 6: AWARD-WINNING NEURAL WEB CONSTELLATION
         * Organic geodesic network with ULTRA-VISIBLE glowing synaptic connections
         */
        createConnectedBeads: function() {
          const group = new THREE.Group();
          const radius = 1.51;
          const beadRadius = 0.022;
          
          const colors = [
            new THREE.Color('#f0fffc'),
            new THREE.Color('#b8f7ed'),
            new THREE.Color('#6ee3d6'),
            new THREE.Color('#9df7ec'),
            new THREE.Color('#d4fff9')
          ];
          
          const beadPositions = [];
          const beadObjects = [];
          
          // Create beads on icosahedron vertices for mathematically perfect distribution
          const tempGeo = new THREE.IcosahedronGeometry(radius, 2);
          const positions = tempGeo.attributes.position.array;
          
          for (let i = 0; i < positions.length; i += 3) {
            const baseX = positions[i];
            const baseY = positions[i + 1];
            const baseZ = positions[i + 2];
            
            // Minimal organic jitter
            const x = baseX + (Math.random() - 0.5) * 0.008;
            const y = baseY + (Math.random() - 0.5) * 0.008;
            const z = baseZ + (Math.random() - 0.5) * 0.008;
            
            const pos = new THREE.Vector3(x, y, z);
            beadPositions.push(pos);
            
            // Determine bead hierarchy
            const distFromEquator = Math.abs(baseY / radius);
            const isPolar = distFromEquator > 0.85;
            const isAnchor = (Math.random() < 0.25) || isPolar;
            const beadSize = isPolar ? beadRadius * 2.0 : (isAnchor ? beadRadius * 1.5 : beadRadius);
            
            const beadGeo = new THREE.SphereGeometry(beadSize, 12, 12);
            const colorIndex = Math.floor((distFromEquator) * (colors.length - 1));
            const beadColor = colors[colorIndex];
            
            const beadMat = new THREE.MeshBasicMaterial({
              color: beadColor,
              transparent: true,
              opacity: isPolar ? 0.9 : (isAnchor ? 0.78 : 0.68),
              blending: THREE.AdditiveBlending
            });
            
            const bead = new THREE.Mesh(beadGeo, beadMat);
            bead.position.copy(pos);
            bead.userData.isBead = true;
            bead.userData.isAnchor = isAnchor;
            bead.userData.isPolar = isPolar;
            bead.userData.baseColor = beadColor.clone();
            bead.userData.baseOpacity = beadMat.opacity;
            bead.userData.nodeIndex = beadObjects.length;
            group.add(bead);
            beadObjects.push(bead);
          }
          
          // Create SUPER VISIBLE connections - Using simple LineBasicMaterial for guaranteed visibility
          const connectionDistance = 0.50;
          const maxConnectionsPerNode = 6;
          const connectionRegistry = new Map();
          
          let totalConnections = 0;
          
          for (let i = 0; i < beadPositions.length; i++) {
            const pos1 = beadPositions[i];
            const bead1 = beadObjects[i];
            let connectionCount = 0;
            
            // Find nearest neighbors for natural web structure
            const neighbors = [];
            for (let j = 0; j < beadPositions.length; j++) {
              if (i === j) continue;
              const pos2 = beadPositions[j];
              const dist = pos1.distanceTo(pos2);
              if (dist < connectionDistance) {
                neighbors.push({ index: j, distance: dist, pos: pos2, bead: beadObjects[j] });
              }
            }
            
            // Sort by distance and connect to nearest
            neighbors.sort((a, b) => a.distance - b.distance);
            
            for (let n of neighbors) {
              if (connectionCount >= maxConnectionsPerNode) break;
              
              const j = n.index;
              const pos2 = n.pos;
              
              // Avoid duplicate connections
              const connectionKey = i < j ? `${i}-${j}` : `${j}-${i}`;
              if (connectionRegistry.has(connectionKey)) continue;
              connectionRegistry.set(connectionKey, true);
              
              // METHOD 1: Simple highly visible line
              const lineGeo = new THREE.BufferGeometry().setFromPoints([pos1, pos2]);
              const lineMat = new THREE.LineBasicMaterial({
                color: '#9df7ec',
                transparent: true,
                opacity: 0.5,
                blending: THREE.AdditiveBlending,
                linewidth: 2
              });
              const line = new THREE.Line(lineGeo, lineMat);
              line.userData.isConnection = true;
              line.userData.connectionPair = [i, j];
              group.add(line);
              
              // METHOD 2: Also add a glowing tube for extra visibility
              const curve = new THREE.LineCurve3(pos1, pos2);
              const tubeGeo = new THREE.TubeGeometry(curve, 4, 0.008, 8, false);
              
              const bead2 = beadObjects[j];
              
              const tubeMat = new THREE.ShaderMaterial({
                uniforms: {
                  time: { value: 0 },
                  color1: { value: new THREE.Color('#c9ffff') },
                  color2: { value: new THREE.Color('#7de0d5') },
                  tubeIndex: { value: totalConnections * 0.5 }
                },
                vertexShader: `
                  varying vec3 vPosition;
                  varying float vDist;
                  void main() {
                    vPosition = position;
                    vDist = length(position);
                    gl_Position = projectionMatrix * modelViewMatrix * vec4(position, 1.0);
                  }
                `,
                fragmentShader: `
                  uniform float time;
                  uniform vec3 color1;
                  uniform vec3 color2;
                  uniform float tubeIndex;
                  varying vec3 vPosition;
                  varying float vDist;
                  
                  void main() {
                    // Flowing energy pulse
                    float pulse = sin(time * 0.0004 + tubeIndex + vDist * 8.0) * 0.5 + 0.5;
                    
                    // Color gradient
                    vec3 color = mix(color1, color2, pulse);
                    
                    // Strong constant glow
                    float alpha = 0.45 + pulse * 0.25;
                    
                    gl_FragColor = vec4(color * 1.3, alpha);
                  }
                `,
                transparent: true,
                blending: THREE.AdditiveBlending,
                depthWrite: false,
                side: THREE.DoubleSide
              });
              
              const tube = new THREE.Mesh(tubeGeo, tubeMat);
              tube.userData.isTube = true;
              group.add(tube);
              
              connectionCount++;
              totalConnections++;
            }
          }
          
          console.log(`Created ${totalConnections} connections between ${beadObjects.length} beads`);
          
          this.el.object3D.add(group);
          return group;
        },
        
        /**
         * ANIMATION TICK - Update all shader uniforms and effects
         */
        tick: function(time, timeDelta) {
          // Design 1: Nested Harmonic Shells - Breathing animation + consciousness
          if (this.fenceObjects[1]) {
            const consciousnessWave = Math.sin(time * 0.00012) * 0.5 + 0.5;
            
            this.fenceObjects[1].children.forEach((mesh, idx) => {
              if (mesh.userData.isShell) {
                const phase = mesh.userData.phaseOffset;
                const breathe = 1.0 + Math.sin((time + phase) * 0.0005) * 0.012;
                mesh.scale.set(breathe, breathe, breathe);
                
                if (mesh.material.uniforms) {
                  mesh.material.uniforms.time.value = time;
                  
                  // Consciousness: subtle opacity pulse across shells
                  const opacityMod = 0.95 + consciousnessWave * 0.1;
                  mesh.material.uniforms.baseOpacity.value = (0.15 + idx * 0.05) * opacityMod;
                }
              }
            });
          }
          
          // Design 2: Veil Lattice - Ribbon rotation and shimmer + consciousness
          if (this.fenceObjects[2]) {
            const consciousShimmer = Math.sin(time * 0.0001) * 0.5 + 0.5;
            
            this.fenceObjects[2].children.forEach(child => {
              if (child.userData.isRibbon && child.material.uniforms) {
                child.material.uniforms.time.value = time;
                
                // Consciousness: gentle opacity breathing
                const baseOpacity = 0.35;
                child.material.opacity = baseOpacity * (0.9 + consciousShimmer * 0.15);
              }
              
              // Lattice gets subtle consciousness glow
              if (child.material && child.material.opacity !== undefined && !child.userData.isRibbon) {
                child.material.opacity = 0.25 * (0.95 + consciousShimmer * 0.1);
              }
            });
          }
          
          // Design 3: Petal Bloom - Petal rotation + consciousness
          if (this.fenceObjects[3]) {
            const consciousGlow = Math.sin(time * 0.00013) * 0.5 + 0.5;
            
            this.fenceObjects[3].children.forEach(child => {
              if (child.userData.isPetal && child.material.uniforms) {
                child.material.uniforms.time.value = time;
                
                // Consciousness: subtle scale pulse on petals
                const petalBreath = 1.0 + consciousGlow * 0.006;
                child.scale.set(petalBreath, petalBreath, petalBreath);
              }
              
              // Microfilament rings get consciousness opacity
              if (child.type === 'Mesh' && child.material.opacity !== undefined) {
                const baseOpacity = 0.15;
                child.material.opacity = baseOpacity * (0.9 + consciousGlow * 0.12);
              }
            });
          }
          
          // Design 4: Fractal Mesh - Layer pulsing + consciousness
          if (this.fenceObjects[4]) {
            const consciousFlow = Math.sin(time * 0.00009) * 0.5 + 0.5;
            
            this.fenceObjects[4].children.forEach(child => {
              if (child.userData.isFractalLayer && child.material.uniforms) {
                child.material.uniforms.time.value = time;
                
                // Consciousness: organic rotation on Y axis
                const rotationAmount = Math.sin(time * 0.00004) * 0.01;
                child.rotation.y = rotationAmount;
                
                // Subtle scale breathing
                const scaleBreath = 1.0 + consciousFlow * 0.005;
                child.scale.set(scaleBreath, scaleBreath, scaleBreath);
              }
            });
          }
          
          // Design 5: Halo Beads - UPGRADED: Separate animation for different bead types
          if (this.fenceObjects[5]) {
            const consciousnessWave = Math.sin(time * 0.00015) * 0.5 + 0.5;
            const hueShift = Math.sin(time * 0.00008) * 0.08;
            
            this.fenceObjects[5].children.forEach(child => {
              if (child.userData.isBead) {
                const baseColor = child.userData.baseColor;
                const hsl = {};
                baseColor.getHSL(hsl);
                
                // Different animation for different bead types
                if (child.userData.isPole) {
                  // Polar beads: gentle pulsing beacon effect
                  const polePulse = 0.85 + Math.sin(time * 0.0008) * 0.15;
                  child.material.opacity = child.userData.baseOpacity * polePulse;
                  child.material.color.setHSL(
                    hsl.h + hueShift * 1.5,
                    hsl.s * (0.85 + consciousnessWave * 0.15),
                    Math.min(1.0, hsl.l * (1.15 + consciousnessWave * 0.1))
                  );
                } else if (child.userData.isAnchor) {
                  // Anchor beads: steady warm glow
                  const anchorGlow = 0.75 + Math.sin(time * 0.0004 + child.position.y * 3.0) * 0.1;
                  child.material.opacity = child.userData.baseOpacity * anchorGlow;
                  child.material.color.setHSL(
                    hsl.h + hueShift,
                    hsl.s,
                    Math.min(1.0, hsl.l * (1.0 + consciousnessWave * 0.12))
                  );
                } else {
                  // Regular beads: subtle shimmer
                  const localShimmer = Math.sin(time * 0.0003 + child.position.x * 4.0 + child.position.z * 3.5) * 0.5 + 0.5;
                  child.material.opacity = child.userData.baseOpacity * (0.92 + localShimmer * 0.08);
                  child.material.color.setHSL(
                    hsl.h + hueShift * 0.7,
                    hsl.s * (0.95 + consciousnessWave * 0.05),
                    Math.min(1.0, hsl.l * (1.0 + consciousnessWave * 0.08))
                  );
                }
              }
              
              // Animate threads with gentle wave motion
              if (child.userData.isThread) {
                const threadPulse = Math.sin(time * 0.0002) * 0.5 + 0.5;
                child.material.opacity = 0.28 + threadPulse * 0.12;
              }
            });
          }
          
          // Design 6: UPGRADED Neural Web - Enhanced synaptic flow + consciousness
          if (this.fenceObjects[6]) {
            const hueShift = Math.sin(time * 0.00006) * 0.1;
            const breathe = 1.0 + Math.sin(time * 0.0002) * 0.006;
            const consciousnessGlow = Math.sin(time * 0.00012) * 0.5 + 0.5;
            const connectionPulse = Math.sin(time * 0.0005) * 0.5 + 0.5;
            
            this.fenceObjects[6].scale.set(breathe, breathe, breathe);
            
            this.fenceObjects[6].children.forEach(child => {
              // Animate shader-based tubes
              if (child.userData.isTube && child.material.uniforms) {
                child.material.uniforms.time.value = time;
              }
              
              // Animate simple connection lines
              if (child.userData.isConnection) {
                child.material.opacity = 0.5 + connectionPulse * 0.2;
              }
              
              if (child.userData.isBead) {
                const baseColor = child.userData.baseColor;
                const hsl = {};
                baseColor.getHSL(hsl);
                
                // Different effects for different node types
                if (child.userData.isPolar) {
                  // Polar nodes: central hub glow
                  const hubPulse = 0.9 + Math.sin(time * 0.0005) * 0.1;
                  child.material.opacity = child.userData.baseOpacity * hubPulse * (1.0 + consciousnessGlow * 0.08);
                  child.material.color.setHSL(
                    hsl.h + hueShift * 1.2,
                    hsl.s * (0.9 + consciousnessGlow * 0.1),
                    Math.min(1.0, hsl.l * (1.2 + consciousnessGlow * 0.1))
                  );
                } else if (child.userData.isAnchor) {
                  // Anchor nodes: neural activity pulse
                  const neuralPulse = Math.sin(time * 0.0004 + child.userData.nodeIndex * 0.7) * 0.5 + 0.5;
                  child.material.opacity = child.userData.baseOpacity * (0.95 + neuralPulse * 0.15);
                  child.material.color.setHSL(
                    hsl.h + hueShift,
                    hsl.s * (0.85 + consciousnessGlow * 0.15),
                    Math.min(1.0, hsl.l * (1.1 + neuralPulse * 0.15))
                  );
                } else {
                  // Regular nodes: organic shimmer
                  const localGlow = Math.sin(time * 0.0003 + child.position.x * 5.0 + child.position.y * 4.5) * 0.5 + 0.5;
                  const brightnessMod = 1.0 + (consciousnessGlow * 0.08 + localGlow * 0.12);
                  
                  child.material.color.setHSL(
                    hsl.h + hueShift * 0.8,
                    hsl.s * (0.9 + consciousnessGlow * 0.1),
                    Math.min(1.0, hsl.l * brightnessMod)
                  );
                  
                  child.material.opacity = child.userData.baseOpacity * (0.92 + localGlow * 0.08);
                }
              }
            });
          }
          
          // Add consciousness to original wire (Design 0)
          if (this.currentDesign === 0 && this.originalWire) {
            const consciousBreath = Math.sin(time * 0.0002) * 0.5 + 0.5;
            const mesh = this.originalWire.getObject3D('mesh');
            if (mesh && mesh.material) {
              const baseOpacity = 0.2;
              mesh.material.opacity = baseOpacity * (0.9 + consciousBreath * 0.1);
              
              // Subtle color shift
              const hsl = {};
              const baseColor = new THREE.Color('#48dbfb');
              baseColor.getHSL(hsl);
              mesh.material.color.setHSL(
                hsl.h + Math.sin(time * 0.0001) * 0.02,
                hsl.s,
                hsl.l * (1.0 + consciousBreath * 0.05)
              );
            }
          }
        }
      });

      /**
       * ADVANCED AUDIO ENGINE
       */
      class EnhancedImpactEngine {
        constructor() {
          const AudioContext = window.AudioContext || window.webkitAudioContext;
          this.ctx = new AudioContext();
          
          this.maxVoices = 8; 
          this.voicePool = [];
          this.lastTriggerTime = 0;
          this.minTimeBetweenTriggers = 15; 
          this.impactQueue = [];
          this.isProcessingQueue = false;
          
          this.masterGain = this.ctx.createGain();
          // Increased default master gain slightly
          this.masterGain.gain.value = 0.30;
          
          this.limiter = this.ctx.createDynamicsCompressor();
          this.limiter.threshold.value = -2;
          this.limiter.ratio.value = 20;
          this.limiter.attack.value = 0.001;
          
          this.limiter.connect(this.masterGain);
          this.masterGain.connect(this.ctx.destination);
          
          this.convolver = this.ctx.createConvolver();
          this.wetGain = this.ctx.createGain();
          this.wetGain.gain.value = 0.3; 
          this.dryGain = this.ctx.createGain();
          this.dryGain.gain.value = 0.8;
          
          this.convolver.connect(this.wetGain);
          this.wetGain.connect(this.limiter);
          this.dryGain.connect(this.limiter);
          
          this.createMassiveHallImpulse();
          this.initVoicePool();
        }

        createMassiveHallImpulse() {
          const length = this.ctx.sampleRate * 3.0;
          const impulse = this.ctx.createBuffer(2, length, this.ctx.sampleRate);
          for (let channel = 0; channel < 2; channel++) {
            const channelData = impulse.getChannelData(channel);
            for (let i = 0; i < length; i++) {
              const decay = Math.pow(1 - i / length, 3);
              channelData[i] = (Math.random() * 2 - 1) * decay;
            }
          }
          this.convolver.buffer = impulse;
        }

        initVoicePool() {
          for (let i = 0; i < this.maxVoices; i++) {
            this.voicePool.push({ id: i, inUse: false, startTime: 0 });
          }
        }

        setVolume(val) {
          this.masterGain.gain.setTargetAtTime(val, this.ctx.currentTime, 0.05);
        }
        
        clearQueue() {
          this.impactQueue = [];
        }

        play(velocity = 1.0, position = null) {
          if (this.ctx.state === 'suspended') this.ctx.resume();
          const now = performance.now();
          if (now - this.lastTriggerTime < this.minTimeBetweenTriggers) {
            if (this.impactQueue.length < 15) this.impactQueue.push({ velocity, position });
            if (!this.isProcessingQueue) this.processQueue();
            return;
          }
          this.lastTriggerTime = now;
          this.triggerStandardImpact(velocity);
        }

        async processQueue() {
          this.isProcessingQueue = true;
          while (this.impactQueue.length > 0) {
            const now = performance.now();
            if (now - this.lastTriggerTime >= this.minTimeBetweenTriggers) {
              const impact = this.impactQueue.shift();
              this.lastTriggerTime = now;
              this.triggerStandardImpact(impact.velocity);
            }
            await new Promise(r => setTimeout(r, 5));
          }
          this.isProcessingQueue = false;
        }

        /**
         * ULTIMATE FIX: Anti-Rattle Impact + VOLUME BOOST
         */
        triggerStandardImpact(velocity) {
          const voice = this.voicePool.find(v => !v.inUse);
          if (!voice) return;
          voice.inUse = true;
          
          // Lookahead to prevent thread jitter clicks
          const t = this.ctx.currentTime + 0.005; 
          
          const osc = this.ctx.createOscillator();
          const gain = this.ctx.createGain();
          
          // 1. FREQUENCY: Use setTargetAtTime for smoother, non-lasery drop
          const startFreq = 180 + Math.random() * 40;
          osc.frequency.setValueAtTime(startFreq, t);
          osc.frequency.setTargetAtTime(40, t, 0.03); // 0.03 time constant = organic drop
          
          // 2. GAIN ENVELOPE: BOOSTED VOLUME HERE
          // Was velocity * 0.4, Now velocity * 1.5 (Huge Boost)
          gain.gain.setValueAtTime(0, t);
          gain.gain.linearRampToValueAtTime(velocity * 1.5, t + 0.01); 
          
          // Smooth Exponential Decay using setTargetAtTime
          // This mathematically approaches 0 without ever hitting the glitchy "math error" point
          gain.gain.setTargetAtTime(0, t + 0.01, 0.04); 
          
          osc.connect(gain);
          gain.connect(this.dryGain);
          gain.connect(this.convolver);
          
          osc.start(t);
          
          // 3. SAFETY STOP: Stop well after sound is silent
          // 0.04 * 6 = 0.24s (sound is effectively -60dB by then)
          const stopTime = t + 0.3; 
          osc.stop(stopTime);
          
          setTimeout(() => { 
            voice.inUse = false;
            try {
                osc.disconnect();
                gain.disconnect();
            } catch(e) {}
          }, 350); // Recycle voice after audio is definitely done
        }

        // --- DYNAMIC PRESSURE SYNTHESIS (UNTOUCHED) ---
        playPressureCrush(density, force) {
          if (this.ctx.state === 'suspended') this.ctx.resume();
          
          const now = this.ctx.currentTime;
          
          // Clamp inputs for safety
          const d = Math.max(0, Math.min(1, density)); 
          const f = Math.max(0.01, Math.min(1.5, force));

          const masterVol = Math.min(0.8, d * 1.0); 
          const attackTime = 0.01 + (1.5 - f) * 0.2; 
          const releaseTime = 0.2 + (1.5 - f) * 1.0; 
          const baseFreq = 40 + (f * 30); 
          const dropFreq = 20;
          const filterFreq = 150 + (f * 1200); 

          // 1. SUB LAYER
          const subOsc = this.ctx.createOscillator();
          const subGain = this.ctx.createGain();
          subOsc.type = 'sine';
          subOsc.frequency.setValueAtTime(baseFreq, now);
          subOsc.frequency.exponentialRampToValueAtTime(dropFreq, now + releaseTime);
          
          subGain.gain.setValueAtTime(0, now);
          subGain.gain.linearRampToValueAtTime(masterVol, now + attackTime);
          subGain.gain.exponentialRampToValueAtTime(0.001, now + releaseTime);

          // 2. CRUSH LAYER 
          const crushOsc = this.ctx.createOscillator();
          const crushGain = this.ctx.createGain();
          const filter = this.ctx.createBiquadFilter();
          
          crushOsc.type = 'sawtooth';
          crushOsc.frequency.setValueAtTime(baseFreq * 2, now);
          crushOsc.frequency.exponentialRampToValueAtTime(dropFreq, now + (releaseTime * 0.5));
          
          filter.type = 'lowpass';
          filter.Q.value = 1 + (f * 4); 
          filter.frequency.setValueAtTime(filterFreq, now);
          filter.frequency.exponentialRampToValueAtTime(50, now + releaseTime);

          crushGain.gain.setValueAtTime(0, now);
          crushGain.gain.linearRampToValueAtTime(masterVol * 0.6, now + (attackTime * 0.5));
          crushGain.gain.exponentialRampToValueAtTime(0.001, now + (releaseTime * 0.8));

          subOsc.connect(subGain);
          subGain.connect(this.dryGain);
          subGain.connect(this.convolver);

          crushOsc.connect(filter);
          filter.connect(crushGain);
          crushGain.connect(this.dryGain);
          crushGain.connect(this.convolver);

          subOsc.start(now);
          subOsc.stop(now + releaseTime + 0.1);
          crushOsc.start(now);
          crushOsc.stop(now + releaseTime + 0.1);
        }
      }

      const CONFIG = { 
        ballCount: 100, 
        ringPoolSize: 50, 
        boxSize: 5, 
        ballRadius: 0.1, 
        defaultSphereRadius: 1.5,
        collisionCooldown: 50 
      };
      
      const PALETTES = {
        chill:     ['#00d2d3', '#48dbfb', '#0abde3', '#54a0ff'], 
        attack:    ['#ff4757', '#ff6b81', '#e17055', '#d63031'], 
        pressure:  ['#8e44ad', '#9b59b6', '#f1c40f', '#e67e22'], 
        pushback:  ['#bdc3c7', '#ecf0f1', '#95a5a6', '#7f8c8d']  
      };

      let state = { mode: 'chill', intensity: 0.1, soundVolume: 0.30, targetRadius: 1.5 };

      function randomRange(min, max) { return Math.random() * (max - min) + min; }
      function randomColor(palette) { return palette[Math.floor(Math.random() * palette.length)]; }

      const intensitySlider = document.getElementById('intensitySlider');
      const volumeSlider = document.getElementById('volumeSlider');
      intensitySlider.addEventListener('input', (e) => { 
        state.intensity = parseFloat(e.target.value);
        document.getElementById('val-force').innerText = state.intensity.toFixed(2);
        document.getElementById('debug-force').innerText = state.intensity.toFixed(2);
      });
      volumeSlider.addEventListener('input', (e) => { 
        state.soundVolume = parseFloat(e.target.value);
        document.getElementById('val-vol').innerText = Math.round(state.soundVolume * 100) + '%';
        const logic = document.querySelector('[swarm-logic]').components['swarm-logic'];
        if (logic) logic.soundEngine.setVolume(state.soundVolume);
      });

      AFRAME.registerComponent('ambient-breathing', {
        init: function() {
          this.colorA = new THREE.Color('#00d2d3'); 
          this.colorB = new THREE.Color('#006266'); 
          this.currentColor = new THREE.Color();
          this.core = this.el.querySelector('#safe-core'); 
          this.wire = this.el.querySelector('#safe-wire');
        },
        tick: function(time) {
          const alpha = (Math.sin(time * 0.001) + 1) / 2;
          this.currentColor.copy(this.colorB).lerp(this.colorA, alpha);
          const hex = this.currentColor.getHex();
          if(this.core) this.core.getObject3D('mesh').material.color.setHex(hex);
          if(this.wire) this.wire.getObject3D('mesh').material.color.setHex(hex);
        }
      });

      AFRAME.registerComponent('pooled-ring', {
        init: function() {
          this.isActive = false; this.lifeTime = 0; this.timer = 0;
          this.el.setAttribute('geometry', { primitive: 'ring', radiusInner: CONFIG.ballRadius * 0.85, radiusOuter: CONFIG.ballRadius, segmentsTheta: 32 });
          this.el.setAttribute('material', { color: '#ffd700', shader: 'flat', transparent: true, opacity: 0, side: 'double', blending: 'additive', depthTest: false, depthWrite: false });
          this.el.object3D.visible = false;
        },
        activate: function(pos, normal, color) {
          this.isActive = true; this.timer = 0; this.lifeTime = 400 + Math.random() * 600; 
          this.el.object3D.position.copy(pos).addScaledVector(normal, 0.02);
          this.el.object3D.lookAt(new THREE.Vector3().copy(pos).add(normal));
          this.el.object3D.visible = true;
          const mesh = this.el.getObject3D('mesh');
          if (mesh) { mesh.material.opacity = 1.0; mesh.material.color.set(color); }
        },
        tick: function(t, dt) {
          if (!this.isActive) return;
          this.timer += dt;
          if (this.timer >= this.lifeTime) { this.isActive = false; this.el.object3D.visible = false; return; }
          const progress = this.timer / this.lifeTime;
          if (this.el.getObject3D('mesh')) this.el.getObject3D('mesh').material.opacity = 1.0 - progress;
        }
      });

      AFRAME.registerComponent('swarm-logic', {
        init: function() {
          const scene = this.el.sceneEl;
          this.soundEngine = new EnhancedImpactEngine();
          this.balls = [];
          this.safeSphere = document.querySelector('#safe-sphere-container');
          
          // Buckets for Pressure Mode
          this.pressureBucketCurrent = 0;
          this.pressureBucketPrevious = 0;
          this.pressureTimer = 0;

          this.ringPool = [];
          this.poolIndex = 0;
          const poolContainer = document.querySelector('#pool-container');
          for(let i=0; i<CONFIG.ringPoolSize; i++) {
             let el = document.createElement('a-entity');
             el.setAttribute('pooled-ring', '');
             poolContainer.appendChild(el);
             this.ringPool.push(el);
          }

          const bound = CONFIG.boxSize / 2;
          for(let i=0; i<CONFIG.ballCount; i++) {
            let ball = document.createElement('a-sphere');
            ball.setAttribute('radius', CONFIG.ballRadius);
            ball.setAttribute('segments-width', 8); ball.setAttribute('segments-height', 8);
            ball.setAttribute('material', 'shader: standard; roughness: 0.3; metalness: 0.5;');
            
            let pos = new THREE.Vector3(randomRange(-bound, bound), randomRange(-bound, bound), randomRange(-bound, bound));
            if (pos.length() < CONFIG.defaultSphereRadius) pos.setLength(CONFIG.defaultSphereRadius + 0.5);
            
            ball.object3D.position.copy(pos);
            ball.userData = { 
              velocity: new THREE.Vector3(0,0,0), 
              colorTarget: new THREE.Color(randomColor(PALETTES.chill)), 
              currentColor: new THREE.Color(randomColor(PALETTES.chill)), 
              isAttacking: false, attackCooldown: 0, lastImpactTime: 0 
            };
            scene.appendChild(ball);
            this.balls.push(ball);
          }
          this.vTemp = new THREE.Vector3(); this.vDir = new THREE.Vector3(); this.vNormal = new THREE.Vector3();
        },

        tick: function(time, timeDelta) {
          if (timeDelta > 100) return;
          const dt = timeDelta / 1000; 
          const bound = CONFIG.boxSize / 2;
          const origin = new THREE.Vector3(0,0,0);
          const now = performance.now();

          if (state.mode === 'pressure') {
            this.pressureTimer += timeDelta;
            if (this.pressureTimer >= 1000) {
              const totalImpacts = this.pressureBucketCurrent + this.pressureBucketPrevious;
              
              // Normalize against max possible impacts
              const maxPossibleImpacts = CONFIG.ballCount * 20; 
              const density = Math.min(1.0, totalImpacts / maxPossibleImpacts);

              document.getElementById('pressure-load').innerText = Math.round(density * 100) + '%';

              this.soundEngine.playPressureCrush(density, state.intensity);

              this.pressureBucketPrevious = this.pressureBucketCurrent;
              this.pressureBucketCurrent = 0;
              this.pressureTimer = 0;
            }
          } else {
            this.pressureBucketCurrent = 0; this.pressureBucketPrevious = 0; this.pressureTimer = 0;
          }

          let currentScale = this.safeSphere.object3D.scale.x;
          let scaleDiff = state.targetRadius - currentScale;
          if (Math.abs(scaleDiff) > 0.001) {
            let speed = (state.mode === 'pushback') ? 0.3 : 2.0; 
            let newScale = currentScale + (scaleDiff * speed * dt);
            this.safeSphere.object3D.scale.set(newScale, newScale, newScale);
          }
          const currentRadius = 1.5 * this.safeSphere.object3D.scale.x;

          for (let i = 0; i < this.balls.length; i++) {
            let ball = this.balls[i];
            let uData = ball.userData;
            let pos = ball.object3D.position;

            uData.currentColor.lerp(uData.colorTarget, 0.08);
            const mesh = ball.getObject3D('mesh');
            if(mesh) { 
              mesh.material.color.setHex(uData.currentColor.getHex()); 
              mesh.material.emissive.setHex(uData.currentColor.getHex()); 
              mesh.material.emissiveIntensity = 0.5; 
            }

            let dist = pos.length();
            if (state.mode === 'chill' || state.mode === 'pushback') {
               uData.velocity.multiplyScalar(0.98); 
               this.applyJitter(uData.velocity, 0.005 * state.intensity);
               if(uData.velocity.length() < 0.02) uData.velocity.normalize().multiplyScalar(0.02);
               uData.isAttacking = false;
            } else if (state.mode === 'attack') {
               if (uData.attackCooldown > 0) uData.attackCooldown -= dt;
               if (!uData.isAttacking && uData.attackCooldown <= 0) {
                  if (Math.random() < 0.02 * state.intensity) {
                     uData.isAttacking = true;
                     this.vDir.copy(origin).sub(pos).normalize();
                     uData.velocity.copy(this.vDir).multiplyScalar((3.5 + state.intensity * 2.0) * dt);
                  } else {
                     this.applyJitter(uData.velocity, 0.02 * state.intensity);
                  }
               }
            } else if (state.mode === 'pressure') {
               this.vDir.copy(origin).sub(pos).normalize();
               uData.velocity.addScaledVector(this.vDir, 0.04 * state.intensity);
               uData.velocity.multiplyScalar(0.96);
               uData.isAttacking = false;
            }
            
            pos.add(uData.velocity);

            if (Math.abs(pos.x) > bound) { pos.x = Math.sign(pos.x)*bound; uData.velocity.x *= -0.8; }
            if (Math.abs(pos.y) > bound) { pos.y = Math.sign(pos.y)*bound; uData.velocity.y *= -0.8; }
            if (Math.abs(pos.z) > bound) { pos.z = Math.sign(pos.z)*bound; uData.velocity.z *= -0.8; }

            let minDist = currentRadius + CONFIG.ballRadius;
            if (dist < minDist) {
               this.vNormal.copy(pos).normalize();
               const canPlaySound = (now - uData.lastImpactTime) > CONFIG.collisionCooldown;

               if (state.mode === 'attack' && uData.isAttacking) {
                  this.spawnRing(pos, this.vNormal, uData.currentColor);
                  if (canPlaySound) {
                    this.soundEngine.play(Math.min(1.0, uData.velocity.length() * 0.3), pos);
                    uData.lastImpactTime = now;
                  }
                  uData.isAttacking = false; uData.attackCooldown = 0.5;
                  uData.velocity.multiplyScalar(0.2); 
               } 
               else if (state.mode === 'pressure') {
                  if (canPlaySound) {
                      this.pressureBucketCurrent++; 
                      uData.lastImpactTime = now;
                      this.spawnRing(pos, this.vNormal, uData.currentColor);
                  }
               }

               let vDotN = uData.velocity.dot(this.vNormal);
               this.vTemp.copy(this.vNormal).multiplyScalar(2 * vDotN);
               uData.velocity.sub(this.vTemp);
               pos.copy(this.vNormal).multiplyScalar(minDist);
               uData.velocity.addScaledVector(this.vNormal, 0.01);
            }
          }
          
          if (['pressure', 'chill', 'pushback'].includes(state.mode)) this.handleBallCollisions(); 
        },
        
        spawnRing: function(pos, normal, color) {
            let poolEl = this.ringPool[this.poolIndex];
            this.poolIndex = (this.poolIndex + 1) % this.ringPool.length;
            if (poolEl.components['pooled-ring']) poolEl.components['pooled-ring'].activate(pos, normal, color);
        },
        
        handleBallCollisions: function() {
           let minDist = CONFIG.ballRadius * 2; let minDistSq = minDist * minDist;
           for (let i = 0; i < this.balls.length; i++) {
             for (let j = i + 1; j < this.balls.length; j++) {
                let b1 = this.balls[i].object3D.position; let b2 = this.balls[j].object3D.position;
                let distSq = b1.distanceToSquared(b2);
                if (distSq < minDistSq) {
                   let dist = Math.sqrt(distSq);
                   this.vTemp.copy(b1).sub(b2).normalize();
                   let overlap = (minDist - dist) * 0.5;
                   b1.addScaledVector(this.vTemp, overlap); b2.addScaledVector(this.vTemp, -overlap);
                   let v1 = this.balls[i].userData.velocity; let v2 = this.balls[j].userData.velocity;
                   this.vDir.copy(this.vTemp).multiplyScalar(0.01); 
                   v1.add(this.vDir).multiplyScalar(0.95); v2.sub(this.vDir).multiplyScalar(0.95);
                }
             }
           }
        },
        
        applyJitter: function(vel, force) {
           vel.x += randomRange(-force, force); vel.y += randomRange(-force, force); vel.z += randomRange(-force, force);
        }
      });

      function setMode(mode) {
        const logic = document.querySelector('[swarm-logic]').components['swarm-logic'];
        if (logic) logic.soundEngine.clearQueue();

        state.mode = mode;
        document.querySelectorAll('button').forEach(b => b.classList.remove('active'));
        const idMap = { 'attack': 'btn-attack', 'pressure': 'btn-pressure', 'pushback': 'btn-push', 'chill': 'btn-chill' };
        document.getElementById(idMap[mode]).classList.add('active');
        
        if (mode === 'chill') state.targetRadius = 1.5;
        if (mode === 'attack') state.targetRadius = 1.5;
        if (mode === 'pressure') state.targetRadius = 0.7; 
        if (mode === 'pushback') state.targetRadius = 1.5; 
        
        if(logic) {
          logic.balls.forEach(ball => { ball.userData.colorTarget.set(randomColor(PALETTES[mode])); });
        }
      }
    </script>
  </body>
</html>