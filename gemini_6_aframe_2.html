<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8">
    <title>A-Frame Swarm: Safe Sphere Component</title>
    <script src="https://aframe.io/releases/1.7.0/aframe.min.js"></script>
    <style>
      body { margin: 0; overflow: hidden; font-family: 'Segoe UI', sans-serif; user-select: none; }
      
      #ui-container {
        position: absolute; bottom: 30px; left: 50%; transform: translateX(-50%);
        z-index: 100; display: flex; flex-direction: column; align-items: center;
        gap: 15px; background: rgba(0, 0, 0, 0.85); padding: 20px;
        border-radius: 24px; backdrop-filter: blur(12px);
        border: 1px solid rgba(255, 255, 255, 0.15);
        box-shadow: 0 10px 30px rgba(0,0,0,0.6); max-width: 95vw;
      }

      #btn-row { display: flex; gap: 10px; }

      button {
        background: rgba(255, 255, 255, 0.05); border: 1px solid rgba(255, 255, 255, 0.2);
        color: #ddd; padding: 10px 20px; font-size: 13px; text-transform: uppercase;
        letter-spacing: 1px; cursor: pointer; border-radius: 12px; transition: all 0.2s ease;
        outline: none; font-weight: 700;
      }
      button:hover { background: rgba(255, 255, 255, 0.2); transform: translateY(-2px); }

      /* Mode Buttons */
      button#btn-attack.active { background: #ff4757; border-color: #ff4757; color: white; box-shadow: 0 0 20px rgba(255, 71, 87, 0.5); }
      button#btn-pressure.active { background: #ffa502; border-color: #ffa502; color: white; box-shadow: 0 0 20px rgba(255, 165, 2, 0.5); }
      button#btn-push.active { background: #bdc3c7; border-color: #bdc3c7; color: #333; box-shadow: 0 0 20px rgba(189, 195, 199, 0.5); }
      button#btn-chill.active { background: #2ed573; border-color: #2ed573; color: white; box-shadow: 0 0 20px rgba(46, 213, 115, 0.5); }

      /* Mute Button State */
      button#btn-audio.active { background: #00eaff; border-color: #00eaff; color: #000; box-shadow: 0 0 15px rgba(0, 234, 255, 0.4); }
      button#btn-audio.muted { background: #ff0000; border-color: #ff0000; color: white; }

      .slider-row { width: 100%; display: flex; flex-direction: row; gap: 25px; min-width: 300px; align-items: flex-end; }
      
      .slider-container { 
        display: flex; flex-direction: column; gap: 8px; flex: 1; 
        color: rgba(255,255,255,0.9); font-size: 11px; text-transform: uppercase; font-weight: 600; 
      }
      
      .label-row { display: flex; justify-content: space-between; width: 100%; }
      .val-display { color: #00eaff; font-family: monospace; font-size: 12px; }
      
      input[type=range] { -webkit-appearance: none; width: 100%; background: transparent; }
      input[type=range]::-webkit-slider-thumb { -webkit-appearance: none; height: 14px; width: 14px; border-radius: 50%; background: #ffffff; cursor: pointer; margin-top: -5px; box-shadow: 0 0 8px rgba(255,255,255,0.8); }
      input[type=range]::-webkit-slider-runnable-track { width: 100%; height: 4px; cursor: pointer; background: rgba(255,255,255,0.2); border-radius: 2px; }

      #audio-debug {
        position: absolute; top: 10px; right: 10px; background: rgba(0,0,0,0.7);
        color: #0f0; font-family: monospace; font-size: 11px; padding: 8px;
        border-radius: 4px; display: none;
      }
    </style>
  </head>
  <body>

    <div id="audio-debug">
      Density: <span id="pressure-load">0%</span> | 
      Force: <span id="debug-force">0.1</span>
    </div>

    <div id="ui-container">
      <div id="btn-row">
        <button id="btn-attack" onclick="setMode('attack')">Attack</button>
        <button id="btn-pressure" onclick="setMode('pressure')">Pressure</button>
        <button id="btn-push" onclick="setMode('pushback')">Push Back</button>
        <button id="btn-chill" class="active" onclick="setMode('chill')">Chill</button>
      </div>
      
      <div class="slider-row">
        <div class="slider-container">
          <div class="label-row">
            <span>Swarm Force</span>
            <span id="val-force" class="val-display">0.10</span>
          </div>
          <input type="range" id="intensitySlider" min="0.01" max="1.5" step="0.01" value="0.1">
        </div>
        
        <!-- Audio Control Group -->
        <div style="display: flex; gap: 10px; flex: 1.2; align-items: flex-end;">
            <div class="slider-container">
            <div class="label-row">
                <span>Master Vol</span>
                <span id="val-vol" class="val-display">40%</span>
            </div>
            <input type="range" id="volumeSlider" min="0.0" max="1.0" step="0.05" value="0.40">
            </div>
            <button id="btn-audio" class="active" onclick="toggleAudio()" style="height: 42px; min-width: 80px; margin-bottom: 2px; font-size: 11px;">ON</button>
        </div>
      </div>
      
      <div style="width: 100%; display: flex; justify-content: space-between; align-items: center; gap: 15px; margin-top: 5px; padding-top: 15px; border-top: 1px solid rgba(255,255,255,0.1);">
        <button onclick="changeFence(-1)" style="padding: 8px 16px;">◀ Prev Fence</button>
        <div style="flex: 1; text-align: center; color: rgba(255,255,255,0.9); font-size: 11px; text-transform: uppercase; font-weight: 600;">
          <div id="fence-name" style="color: #00eaff; font-size: 13px; margin-bottom: 3px;">Simple Wire</div>
          <div id="fence-id" style="color: rgba(255,255,255,0.5); font-size: 10px;">Design 1/7</div>
        </div>
        <button onclick="changeFence(1)" style="padding: 8px 16px;">Next Fence ▶</button>
      </div>
    </div>

    <a-scene stats background="color: #050508" renderer="antialias: true; colorManagement: true; sortObjects: true;" xr-mode-ui>
      
      <a-entity light="type: ambient; intensity: 0.3; color: #ffffff"></a-entity>
      <a-entity light="type: point; intensity: 1.2; distance: 10; decay: 2; color: #00eaff" position="0 0 0"></a-entity>
      <a-entity light="type: directional; intensity: 0.5; position: 2 4 3"></a-entity>

      <!-- SAFE SPHERE COMPONENT -->
      <a-entity id="main-safe-sphere" 
                safe-sphere="
                  box_size: 6;
                  safe_sphere_radius_chill: 1.5;
                  safe_sphere_radius_attack: 1.4;
                  safe_sphere_radius_pressure: 1.0;
                  safe_sphere_radius_pushback: 1.6;
                  balls_radius_min: 0.05;
                  balls_radius_max: 0.2;
                  number_of_balls: 100;
                  swarm_force: 0.05;
                  master_vol: 0.4;
                  with_impact_sounds: true;
                  color_chill: #00d2d3;
                  color_attack: #ff4757;
                  color_pressure: #f1c40f;
                  color_pushback: #bdc3c7;
                "
                position="0 0 0">
      </a-entity>

      <a-entity id="rig" movement-controls position="0.5 0 0">
        <a-entity id="camera" camera look-controls="fly: true" wasd-controls="acceleration:15" position="0 0 0"></a-entity>
        <a-entity id="leftHand" hand-controls="hand: left; handModelStyle: lowPoly; color: #FF0000"></a-entity>
        <a-entity id="rightHand" hand-controls="hand: right; handModelStyle: lowPoly; color: #0000FF"></a-entity>
      </a-entity>

    </a-scene>

    <script>
      // --- Global Audio Engine Class ---
      class EnhancedImpactEngine {
        constructor(volume) {
          const AudioContext = window.AudioContext || window.webkitAudioContext;
          this.ctx = new AudioContext();
          this.maxVoices = 8; 
          this.voicePool = [];
          this.lastTriggerTime = 0;
          this.minTimeBetweenTriggers = 15; 
          this.impactQueue = [];
          this.isProcessingQueue = false;
          this.masterGain = this.ctx.createGain();
          this.masterGain.gain.value = volume;
          this.limiter = this.ctx.createDynamicsCompressor();
          this.limiter.threshold.value = -2;
          this.limiter.ratio.value = 20;
          this.limiter.attack.value = 0.001;
          this.limiter.connect(this.masterGain);
          this.masterGain.connect(this.ctx.destination);
          this.convolver = this.ctx.createConvolver();
          this.wetGain = this.ctx.createGain();
          this.wetGain.gain.value = 0.3; 
          this.dryGain = this.ctx.createGain();
          this.dryGain.gain.value = 0.8;
          this.convolver.connect(this.wetGain);
          this.wetGain.connect(this.limiter);
          this.dryGain.connect(this.limiter);
          this.createMassiveHallImpulse();
          this.initVoicePool();
        }
        createMassiveHallImpulse() {
          const length = this.ctx.sampleRate * 3.0;
          const impulse = this.ctx.createBuffer(2, length, this.ctx.sampleRate);
          for (let c = 0; c < 2; c++) {
            const d = impulse.getChannelData(c);
            for (let i = 0; i < length; i++) d[i] = (Math.random() * 2 - 1) * Math.pow(1 - i / length, 3);
          }
          this.convolver.buffer = impulse;
        }
        initVoicePool() { for (let i=0; i<this.maxVoices; i++) this.voicePool.push({ id: i, inUse: false }); }
        setVolume(val) { this.masterGain.gain.setTargetAtTime(val, this.ctx.currentTime, 0.05); }
        clearQueue() { this.impactQueue = []; }
        
        play(velocity = 1.0) {
          // Safety check if context is suspended or closed
          if (this.ctx.state === 'suspended' || this.ctx.state === 'closed') return;
          
          const now = performance.now();
          if (now - this.lastTriggerTime < this.minTimeBetweenTriggers) {
            if (this.impactQueue.length < 15) this.impactQueue.push({ velocity });
            if (!this.isProcessingQueue) this.processQueue();
            return;
          }
          this.lastTriggerTime = now;
          this.triggerStandardImpact(velocity);
        }
        async processQueue() {
          this.isProcessingQueue = true;
          while (this.impactQueue.length > 0) {
            if (this.ctx.state === 'suspended' || this.ctx.state === 'closed') break;
            const now = performance.now();
            if (now - this.lastTriggerTime >= this.minTimeBetweenTriggers) {
              const impact = this.impactQueue.shift();
              this.lastTriggerTime = now;
              this.triggerStandardImpact(impact.velocity);
            }
            await new Promise(r => setTimeout(r, 5));
          }
          this.isProcessingQueue = false;
        }
        triggerStandardImpact(velocity) {
          const voice = this.voicePool.find(v => !v.inUse);
          if (!voice) return;
          voice.inUse = true;
          const t = this.ctx.currentTime + 0.005; 
          const osc = this.ctx.createOscillator();
          const gain = this.ctx.createGain();
          const startFreq = 180 + Math.random() * 40;
          osc.frequency.setValueAtTime(startFreq, t);
          osc.frequency.setTargetAtTime(40, t, 0.03); 
          gain.gain.setValueAtTime(0, t);
          gain.gain.linearRampToValueAtTime(velocity * 1.5, t + 0.01); 
          gain.gain.setTargetAtTime(0, t + 0.01, 0.04); 
          osc.connect(gain);
          gain.connect(this.dryGain);
          gain.connect(this.convolver);
          osc.start(t);
          osc.stop(t + 0.3);
          setTimeout(() => { voice.inUse = false; try{osc.disconnect(); gain.disconnect();}catch(e){} }, 350);
        }
        playPressureCrush(density, force) {
          if (this.ctx.state === 'suspended' || this.ctx.state === 'closed') return;
          
          const now = this.ctx.currentTime;
          const d = Math.max(0, Math.min(1, density)); 
          const f = Math.max(0.01, Math.min(1.5, force));
          const masterVol = Math.min(0.8, d * 1.0); 
          const attackTime = 0.01 + (1.5 - f) * 0.2; 
          const releaseTime = 0.2 + (1.5 - f) * 1.0; 
          const baseFreq = 40 + (f * 30); 
          const subOsc = this.ctx.createOscillator();
          const subGain = this.ctx.createGain();
          subOsc.type = 'sine';
          subOsc.frequency.setValueAtTime(baseFreq, now);
          subOsc.frequency.exponentialRampToValueAtTime(20, now + releaseTime);
          subGain.gain.setValueAtTime(0, now);
          subGain.gain.linearRampToValueAtTime(masterVol, now + attackTime);
          subGain.gain.exponentialRampToValueAtTime(0.001, now + releaseTime);
          const crushOsc = this.ctx.createOscillator();
          const crushGain = this.ctx.createGain();
          const filter = this.ctx.createBiquadFilter();
          crushOsc.type = 'sawtooth';
          crushOsc.frequency.setValueAtTime(baseFreq * 2, now);
          crushOsc.frequency.exponentialRampToValueAtTime(20, now + (releaseTime * 0.5));
          filter.type = 'lowpass';
          filter.Q.value = 1 + (f * 4); 
          filter.frequency.setValueAtTime(150 + (f * 1200), now);
          filter.frequency.exponentialRampToValueAtTime(50, now + releaseTime);
          crushGain.gain.setValueAtTime(0, now);
          crushGain.gain.linearRampToValueAtTime(masterVol * 0.6, now + (attackTime * 0.5));
          crushGain.gain.exponentialRampToValueAtTime(0.001, now + (releaseTime * 0.8));
          subOsc.connect(subGain); subGain.connect(this.dryGain); subGain.connect(this.convolver);
          crushOsc.connect(filter); filter.connect(crushGain); crushGain.connect(this.dryGain); crushGain.connect(this.convolver);
          subOsc.start(now); subOsc.stop(now + releaseTime + 0.1);
          crushOsc.start(now); crushOsc.stop(now + releaseTime + 0.1);
        }
      }

      // --- Visual Component: Pooled Ring ---
      AFRAME.registerComponent('pooled-ring', {
        init: function() {
          this.isActive = false; this.lifeTime = 0; this.timer = 0;
          this.el.setAttribute('geometry', { primitive: 'ring', radiusInner: 0.085, radiusOuter: 0.1, segmentsTheta: 32 });
          this.el.setAttribute('material', { color: '#ffd700', shader: 'flat', transparent: true, opacity: 0, side: 'double', blending: 'additive', depthTest: false, depthWrite: false });
          this.el.object3D.visible = false;
        },
        activate: function(pos, normal, color) {
          this.isActive = true; this.timer = 0; this.lifeTime = 400 + Math.random() * 600; 
          this.el.object3D.position.copy(pos).addScaledVector(normal, 0.02);
          this.el.object3D.lookAt(new THREE.Vector3().copy(pos).add(normal));
          this.el.object3D.visible = true;
          const mesh = this.el.getObject3D('mesh');
          if (mesh) { mesh.material.opacity = 1.0; mesh.material.color.set(color); }
        },
        tick: function(t, dt) {
          if (!this.isActive) return;
          this.timer += dt;
          if (this.timer >= this.lifeTime) { this.isActive = false; this.el.object3D.visible = false; return; }
          const progress = this.timer / this.lifeTime;
          if (this.el.getObject3D('mesh')) this.el.getObject3D('mesh').material.opacity = 1.0 - progress;
        }
      });

      // --- CONSTANTS for Fence Designs ---
      const FENCE_DESIGNS = [
        { id: 0, name: 'Simple Wire' },
        { id: 1, name: 'Nested Harmonic Shells' },
        { id: 2, name: 'Veil Lattice Aurora' },
        { id: 3, name: 'Petal Arc Bloom' },
        { id: 4, name: 'Fractal Mesh Dissolve' },
        { id: 5, name: 'Halo Bead Filigree' },
        { id: 6, name: 'Connected Bead Network' }
      ];

      // --- SAFE SPHERE COMPONENT ---
      AFRAME.registerComponent('safe-sphere', {
        schema: {
          box_size: { default: 6 },
          safe_sphere_radius_chill: { default: 1.5 },
          safe_sphere_radius_attack: { default: 1.4 },
          safe_sphere_radius_pressure: { default: 1.0 },
          safe_sphere_radius_pushback: { default: 1.6 },
          balls_radius_min: { default: 0.05 },
          balls_radius_max: { default: 0.2 },
          number_of_balls: { default: 100 },
          color_chill: { default: '#00d2d3' },
          color_attack: { default: '#ff4757' },
          color_pressure: { default: '#f1c40f' },
          color_pushback: { default: '#bdc3c7' },
          swarm_force: { default: 0.05 },
          master_vol: { default: 0.4 },
          with_impact_sounds: { default: true }
        },

        init: function() {
          this.mode = 'chill';
          this.targetRadius = this.data.safe_sphere_radius_chill;
          this.soundEngine = new EnhancedImpactEngine(this.data.master_vol);
          this.balls = [];
          this.fenceObjects = [];
          this.currentFenceIndex = 0;
          
          // Audio state initialization
          this.isMuted = !this.data.with_impact_sounds;
          if(this.isMuted) {
            this.soundEngine.ctx.suspend();
          }

          // Palettes
          this.palettes = {
            chill: ['#00d2d3', '#48dbfb', '#0abde3', '#54a0ff'],
            attack: ['#ff4757', '#ff6b81', '#e17055', '#d63031'],
            pressure: ['#8e44ad', '#9b59b6', '#f1c40f', '#e67e22'],
            pushback: ['#bdc3c7', '#ecf0f1', '#95a5a6', '#7f8c8d']
          };

          // Physics vectors
          this.vTemp = new THREE.Vector3();
          this.vDir = new THREE.Vector3();
          this.vNormal = new THREE.Vector3();

          // Pressure bucket logic
          this.pressureBucketCurrent = 0;
          this.pressureBucketPrevious = 0;
          this.pressureTimer = 0;

          this.createVisualStructure();
          this.createPool();
          this.createBalls();
          this.createFenceDesigns(); 
          this.set_fence_style('Simple Wire'); 

          // Ambient colors
          this.colorA = new THREE.Color(this.data.color_chill);
          this.colorB = new THREE.Color('#006266');
          this.ambientColor = new THREE.Color();
        },

        createVisualStructure: function() {
          this.sphereContainer = document.createElement('a-entity');
          this.el.appendChild(this.sphereContainer);
          
          // Core
          this.safeCore = document.createElement('a-sphere');
          this.safeCore.setAttribute('radius', '1'); 
          this.safeCore.setAttribute('segments-width', 64);
          this.safeCore.setAttribute('segments-height', 64);
          this.safeCore.setAttribute('material', 'color: #00a8ff; opacity: 0.12; transparent: true; roughness: 0.1; metalness: 0.0; side: double; blending: additive; depthWrite: false');
          this.sphereContainer.appendChild(this.safeCore);

          // Wire
          this.safeWire = document.createElement('a-sphere');
          this.safeWire.setAttribute('radius', '1.01');
          this.safeWire.setAttribute('segments-width', 24);
          this.safeWire.setAttribute('segments-height', 16);
          this.safeWire.setAttribute('material', 'color: #48dbfb; wireframe: true; opacity: 0.2; transparent: true; side: double; depthWrite: false');
          this.sphereContainer.appendChild(this.safeWire);

          this.sphereContainer.object3D.scale.set(this.targetRadius, this.targetRadius, this.targetRadius);
        },

        createPool: function() {
          this.ringPool = [];
          this.poolIndex = 0;
          const poolContainer = document.createElement('a-entity');
          this.el.appendChild(poolContainer);
          for(let i=0; i<50; i++) {
             let el = document.createElement('a-entity');
             el.setAttribute('pooled-ring', '');
             poolContainer.appendChild(el);
             this.ringPool.push(el);
          }
        },

        createBalls: function() {
          const bound = this.data.box_size / 2;
          for(let i=0; i<this.data.number_of_balls; i++) {
            let ball = document.createElement('a-sphere');
            let r = this.data.balls_radius_min + Math.random() * (this.data.balls_radius_max - this.data.balls_radius_min);
            ball.setAttribute('radius', r);
            ball.setAttribute('segments-width', 8); ball.setAttribute('segments-height', 8);
            ball.setAttribute('material', 'shader: standard; roughness: 0.3; metalness: 0.5;');
            
            let pos = new THREE.Vector3(
              (Math.random() - 0.5) * this.data.box_size,
              (Math.random() - 0.5) * this.data.box_size,
              (Math.random() - 0.5) * this.data.box_size
            );
            if (pos.length() < this.data.safe_sphere_radius_chill) pos.setLength(this.data.safe_sphere_radius_chill + 0.5);
            
            ball.object3D.position.copy(pos);
            
            const col = this.palettes.chill[Math.floor(Math.random() * this.palettes.chill.length)];
            
            ball.userData = { 
              velocity: new THREE.Vector3(0,0,0), 
              colorTarget: new THREE.Color(col), 
              currentColor: new THREE.Color(col), 
              isAttacking: false, attackCooldown: 0, lastImpactTime: 0,
              radius: r
            };
            this.el.sceneEl.appendChild(ball);
            this.balls.push(ball);
          }
        },

        // --- API Methods ---
        activate_chill: function() { this.setMode('chill'); },
        activate_attack: function() { this.setMode('attack'); },
        activate_pressure: function() { this.setMode('pressure'); },
        activate_pushback: function() { this.setMode('pushback'); },
        set_swarm_force: function(val) { this.data.swarm_force = parseFloat(val); },
        set_master_vol: function(val) {
          this.data.master_vol = parseFloat(val);
          if(this.soundEngine) this.soundEngine.setVolume(this.data.master_vol);
        },
        set_fence_style: function(name) {
          const design = FENCE_DESIGNS.find(d => d.name === name);
          if (design) this.switchToFenceDesign(design.id);
        },
        
        // NEW METHODS: Mute/Unmute
        mute: function() {
            this.isMuted = true;
            if(this.soundEngine && this.soundEngine.ctx) {
                // Suspend the audio context to stop processing and save CPU
                this.soundEngine.ctx.suspend();
                this.soundEngine.clearQueue();
            }
        },
        
        unmute: function() {
            this.isMuted = false;
            if(this.soundEngine && this.soundEngine.ctx) {
                // Resume context
                this.soundEngine.ctx.resume();
            }
        },

        setMode: function(mode) {
          if(this.soundEngine) this.soundEngine.clearQueue();
          this.mode = mode;
          
          if (mode === 'chill') this.targetRadius = this.data.safe_sphere_radius_chill;
          else if (mode === 'attack') this.targetRadius = this.data.safe_sphere_radius_attack;
          else if (mode === 'pressure') this.targetRadius = this.data.safe_sphere_radius_pressure;
          else if (mode === 'pushback') this.targetRadius = this.data.safe_sphere_radius_pushback;

          const palette = this.palettes[mode];
          this.balls.forEach(ball => {
            ball.userData.colorTarget.set(palette[Math.floor(Math.random() * palette.length)]);
          });
        },

        // --- Tick Loop (Animation & Physics) ---
        tick: function(time, timeDelta) {
          if (timeDelta > 100) return;
          const dt = timeDelta / 1000; 
          const now = performance.now();

          this.animateFences(time);
          this.animateAmbientColor(time);

          let currentScale = this.sphereContainer.object3D.scale.x;
          let scaleDiff = this.targetRadius - currentScale;
          if (Math.abs(scaleDiff) > 0.001) {
            let speed = (this.mode === 'pushback') ? 0.3 : 2.0; 
            let newScale = currentScale + (scaleDiff * speed * dt);
            this.sphereContainer.object3D.scale.set(newScale, newScale, newScale);
          }
          const currentCollisionRadius = 1.0 * this.sphereContainer.object3D.scale.x; 

          // PRESSURE SOUND LOGIC
          // We only process this if not muted and not explicitly disabled via param
          const audioEnabled = !this.isMuted && this.data.with_impact_sounds;

          if (this.mode === 'pressure') {
            this.pressureTimer += timeDelta;
            if (this.pressureTimer >= 1000) {
              const totalImpacts = this.pressureBucketCurrent + this.pressureBucketPrevious;
              const maxPossibleImpacts = this.data.number_of_balls * 20; 
              const density = Math.min(1.0, totalImpacts / maxPossibleImpacts);
              
              const debugEl = document.getElementById('pressure-load');
              if(debugEl) debugEl.innerText = Math.round(density * 100) + '%';

              if (audioEnabled) {
                  this.soundEngine.playPressureCrush(density, this.data.swarm_force);
              }
              
              this.pressureBucketPrevious = this.pressureBucketCurrent;
              this.pressureBucketCurrent = 0;
              this.pressureTimer = 0;
            }
          } else {
            this.pressureBucketCurrent = 0; this.pressureTimer = 0;
          }

          // SWARM LOGIC
          const bound = this.data.box_size / 2;
          const origin = new THREE.Vector3(0,0,0);

          for (let i = 0; i < this.balls.length; i++) {
            let ball = this.balls[i];
            let uData = ball.userData;
            let pos = ball.object3D.position;

            uData.currentColor.lerp(uData.colorTarget, 0.08);
            const mesh = ball.getObject3D('mesh');
            if(mesh) { 
              mesh.material.color.setHex(uData.currentColor.getHex()); 
              mesh.material.emissive.setHex(uData.currentColor.getHex()); 
              mesh.material.emissiveIntensity = 0.5; 
            }

            let dist = pos.length();
            if (this.mode === 'chill' || this.mode === 'pushback') {
               uData.velocity.multiplyScalar(0.98); 
               this.applyJitter(uData.velocity, 0.005 * this.data.swarm_force);
               if(uData.velocity.length() < 0.02) uData.velocity.normalize().multiplyScalar(0.02);
               uData.isAttacking = false;
            } else if (this.mode === 'attack') {
               if (uData.attackCooldown > 0) uData.attackCooldown -= dt;
               if (!uData.isAttacking && uData.attackCooldown <= 0) {
                  if (Math.random() < 0.02 * this.data.swarm_force) {
                     uData.isAttacking = true;
                     this.vDir.copy(origin).sub(pos).normalize();
                     uData.velocity.copy(this.vDir).multiplyScalar((3.5 + this.data.swarm_force * 2.0) * dt);
                  } else {
                     this.applyJitter(uData.velocity, 0.02 * this.data.swarm_force);
                  }
               }
            } else if (this.mode === 'pressure') {
               this.vDir.copy(origin).sub(pos).normalize();
               uData.velocity.addScaledVector(this.vDir, 0.04 * this.data.swarm_force);
               uData.velocity.multiplyScalar(0.96);
               uData.isAttacking = false;
            }
            
            pos.add(uData.velocity);

            if (Math.abs(pos.x) > bound) { pos.x = Math.sign(pos.x)*bound; uData.velocity.x *= -0.8; }
            if (Math.abs(pos.y) > bound) { pos.y = Math.sign(pos.y)*bound; uData.velocity.y *= -0.8; }
            if (Math.abs(pos.z) > bound) { pos.z = Math.sign(pos.z)*bound; uData.velocity.z *= -0.8; }

            let minDist = currentCollisionRadius + uData.radius;
            if (dist < minDist) {
               this.vNormal.copy(pos).normalize();
               const canPlaySound = (now - uData.lastImpactTime) > 50; 

               if (this.mode === 'attack' && uData.isAttacking) {
                  this.spawnRing(pos, this.vNormal, uData.currentColor);
                  if (canPlaySound && audioEnabled) {
                    this.soundEngine.play(Math.min(1.0, uData.velocity.length() * 0.3));
                    uData.lastImpactTime = now;
                  }
                  uData.isAttacking = false; uData.attackCooldown = 0.5;
                  uData.velocity.multiplyScalar(0.2); 
               } 
               else if (this.mode === 'pressure') {
                  if (canPlaySound) {
                      this.pressureBucketCurrent++; 
                      uData.lastImpactTime = now;
                      this.spawnRing(pos, this.vNormal, uData.currentColor);
                  }
               }

               let vDotN = uData.velocity.dot(this.vNormal);
               this.vTemp.copy(this.vNormal).multiplyScalar(2 * vDotN);
               uData.velocity.sub(this.vTemp);
               pos.copy(this.vNormal).multiplyScalar(minDist);
               uData.velocity.addScaledVector(this.vNormal, 0.01);
            }
          }

          if (this.mode !== 'attack') {
             this.handleBallCollisions();
          }
        },

        applyJitter: function(vel, force) {
           vel.x += (Math.random() * 2 - 1) * force;
           vel.y += (Math.random() * 2 - 1) * force;
           vel.z += (Math.random() * 2 - 1) * force;
        },

        spawnRing: function(pos, normal, color) {
            let poolEl = this.ringPool[this.poolIndex];
            this.poolIndex = (this.poolIndex + 1) % this.ringPool.length;
            if (poolEl.components['pooled-ring']) poolEl.components['pooled-ring'].activate(pos, normal, color);
        },

        handleBallCollisions: function() {
           const rSum = this.data.balls_radius_max * 1.5; 
           const rSumSq = rSum * rSum;
           for (let i = 0; i < this.balls.length; i++) {
             for (let j = i + 1; j < this.balls.length; j++) {
                let b1 = this.balls[i].object3D.position; 
                let b2 = this.balls[j].object3D.position;
                let distSq = b1.distanceToSquared(b2);
                if (distSq < rSumSq) {
                   let dist = Math.sqrt(distSq);
                   this.vTemp.copy(b1).sub(b2).normalize();
                   let overlap = (rSum - dist) * 0.5;
                   b1.addScaledVector(this.vTemp, overlap); 
                   b2.addScaledVector(this.vTemp, -overlap);
                   let v1 = this.balls[i].userData.velocity; 
                   let v2 = this.balls[j].userData.velocity;
                   this.vDir.copy(this.vTemp).multiplyScalar(0.01); 
                   v1.add(this.vDir).multiplyScalar(0.95); 
                   v2.sub(this.vDir).multiplyScalar(0.95);
                }
             }
           }
        },

        animateAmbientColor: function(time) {
          const alpha = (Math.sin(time * 0.001) + 1) / 2;
          this.ambientColor.copy(this.colorB).lerp(this.colorA, alpha);
          const hex = this.ambientColor.getHex();
          if(this.safeCore) this.safeCore.getObject3D('mesh').material.color.setHex(hex);
        },

        createFenceDesigns: function() {
            this.fenceObjects[1] = this.createNestedShells();
            this.fenceObjects[2] = this.createVeilLattice();
            this.fenceObjects[3] = this.createPetalBloom();
            this.fenceObjects[4] = this.createFractalMesh();
            this.fenceObjects[5] = this.createHaloBeads();
            this.fenceObjects[6] = this.createConnectedBeads();
        },

        switchToFenceDesign: function(index) {
            this.currentFenceIndex = index;
            if(this.safeWire) this.safeWire.object3D.visible = (index === 0);
            for (let i = 1; i < this.fenceObjects.length; i++) {
                if (this.fenceObjects[i]) this.fenceObjects[i].visible = (i === index);
            }
        },

        animateFences: function(time) {
            if (this.fenceObjects[1] && this.fenceObjects[1].visible) {
                const consciousnessWave = Math.sin(time * 0.00012) * 0.5 + 0.5;
                this.fenceObjects[1].children.forEach((mesh, idx) => {
                    if (mesh.userData.isShell) {
                        const phase = mesh.userData.phaseOffset;
                        const breathe = 1.0 + Math.sin((time + phase) * 0.0005) * 0.012;
                        mesh.scale.set(breathe, breathe, breathe);
                        if (mesh.material.uniforms) {
                            mesh.material.uniforms.time.value = time;
                            mesh.material.uniforms.baseOpacity.value = (0.15 + idx * 0.05) * (0.95 + consciousnessWave * 0.1);
                        }
                    }
                });
            }
            if (this.fenceObjects[2] && this.fenceObjects[2].visible) {
                const consciousShimmer = Math.sin(time * 0.0001) * 0.5 + 0.5;
                this.fenceObjects[2].children.forEach(child => {
                    if (child.userData.isRibbon && child.material.uniforms) {
                        child.material.uniforms.time.value = time;
                        child.material.opacity = 0.35 * (0.9 + consciousShimmer * 0.15);
                    }
                });
            }
            if (this.fenceObjects[3] && this.fenceObjects[3].visible) {
                const consciousGlow = Math.sin(time * 0.00013) * 0.5 + 0.5;
                this.fenceObjects[3].children.forEach(child => {
                    if (child.userData.isPetal && child.material.uniforms) {
                        child.material.uniforms.time.value = time;
                        const petalBreath = 1.0 + consciousGlow * 0.006;
                        child.scale.set(petalBreath, petalBreath, petalBreath);
                    }
                });
            }
            if (this.fenceObjects[4] && this.fenceObjects[4].visible) {
                this.fenceObjects[4].children.forEach(child => {
                    if (child.userData.isFractalLayer && child.material.uniforms) {
                        child.material.uniforms.time.value = time;
                        child.rotation.y = Math.sin(time * 0.00004) * 0.01;
                    }
                });
            }
            [5, 6].forEach(idx => {
                if (this.fenceObjects[idx] && this.fenceObjects[idx].visible) {
                    this.fenceObjects[idx].children.forEach(child => {
                        if(child.material.uniforms) child.material.uniforms.time.value = time;
                        if(child.userData.isBead) {
                           const hueShift = Math.sin(time * 0.00008) * 0.08;
                           const baseColor = child.userData.baseColor;
                           const hsl = {}; baseColor.getHSL(hsl);
                           child.material.color.setHSL(hsl.h + hueShift, hsl.s, hsl.l);
                        }
                    });
                }
            });
        },

        // --- Geometry Creators ---
        createNestedShells: function() {
            const group = new THREE.Group();
            const radii = [1.0, 1.02, 1.04]; 
            const colors = [new THREE.Color('#7ff9ff'), new THREE.Color('#33c7ff'), new THREE.Color('#c9ffff')];
            const phases = [0, 4000, 8000];
            radii.forEach((radius, idx) => {
                const geo = new THREE.IcosahedronGeometry(radius, 2);
                const mat = new THREE.ShaderMaterial({
                    uniforms: { time: {value:0}, color1: {value:colors[idx]}, color2: {value:colors[idx].clone().multiplyScalar(0.7)}, phase: {value:phases[idx]}, baseOpacity: {value: 0.15} },
                    vertexShader: `varying vec3 vP; void main(){vP=position;gl_Position=projectionMatrix*modelViewMatrix*vec4(position,1.0);}`,
                    fragmentShader: `uniform float time; uniform vec3 color1; uniform vec3 color2; uniform float baseOpacity; varying vec3 vP; void main(){ float d=length(vP); float a=baseOpacity*(1.0-abs(vP.y/d)*0.15); gl_FragColor=vec4(mix(color2,color1,abs(vP.y/d)), a); }`,
                    transparent: true, side: THREE.DoubleSide, wireframe: true, blending: THREE.AdditiveBlending, depthWrite: false
                });
                const mesh = new THREE.LineSegments(new THREE.EdgesGeometry(geo), mat);
                mesh.userData = { isShell: true, phaseOffset: phases[idx] };
                group.add(mesh);
            });
            this.sphereContainer.object3D.add(group);
            return group;
        },
        createVeilLattice: function() {
            const group = new THREE.Group();
            const geo = new THREE.IcosahedronGeometry(1.01, 3);
            const mat = new THREE.LineBasicMaterial({ color: '#d6fff6', transparent: true, opacity: 0.2, blending: THREE.AdditiveBlending });
            group.add(new THREE.LineSegments(new THREE.EdgesGeometry(geo), mat));
            this.sphereContainer.object3D.add(group);
            return group;
        },
        createPetalBloom: function() {
            const group = new THREE.Group();
            const count = 16;
            for(let i=0; i<count; i++){
               const curve = new THREE.EllipseCurve(0,0, 1.01, 0.5, 0, Math.PI*2, false, 0);
               const pts = curve.getPoints(50).map(p => new THREE.Vector3(p.x, p.y, 0));
               const geo = new THREE.BufferGeometry().setFromPoints(pts);
               const mat = new THREE.LineBasicMaterial({ color: '#4ddde8', transparent: true, opacity: 0.4, blending: THREE.AdditiveBlending });
               const line = new THREE.Line(geo, mat);
               line.rotation.y = (i/count)*Math.PI;
               line.userData.isPetal = true;
               group.add(line);
            }
            this.sphereContainer.object3D.add(group);
            return group;
        },
        createFractalMesh: function() {
            const group = new THREE.Group();
            [0, 1].forEach(idx => {
                const geo = new THREE.IcosahedronGeometry(1.01 + idx*0.01, idx+1);
                const mat = new THREE.LineBasicMaterial({ color: idx===0?'#73f6e8':'#186265', transparent: true, opacity: 0.2 });
                const mesh = new THREE.LineSegments(new THREE.EdgesGeometry(geo), mat);
                mesh.userData.isFractalLayer = true;
                group.add(mesh);
            });
            this.sphereContainer.object3D.add(group);
            return group;
        },
        createHaloBeads: function() {
            const group = new THREE.Group();
            for(let i=0; i<40; i++) {
                const mesh = new THREE.Mesh(new THREE.SphereGeometry(0.02, 8, 8), new THREE.MeshBasicMaterial({ color: '#7de0d5' }));
                mesh.position.randomDirection().multiplyScalar(1.01);
                mesh.userData = { isBead: true, baseColor: new THREE.Color('#7de0d5') };
                group.add(mesh);
            }
            this.sphereContainer.object3D.add(group);
            return group;
        },
        createConnectedBeads: function() {
            const group = new THREE.Group();
            const geo = new THREE.IcosahedronGeometry(1.01, 1);
            const pos = geo.attributes.position.array;
            for(let i=0; i<pos.length; i+=3){
                const v = new THREE.Vector3(pos[i], pos[i+1], pos[i+2]);
                const mesh = new THREE.Mesh(new THREE.SphereGeometry(0.025, 8, 8), new THREE.MeshBasicMaterial({color: '#6ee3d6'}));
                mesh.position.copy(v);
                mesh.userData = { isBead: true, baseColor: new THREE.Color('#6ee3d6') };
                group.add(mesh);
            }
            const lineGeo = new THREE.WireframeGeometry(geo);
            const line = new THREE.LineSegments(lineGeo, new THREE.LineBasicMaterial({color: '#9df7ec', transparent:true, opacity:0.3}));
            group.add(line);
            this.sphereContainer.object3D.add(group);
            return group;
        }
      });

      // --- UI & Controller Scripts ---
      
      let currentFenceIndex = 0;
      const fenceNames = FENCE_DESIGNS.map(d => d.name);
      const intensitySlider = document.getElementById('intensitySlider');
      const volumeSlider = document.getElementById('volumeSlider');

      function getSphereComp() {
        const el = document.getElementById('main-safe-sphere');
        return el ? el.components['safe-sphere'] : null;
      }

      function setMode(mode) {
        const comp = getSphereComp();
        if (!comp) return;

        if(mode === 'chill') comp.activate_chill();
        if(mode === 'attack') comp.activate_attack();
        if(mode === 'pressure') comp.activate_pressure();
        if(mode === 'pushback') comp.activate_pushback();

        document.querySelectorAll('button').forEach(b => {
            // Don't remove active class from audio button
            if(b.id !== 'btn-audio') b.classList.remove('active');
        });
        
        const idMap = { 'attack': 'btn-attack', 'pressure': 'btn-pressure', 'pushback': 'btn-push', 'chill': 'btn-chill' };
        const btn = document.getElementById(idMap[mode]);
        if(btn) btn.classList.add('active');
      }

      intensitySlider.addEventListener('input', (e) => { 
        const val = parseFloat(e.target.value);
        document.getElementById('val-force').innerText = val.toFixed(2);
        document.getElementById('debug-force').innerText = val.toFixed(2);
        const comp = getSphereComp();
        if(comp) comp.set_swarm_force(val);
      });

      volumeSlider.addEventListener('input', (e) => { 
        const val = parseFloat(e.target.value);
        document.getElementById('val-vol').innerText = Math.round(val * 100) + '%';
        const comp = getSphereComp();
        if(comp) comp.set_master_vol(val);
      });

      function changeFence(direction) {
        currentFenceIndex = (currentFenceIndex + direction + fenceNames.length) % fenceNames.length;
        const name = fenceNames[currentFenceIndex];
        document.getElementById('fence-name').innerText = name;
        document.getElementById('fence-id').innerText = `Design ${currentFenceIndex + 1}/7`;
        const comp = getSphereComp();
        if(comp) comp.set_fence_style(name);
      }
      
      // AUDIO TOGGLE LOGIC
      let isAudioEnabled = true;
      function toggleAudio() {
          isAudioEnabled = !isAudioEnabled;
          const btn = document.getElementById('btn-audio');
          const comp = getSphereComp();
          
          if(isAudioEnabled) {
              btn.classList.remove('muted');
              btn.classList.add('active');
              btn.innerText = "ON";
              if(comp) comp.unmute();
          } else {
              btn.classList.remove('active');
              btn.classList.add('muted');
              btn.innerText = "MUTED";
              if(comp) comp.mute();
          }
      }

    </script>
  </body>
</html>